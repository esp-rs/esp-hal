// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32c5"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32c5"
    };
    ("arch") => {
        "riscv"
    };
    ("cores") => {
        1
    };
    ("cores", str) => {
        stringify!(1)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-c5_technical_reference_manual_en.pdf"
    };
    ("soc.cpu_has_csr_pc") => {
        true
    };
    ("soc.cpu_has_prv_mode") => {
        true
    };
    ("soc.rc_fast_clk_default") => {
        17500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(17500000)
    };
    ("soc.rc_slow_clock") => {
        136000
    };
    ("soc.rc_slow_clock", str) => {
        stringify!(136000)
    };
    ("interrupts.status_registers") => {
        3
    };
    ("interrupts.status_registers", str) => {
        stringify!(3)
    };
    ("rmt.ram_start") => {
        1610638336
    };
    ("rmt.ram_start", str) => {
        stringify!(1610638336)
    };
    ("rmt.channel_ram_size") => {
        48
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(48)
    };
    ("rmt.has_tx_immediate_stop") => {
        true
    };
    ("rmt.has_tx_loop_count") => {
        true
    };
    ("rmt.has_tx_loop_auto_stop") => {
        true
    };
    ("rmt.has_tx_carrier_data_only") => {
        true
    };
    ("rmt.has_tx_sync") => {
        true
    };
    ("rmt.has_rx_wrap") => {
        true
    };
    ("rmt.has_rx_demodulation") => {
        true
    };
    ("rmt.has_dma") => {
        false
    };
    ("rmt.has_per_channel_clock") => {
        false
    };
    ("rsa.size_increment") => {
        32
    };
    ("rsa.size_increment", str) => {
        stringify!(32)
    };
    ("rsa.memory_size_bytes") => {
        384
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(384)
    };
    ("sha.dma") => {
        true
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, no_run
/// // XTAL_CLK
///
/// fn configure_xtal_clk_impl(_clocks: &mut ClockTree, _config: XtalClkConfig) {
///     todo!()
/// }
///
/// // PLL_CLK
///
/// fn enable_pll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_FAST_CLK
///
/// fn enable_rc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL32K_CLK
///
/// fn enable_xtal32k_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // OSC_SLOW_CLK
///
/// fn enable_osc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_SLOW_CLK
///
/// fn enable_rc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F22M
///
/// fn enable_pll_f22m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F40M
///
/// fn enable_pll_f40m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F44M
///
/// fn enable_pll_f44m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F48M
///
/// fn enable_pll_f48m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F80M
///
/// fn enable_pll_f80m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F120M
///
/// fn enable_pll_f120m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F160M
///
/// fn enable_pll_f160m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F240M
///
/// fn enable_pll_f240m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // SOC_ROOT_CLK
///
/// fn enable_soc_root_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_soc_root_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<SocRootClkConfig>,
///     _new_selector: SocRootClkConfig,
/// ) {
///     todo!()
/// }
///
/// // CPU_CLK
///
/// fn enable_cpu_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_clk_impl(_clocks: &mut ClockTree, _new_config: CpuClkConfig) {
///     todo!()
/// }
///
/// // AHB_CLK
///
/// fn enable_ahb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ahb_clk_impl(_clocks: &mut ClockTree, _new_config: AhbClkConfig) {
///     todo!()
/// }
///
/// // APB_CLK
///
/// fn enable_apb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apb_clk_impl(_clocks: &mut ClockTree, _new_config: ApbClkConfig) {
///     todo!()
/// }
///
/// // XTAL_D2_CLK
///
/// fn enable_xtal_d2_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // LP_FAST_CLK
///
/// fn enable_lp_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_lp_fast_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LpFastClkConfig>,
///     _new_selector: LpFastClkConfig,
/// ) {
///     todo!()
/// }
///
/// // LP_SLOW_CLK
///
/// fn enable_lp_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_lp_slow_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LpSlowClkConfig>,
///     _new_selector: LpSlowClkConfig,
/// ) {
///     todo!()
/// }
///
/// // APBSARADC_FUNCTION_CLOCK
///
/// fn enable_apbsaradc_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apbsaradc_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<ApbsaradcFunctionClockConfig>,
///     _new_selector: ApbsaradcFunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // LEDC_FUNCTION_CLOCK
///
/// fn enable_ledc_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ledc_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LedcFunctionClockConfig>,
///     _new_selector: LedcFunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // MCPWM0_FUNCTION_CLOCK
///
/// fn enable_mcpwm0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mcpwm0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Mcpwm0FunctionClockConfig>,
///     _new_selector: Mcpwm0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // PARLIO_TX_FUNCTION_CLOCK
///
/// fn enable_parlio_tx_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_parlio_tx_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<ParlioTxFunctionClockConfig>,
///     _new_selector: ParlioTxFunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // RMT_FUNCTION_CLOCK
///
/// fn enable_rmt_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_rmt_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RmtFunctionClockConfig>,
///     _new_selector: RmtFunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // SYSTIMER_FUNCTION_CLOCK
///
/// fn enable_systimer_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_systimer_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<SystimerFunctionClockConfig>,
///     _new_selector: SystimerFunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_FUNCTION_CLOCK
///
/// fn enable_timg0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_CALIBRATION_CLOCK
///
/// fn enable_timg0_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_WDT_CLOCK
///
/// fn enable_timg0_wdt_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_wdt_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0WdtClockConfig>,
///     _new_selector: Timg0WdtClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_FUNCTION_CLOCK
///
/// fn enable_timg1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_CALIBRATION_CLOCK
///
/// fn enable_timg1_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_WDT_CLOCK
///
/// fn enable_timg1_wdt_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_wdt_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0WdtClockConfig>,
///     _new_selector: Timg0WdtClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART0_FUNCTION_CLOCK
///
/// fn enable_uart0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0FunctionClockConfig>,
///     _new_selector: Uart0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART1_FUNCTION_CLOCK
///
/// fn enable_uart1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0FunctionClockConfig>,
///     _new_selector: Uart0FunctionClockConfig,
/// ) {
///     todo!()
/// }
/// ```
macro_rules! define_clock_tree_types {
    () => {
        /// Selects the output frequency of `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum XtalClkConfig {
            /// 40 MHz
            _40,
            /// 48 MHz
            _48,
        }
        impl XtalClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    XtalClkConfig::_40 => 40000000,
                    XtalClkConfig::_48 => 48000000,
                }
            }
        }
        /// The list of clock signals that the `SOC_ROOT_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SocRootClkConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F160M`.
            PllF160m,
            /// Selects `PLL_F240M`.
            PllF240m,
        }
        /// Configures the `CPU_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = SOC_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct CpuClkConfig(u32);
        impl CpuClkConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 254).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 254u32,
                    "`CPU_CLK` divisor value must be between 0 and 254 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `AHB_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = SOC_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct AhbClkConfig(u32);
        impl AhbClkConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 254).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 254u32,
                    "`AHB_CLK` divisor value must be between 0 and 254 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `APB_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = AHB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApbClkConfig {
            /// Selects `DIVISOR = 0`.
            _0 = 0,
            /// Selects `DIVISOR = 1`.
            _1 = 1,
            /// Selects `DIVISOR = 3`.
            _3 = 3,
        }
        impl ApbClkConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    0 => ApbClkConfig::_0,
                    1 => ApbClkConfig::_1,
                    3 => ApbClkConfig::_3,
                    _ => ::core::panic!("Invalid APB_CLK divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    ApbClkConfig::_0 => 0,
                    ApbClkConfig::_1 => 1,
                    ApbClkConfig::_3 => 3,
                }
            }
        }
        /// The list of clock signals that the `LP_FAST_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LpFastClkConfig {
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `XTAL_D2_CLK`.
            XtalD2,
            /// Selects `XTAL_CLK`.
            Xtal,
        }
        /// The list of clock signals that the `LP_SLOW_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LpSlowClkConfig {
            /// Selects `RC_SLOW_CLK`.
            RcSlow,
            /// Selects `XTAL32K_CLK`.
            Xtal32k,
            /// Selects `OSC_SLOW_CLK`.
            OscSlow,
        }
        /// The list of clock signals that the `APBSARADC_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApbsaradcFunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `LEDC_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LedcFunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `MCPWM0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcpwm0FunctionClockConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            #[default]
            /// Selects `PLL_F160M`.
            PllF160m,
        }
        /// The list of clock signals that the `PARLIO_TX_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ParlioTxFunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F240M`.
            PllF240m,
        }
        /// The list of clock signals that the `RMT_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RmtFunctionClockConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            #[default]
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `SYSTIMER_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SystimerFunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
        }
        /// The list of clock signals that the `TIMG0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0FunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F48M`.
            PllF48m,
        }
        /// The list of clock signals that the `TIMG0_CALIBRATION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0CalibrationClockConfig {
            #[default]
            /// Selects `XTAL32K_CLK`.
            Xtal32k,
            /// Selects `OSC_SLOW_CLK`.
            OscSlow,
            /// Selects `RC_SLOW_CLK`.
            RcSlow,
            /// Selects `RC_FAST_CLK`.
            RcFast,
        }
        /// The list of clock signals that the `TIMG0_WDT_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0WdtClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `UART0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uart0FunctionClockConfig {
            /// Selects `PLL_F80M`.
            PllF80m,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
        }
        /// Represents the device's clock tree.
        pub struct ClockTree {
            xtal_clk: Option<XtalClkConfig>,
            soc_root_clk: Option<SocRootClkConfig>,
            cpu_clk: Option<CpuClkConfig>,
            ahb_clk: Option<AhbClkConfig>,
            apb_clk: Option<ApbClkConfig>,
            lp_fast_clk: Option<LpFastClkConfig>,
            lp_slow_clk: Option<LpSlowClkConfig>,
            apbsaradc_function_clock: Option<ApbsaradcFunctionClockConfig>,
            ledc_function_clock: Option<LedcFunctionClockConfig>,
            mcpwm0_function_clock: Option<Mcpwm0FunctionClockConfig>,
            parlio_tx_function_clock: Option<ParlioTxFunctionClockConfig>,
            rmt_function_clock: Option<RmtFunctionClockConfig>,
            systimer_function_clock: Option<SystimerFunctionClockConfig>,
            timg0_function_clock: Option<Timg0FunctionClockConfig>,
            timg0_calibration_clock: Option<Timg0CalibrationClockConfig>,
            timg0_wdt_clock: Option<Timg0WdtClockConfig>,
            timg1_function_clock: Option<Timg0FunctionClockConfig>,
            timg1_calibration_clock: Option<Timg0CalibrationClockConfig>,
            timg1_wdt_clock: Option<Timg0WdtClockConfig>,
            uart0_function_clock: Option<Uart0FunctionClockConfig>,
            uart1_function_clock: Option<Uart0FunctionClockConfig>,
            pll_clk_refcount: u32,
            rc_fast_clk_refcount: u32,
            xtal32k_clk_refcount: u32,
            osc_slow_clk_refcount: u32,
            rc_slow_clk_refcount: u32,
            pll_f22m_refcount: u32,
            pll_f40m_refcount: u32,
            pll_f44m_refcount: u32,
            pll_f48m_refcount: u32,
            pll_f80m_refcount: u32,
            pll_f120m_refcount: u32,
            pll_f160m_refcount: u32,
            pll_f240m_refcount: u32,
            soc_root_clk_refcount: u32,
            cpu_clk_refcount: u32,
            apb_clk_refcount: u32,
            lp_fast_clk_refcount: u32,
            lp_slow_clk_refcount: u32,
            apbsaradc_function_clock_refcount: u32,
            ledc_function_clock_refcount: u32,
            mcpwm0_function_clock_refcount: u32,
            parlio_tx_function_clock_refcount: u32,
            rmt_function_clock_refcount: u32,
            systimer_function_clock_refcount: u32,
            timg0_function_clock_refcount: u32,
            timg0_calibration_clock_refcount: u32,
            timg0_wdt_clock_refcount: u32,
            timg1_function_clock_refcount: u32,
            timg1_calibration_clock_refcount: u32,
            timg1_wdt_clock_refcount: u32,
            uart0_function_clock_refcount: u32,
            uart1_function_clock_refcount: u32,
        }
        impl ClockTree {
            /// Locks the clock tree for exclusive access.
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
            /// Returns the current configuration of the XTAL_CLK clock tree node
            pub fn xtal_clk(&self) -> Option<XtalClkConfig> {
                self.xtal_clk
            }
            /// Returns the current configuration of the SOC_ROOT_CLK clock tree node
            pub fn soc_root_clk(&self) -> Option<SocRootClkConfig> {
                self.soc_root_clk
            }
            /// Returns the current configuration of the CPU_CLK clock tree node
            pub fn cpu_clk(&self) -> Option<CpuClkConfig> {
                self.cpu_clk
            }
            /// Returns the current configuration of the AHB_CLK clock tree node
            pub fn ahb_clk(&self) -> Option<AhbClkConfig> {
                self.ahb_clk
            }
            /// Returns the current configuration of the APB_CLK clock tree node
            pub fn apb_clk(&self) -> Option<ApbClkConfig> {
                self.apb_clk
            }
            /// Returns the current configuration of the LP_FAST_CLK clock tree node
            pub fn lp_fast_clk(&self) -> Option<LpFastClkConfig> {
                self.lp_fast_clk
            }
            /// Returns the current configuration of the LP_SLOW_CLK clock tree node
            pub fn lp_slow_clk(&self) -> Option<LpSlowClkConfig> {
                self.lp_slow_clk
            }
            /// Returns the current configuration of the APBSARADC_FUNCTION_CLOCK clock tree node
            pub fn apbsaradc_function_clock(&self) -> Option<ApbsaradcFunctionClockConfig> {
                self.apbsaradc_function_clock
            }
            /// Returns the current configuration of the LEDC_FUNCTION_CLOCK clock tree node
            pub fn ledc_function_clock(&self) -> Option<LedcFunctionClockConfig> {
                self.ledc_function_clock
            }
            /// Returns the current configuration of the MCPWM0_FUNCTION_CLOCK clock tree node
            pub fn mcpwm0_function_clock(&self) -> Option<Mcpwm0FunctionClockConfig> {
                self.mcpwm0_function_clock
            }
            /// Returns the current configuration of the PARLIO_TX_FUNCTION_CLOCK clock tree node
            pub fn parlio_tx_function_clock(&self) -> Option<ParlioTxFunctionClockConfig> {
                self.parlio_tx_function_clock
            }
            /// Returns the current configuration of the RMT_FUNCTION_CLOCK clock tree node
            pub fn rmt_function_clock(&self) -> Option<RmtFunctionClockConfig> {
                self.rmt_function_clock
            }
            /// Returns the current configuration of the SYSTIMER_FUNCTION_CLOCK clock tree node
            pub fn systimer_function_clock(&self) -> Option<SystimerFunctionClockConfig> {
                self.systimer_function_clock
            }
            /// Returns the current configuration of the TIMG0_FUNCTION_CLOCK clock tree node
            pub fn timg0_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg0_function_clock
            }
            /// Returns the current configuration of the TIMG0_CALIBRATION_CLOCK clock tree node
            pub fn timg0_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg0_calibration_clock
            }
            /// Returns the current configuration of the TIMG0_WDT_CLOCK clock tree node
            pub fn timg0_wdt_clock(&self) -> Option<Timg0WdtClockConfig> {
                self.timg0_wdt_clock
            }
            /// Returns the current configuration of the TIMG1_FUNCTION_CLOCK clock tree node
            pub fn timg1_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg1_function_clock
            }
            /// Returns the current configuration of the TIMG1_CALIBRATION_CLOCK clock tree node
            pub fn timg1_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg1_calibration_clock
            }
            /// Returns the current configuration of the TIMG1_WDT_CLOCK clock tree node
            pub fn timg1_wdt_clock(&self) -> Option<Timg0WdtClockConfig> {
                self.timg1_wdt_clock
            }
            /// Returns the current configuration of the UART0_FUNCTION_CLOCK clock tree node
            pub fn uart0_function_clock(&self) -> Option<Uart0FunctionClockConfig> {
                self.uart0_function_clock
            }
            /// Returns the current configuration of the UART1_FUNCTION_CLOCK clock tree node
            pub fn uart1_function_clock(&self) -> Option<Uart0FunctionClockConfig> {
                self.uart1_function_clock
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {
                xtal_clk: None,
                soc_root_clk: None,
                cpu_clk: None,
                ahb_clk: None,
                apb_clk: None,
                lp_fast_clk: None,
                lp_slow_clk: None,
                apbsaradc_function_clock: None,
                ledc_function_clock: None,
                mcpwm0_function_clock: None,
                parlio_tx_function_clock: None,
                rmt_function_clock: None,
                systimer_function_clock: None,
                timg0_function_clock: None,
                timg0_calibration_clock: None,
                timg0_wdt_clock: None,
                timg1_function_clock: None,
                timg1_calibration_clock: None,
                timg1_wdt_clock: None,
                uart0_function_clock: None,
                uart1_function_clock: None,
                pll_clk_refcount: 0,
                rc_fast_clk_refcount: 0,
                xtal32k_clk_refcount: 0,
                osc_slow_clk_refcount: 0,
                rc_slow_clk_refcount: 0,
                pll_f22m_refcount: 0,
                pll_f40m_refcount: 0,
                pll_f44m_refcount: 0,
                pll_f48m_refcount: 0,
                pll_f80m_refcount: 0,
                pll_f120m_refcount: 0,
                pll_f160m_refcount: 0,
                pll_f240m_refcount: 0,
                soc_root_clk_refcount: 0,
                cpu_clk_refcount: 0,
                apb_clk_refcount: 0,
                lp_fast_clk_refcount: 0,
                lp_slow_clk_refcount: 0,
                apbsaradc_function_clock_refcount: 0,
                ledc_function_clock_refcount: 0,
                mcpwm0_function_clock_refcount: 0,
                parlio_tx_function_clock_refcount: 0,
                rmt_function_clock_refcount: 0,
                systimer_function_clock_refcount: 0,
                timg0_function_clock_refcount: 0,
                timg0_calibration_clock_refcount: 0,
                timg0_wdt_clock_refcount: 0,
                timg1_function_clock_refcount: 0,
                timg1_calibration_clock_refcount: 0,
                timg1_wdt_clock_refcount: 0,
                uart0_function_clock_refcount: 0,
                uart1_function_clock_refcount: 0,
            });
        pub fn configure_xtal_clk(clocks: &mut ClockTree, config: XtalClkConfig) {
            clocks.xtal_clk = Some(config);
            configure_xtal_clk_impl(clocks, config);
        }
        fn request_xtal_clk(_clocks: &mut ClockTree) {}
        fn release_xtal_clk(_clocks: &mut ClockTree) {}
        pub fn xtal_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.xtal_clk).value()
        }
        pub fn request_pll_clk(clocks: &mut ClockTree) {
            trace!("Requesting PLL_CLK");
            if increment_reference_count(&mut clocks.pll_clk_refcount) {
                trace!("Enabling PLL_CLK");
                request_xtal_clk(clocks);
                enable_pll_clk_impl(clocks, true);
            }
        }
        pub fn release_pll_clk(clocks: &mut ClockTree) {
            trace!("Releasing PLL_CLK");
            if decrement_reference_count(&mut clocks.pll_clk_refcount) {
                trace!("Disabling PLL_CLK");
                enable_pll_clk_impl(clocks, false);
                release_xtal_clk(clocks);
            }
        }
        pub fn pll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            480000000
        }
        pub fn request_rc_fast_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_FAST_CLK");
            if increment_reference_count(&mut clocks.rc_fast_clk_refcount) {
                trace!("Enabling RC_FAST_CLK");
                enable_rc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_FAST_CLK");
            if decrement_reference_count(&mut clocks.rc_fast_clk_refcount) {
                trace!("Disabling RC_FAST_CLK");
                enable_rc_fast_clk_impl(clocks, false);
            }
        }
        pub fn rc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            20000000
        }
        pub fn request_xtal32k_clk(clocks: &mut ClockTree) {
            trace!("Requesting XTAL32K_CLK");
            if increment_reference_count(&mut clocks.xtal32k_clk_refcount) {
                trace!("Enabling XTAL32K_CLK");
                enable_xtal32k_clk_impl(clocks, true);
            }
        }
        pub fn release_xtal32k_clk(clocks: &mut ClockTree) {
            trace!("Releasing XTAL32K_CLK");
            if decrement_reference_count(&mut clocks.xtal32k_clk_refcount) {
                trace!("Disabling XTAL32K_CLK");
                enable_xtal32k_clk_impl(clocks, false);
            }
        }
        pub fn xtal32k_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_osc_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting OSC_SLOW_CLK");
            if increment_reference_count(&mut clocks.osc_slow_clk_refcount) {
                trace!("Enabling OSC_SLOW_CLK");
                enable_osc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_osc_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing OSC_SLOW_CLK");
            if decrement_reference_count(&mut clocks.osc_slow_clk_refcount) {
                trace!("Disabling OSC_SLOW_CLK");
                enable_osc_slow_clk_impl(clocks, false);
            }
        }
        pub fn osc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_rc_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_SLOW_CLK");
            if increment_reference_count(&mut clocks.rc_slow_clk_refcount) {
                trace!("Enabling RC_SLOW_CLK");
                enable_rc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_SLOW_CLK");
            if decrement_reference_count(&mut clocks.rc_slow_clk_refcount) {
                trace!("Disabling RC_SLOW_CLK");
                enable_rc_slow_clk_impl(clocks, false);
            }
        }
        pub fn rc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            130000
        }
        pub fn request_pll_f22m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F22M");
            if increment_reference_count(&mut clocks.pll_f22m_refcount) {
                trace!("Enabling PLL_F22M");
                request_pll_clk(clocks);
                enable_pll_f22m_impl(clocks, true);
            }
        }
        pub fn release_pll_f22m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F22M");
            if decrement_reference_count(&mut clocks.pll_f22m_refcount) {
                trace!("Disabling PLL_F22M");
                enable_pll_f22m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f22m_frequency(clocks: &mut ClockTree) -> u32 {
            22000000
        }
        pub fn request_pll_f40m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F40M");
            if increment_reference_count(&mut clocks.pll_f40m_refcount) {
                trace!("Enabling PLL_F40M");
                request_pll_clk(clocks);
                enable_pll_f40m_impl(clocks, true);
            }
        }
        pub fn release_pll_f40m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F40M");
            if decrement_reference_count(&mut clocks.pll_f40m_refcount) {
                trace!("Disabling PLL_F40M");
                enable_pll_f40m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f40m_frequency(clocks: &mut ClockTree) -> u32 {
            40000000
        }
        pub fn request_pll_f44m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F44M");
            if increment_reference_count(&mut clocks.pll_f44m_refcount) {
                trace!("Enabling PLL_F44M");
                request_pll_clk(clocks);
                enable_pll_f44m_impl(clocks, true);
            }
        }
        pub fn release_pll_f44m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F44M");
            if decrement_reference_count(&mut clocks.pll_f44m_refcount) {
                trace!("Disabling PLL_F44M");
                enable_pll_f44m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f44m_frequency(clocks: &mut ClockTree) -> u32 {
            44000000
        }
        pub fn request_pll_f48m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F48M");
            if increment_reference_count(&mut clocks.pll_f48m_refcount) {
                trace!("Enabling PLL_F48M");
                request_pll_clk(clocks);
                enable_pll_f48m_impl(clocks, true);
            }
        }
        pub fn release_pll_f48m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F48M");
            if decrement_reference_count(&mut clocks.pll_f48m_refcount) {
                trace!("Disabling PLL_F48M");
                enable_pll_f48m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f48m_frequency(clocks: &mut ClockTree) -> u32 {
            48000000
        }
        pub fn request_pll_f80m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F80M");
            if increment_reference_count(&mut clocks.pll_f80m_refcount) {
                trace!("Enabling PLL_F80M");
                request_pll_clk(clocks);
                enable_pll_f80m_impl(clocks, true);
            }
        }
        pub fn release_pll_f80m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F80M");
            if decrement_reference_count(&mut clocks.pll_f80m_refcount) {
                trace!("Disabling PLL_F80M");
                enable_pll_f80m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f80m_frequency(clocks: &mut ClockTree) -> u32 {
            80000000
        }
        pub fn request_pll_f120m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F120M");
            if increment_reference_count(&mut clocks.pll_f120m_refcount) {
                trace!("Enabling PLL_F120M");
                request_pll_clk(clocks);
                enable_pll_f120m_impl(clocks, true);
            }
        }
        pub fn release_pll_f120m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F120M");
            if decrement_reference_count(&mut clocks.pll_f120m_refcount) {
                trace!("Disabling PLL_F120M");
                enable_pll_f120m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f120m_frequency(clocks: &mut ClockTree) -> u32 {
            120000000
        }
        pub fn request_pll_f160m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F160M");
            if increment_reference_count(&mut clocks.pll_f160m_refcount) {
                trace!("Enabling PLL_F160M");
                request_pll_clk(clocks);
                enable_pll_f160m_impl(clocks, true);
            }
        }
        pub fn release_pll_f160m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F160M");
            if decrement_reference_count(&mut clocks.pll_f160m_refcount) {
                trace!("Disabling PLL_F160M");
                enable_pll_f160m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f160m_frequency(clocks: &mut ClockTree) -> u32 {
            160000000
        }
        pub fn request_pll_f240m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F240M");
            if increment_reference_count(&mut clocks.pll_f240m_refcount) {
                trace!("Enabling PLL_F240M");
                request_pll_clk(clocks);
                enable_pll_f240m_impl(clocks, true);
            }
        }
        pub fn release_pll_f240m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F240M");
            if decrement_reference_count(&mut clocks.pll_f240m_refcount) {
                trace!("Disabling PLL_F240M");
                enable_pll_f240m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f240m_frequency(clocks: &mut ClockTree) -> u32 {
            240000000
        }
        pub fn configure_soc_root_clk(clocks: &mut ClockTree, new_selector: SocRootClkConfig) {
            let old_selector = clocks.soc_root_clk.replace(new_selector);
            if clocks.soc_root_clk_refcount > 0 {
                match new_selector {
                    SocRootClkConfig::Xtal => request_xtal_clk(clocks),
                    SocRootClkConfig::RcFast => request_rc_fast_clk(clocks),
                    SocRootClkConfig::PllF160m => request_pll_f160m(clocks),
                    SocRootClkConfig::PllF240m => request_pll_f240m(clocks),
                }
                configure_soc_root_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        SocRootClkConfig::Xtal => release_xtal_clk(clocks),
                        SocRootClkConfig::RcFast => release_rc_fast_clk(clocks),
                        SocRootClkConfig::PllF160m => release_pll_f160m(clocks),
                        SocRootClkConfig::PllF240m => release_pll_f240m(clocks),
                    }
                }
            } else {
                configure_soc_root_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_soc_root_clk(clocks: &mut ClockTree) {
            trace!("Requesting SOC_ROOT_CLK");
            if increment_reference_count(&mut clocks.soc_root_clk_refcount) {
                trace!("Enabling SOC_ROOT_CLK");
                match unwrap!(clocks.soc_root_clk) {
                    SocRootClkConfig::Xtal => request_xtal_clk(clocks),
                    SocRootClkConfig::RcFast => request_rc_fast_clk(clocks),
                    SocRootClkConfig::PllF160m => request_pll_f160m(clocks),
                    SocRootClkConfig::PllF240m => request_pll_f240m(clocks),
                }
                enable_soc_root_clk_impl(clocks, true);
            }
        }
        pub fn release_soc_root_clk(clocks: &mut ClockTree) {
            trace!("Releasing SOC_ROOT_CLK");
            if decrement_reference_count(&mut clocks.soc_root_clk_refcount) {
                trace!("Disabling SOC_ROOT_CLK");
                enable_soc_root_clk_impl(clocks, false);
                match unwrap!(clocks.soc_root_clk) {
                    SocRootClkConfig::Xtal => release_xtal_clk(clocks),
                    SocRootClkConfig::RcFast => release_rc_fast_clk(clocks),
                    SocRootClkConfig::PllF160m => release_pll_f160m(clocks),
                    SocRootClkConfig::PllF240m => release_pll_f240m(clocks),
                }
            }
        }
        pub fn soc_root_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.soc_root_clk) {
                SocRootClkConfig::Xtal => xtal_clk_frequency(clocks),
                SocRootClkConfig::RcFast => rc_fast_clk_frequency(clocks),
                SocRootClkConfig::PllF160m => pll_f160m_frequency(clocks),
                SocRootClkConfig::PllF240m => pll_f240m_frequency(clocks),
            }
        }
        pub fn configure_cpu_clk(clocks: &mut ClockTree, config: CpuClkConfig) {
            clocks.cpu_clk = Some(config);
            configure_cpu_clk_impl(clocks, config);
        }
        pub fn request_cpu_clk(clocks: &mut ClockTree) {
            trace!("Requesting CPU_CLK");
            if increment_reference_count(&mut clocks.cpu_clk_refcount) {
                trace!("Enabling CPU_CLK");
                request_soc_root_clk(clocks);
                enable_cpu_clk_impl(clocks, true);
            }
        }
        pub fn release_cpu_clk(clocks: &mut ClockTree) {
            trace!("Releasing CPU_CLK");
            if decrement_reference_count(&mut clocks.cpu_clk_refcount) {
                trace!("Disabling CPU_CLK");
                enable_cpu_clk_impl(clocks, false);
                release_soc_root_clk(clocks);
            }
        }
        pub fn cpu_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (soc_root_clk_frequency(clocks) / (unwrap!(clocks.cpu_clk).value() + 1))
        }
        pub fn configure_ahb_clk(clocks: &mut ClockTree, config: AhbClkConfig) {
            clocks.ahb_clk = Some(config);
            configure_ahb_clk_impl(clocks, config);
        }
        pub fn request_ahb_clk(clocks: &mut ClockTree) {
            trace!("Requesting AHB_CLK");
            trace!("Enabling AHB_CLK");
            request_soc_root_clk(clocks);
            enable_ahb_clk_impl(clocks, true);
        }
        pub fn release_ahb_clk(clocks: &mut ClockTree) {
            trace!("Releasing AHB_CLK");
            trace!("Disabling AHB_CLK");
            enable_ahb_clk_impl(clocks, false);
            release_soc_root_clk(clocks);
        }
        pub fn ahb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (soc_root_clk_frequency(clocks) / (unwrap!(clocks.ahb_clk).value() + 1))
        }
        pub fn configure_apb_clk(clocks: &mut ClockTree, config: ApbClkConfig) {
            clocks.apb_clk = Some(config);
            configure_apb_clk_impl(clocks, config);
        }
        pub fn request_apb_clk(clocks: &mut ClockTree) {
            trace!("Requesting APB_CLK");
            if increment_reference_count(&mut clocks.apb_clk_refcount) {
                trace!("Enabling APB_CLK");
                request_ahb_clk(clocks);
                enable_apb_clk_impl(clocks, true);
            }
        }
        pub fn release_apb_clk(clocks: &mut ClockTree) {
            trace!("Releasing APB_CLK");
            if decrement_reference_count(&mut clocks.apb_clk_refcount) {
                trace!("Disabling APB_CLK");
                enable_apb_clk_impl(clocks, false);
                release_ahb_clk(clocks);
            }
        }
        pub fn apb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (ahb_clk_frequency(clocks) / (unwrap!(clocks.apb_clk).value() + 1))
        }
        pub fn request_xtal_d2_clk(clocks: &mut ClockTree) {
            trace!("Requesting XTAL_D2_CLK");
            trace!("Enabling XTAL_D2_CLK");
            request_xtal_clk(clocks);
            enable_xtal_d2_clk_impl(clocks, true);
        }
        pub fn release_xtal_d2_clk(clocks: &mut ClockTree) {
            trace!("Releasing XTAL_D2_CLK");
            trace!("Disabling XTAL_D2_CLK");
            enable_xtal_d2_clk_impl(clocks, false);
            release_xtal_clk(clocks);
        }
        pub fn xtal_d2_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (xtal_clk_frequency(clocks) / 2)
        }
        pub fn configure_lp_fast_clk(clocks: &mut ClockTree, new_selector: LpFastClkConfig) {
            let old_selector = clocks.lp_fast_clk.replace(new_selector);
            if clocks.lp_fast_clk_refcount > 0 {
                match new_selector {
                    LpFastClkConfig::RcFast => request_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2 => request_xtal_d2_clk(clocks),
                    LpFastClkConfig::Xtal => request_xtal_clk(clocks),
                }
                configure_lp_fast_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LpFastClkConfig::RcFast => release_rc_fast_clk(clocks),
                        LpFastClkConfig::XtalD2 => release_xtal_d2_clk(clocks),
                        LpFastClkConfig::Xtal => release_xtal_clk(clocks),
                    }
                }
            } else {
                configure_lp_fast_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_lp_fast_clk(clocks: &mut ClockTree) {
            trace!("Requesting LP_FAST_CLK");
            if increment_reference_count(&mut clocks.lp_fast_clk_refcount) {
                trace!("Enabling LP_FAST_CLK");
                match unwrap!(clocks.lp_fast_clk) {
                    LpFastClkConfig::RcFast => request_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2 => request_xtal_d2_clk(clocks),
                    LpFastClkConfig::Xtal => request_xtal_clk(clocks),
                }
                enable_lp_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_lp_fast_clk(clocks: &mut ClockTree) {
            trace!("Releasing LP_FAST_CLK");
            if decrement_reference_count(&mut clocks.lp_fast_clk_refcount) {
                trace!("Disabling LP_FAST_CLK");
                enable_lp_fast_clk_impl(clocks, false);
                match unwrap!(clocks.lp_fast_clk) {
                    LpFastClkConfig::RcFast => release_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2 => release_xtal_d2_clk(clocks),
                    LpFastClkConfig::Xtal => release_xtal_clk(clocks),
                }
            }
        }
        pub fn lp_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.lp_fast_clk) {
                LpFastClkConfig::RcFast => rc_fast_clk_frequency(clocks),
                LpFastClkConfig::XtalD2 => xtal_d2_clk_frequency(clocks),
                LpFastClkConfig::Xtal => xtal_clk_frequency(clocks),
            }
        }
        pub fn configure_lp_slow_clk(clocks: &mut ClockTree, new_selector: LpSlowClkConfig) {
            let old_selector = clocks.lp_slow_clk.replace(new_selector);
            if clocks.lp_slow_clk_refcount > 0 {
                match new_selector {
                    LpSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    LpSlowClkConfig::Xtal32k => request_xtal32k_clk(clocks),
                    LpSlowClkConfig::OscSlow => request_osc_slow_clk(clocks),
                }
                configure_lp_slow_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LpSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                        LpSlowClkConfig::Xtal32k => release_xtal32k_clk(clocks),
                        LpSlowClkConfig::OscSlow => release_osc_slow_clk(clocks),
                    }
                }
            } else {
                configure_lp_slow_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_lp_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting LP_SLOW_CLK");
            if increment_reference_count(&mut clocks.lp_slow_clk_refcount) {
                trace!("Enabling LP_SLOW_CLK");
                match unwrap!(clocks.lp_slow_clk) {
                    LpSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    LpSlowClkConfig::Xtal32k => request_xtal32k_clk(clocks),
                    LpSlowClkConfig::OscSlow => request_osc_slow_clk(clocks),
                }
                enable_lp_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_lp_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing LP_SLOW_CLK");
            if decrement_reference_count(&mut clocks.lp_slow_clk_refcount) {
                trace!("Disabling LP_SLOW_CLK");
                enable_lp_slow_clk_impl(clocks, false);
                match unwrap!(clocks.lp_slow_clk) {
                    LpSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                    LpSlowClkConfig::Xtal32k => release_xtal32k_clk(clocks),
                    LpSlowClkConfig::OscSlow => release_osc_slow_clk(clocks),
                }
            }
        }
        pub fn lp_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.lp_slow_clk) {
                LpSlowClkConfig::RcSlow => rc_slow_clk_frequency(clocks),
                LpSlowClkConfig::Xtal32k => xtal32k_clk_frequency(clocks),
                LpSlowClkConfig::OscSlow => osc_slow_clk_frequency(clocks),
            }
        }
        pub fn configure_apbsaradc_function_clock(
            clocks: &mut ClockTree,
            new_selector: ApbsaradcFunctionClockConfig,
        ) {
            let old_selector = clocks.apbsaradc_function_clock.replace(new_selector);
            if clocks.apbsaradc_function_clock_refcount > 0 {
                match new_selector {
                    ApbsaradcFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    ApbsaradcFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    ApbsaradcFunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_apbsaradc_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        ApbsaradcFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        ApbsaradcFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        ApbsaradcFunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_apbsaradc_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_apbsaradc_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting APBSARADC_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.apbsaradc_function_clock_refcount) {
                trace!("Enabling APBSARADC_FUNCTION_CLOCK");
                match unwrap!(clocks.apbsaradc_function_clock) {
                    ApbsaradcFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    ApbsaradcFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    ApbsaradcFunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_apbsaradc_function_clock_impl(clocks, true);
            }
        }
        pub fn release_apbsaradc_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing APBSARADC_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.apbsaradc_function_clock_refcount) {
                trace!("Disabling APBSARADC_FUNCTION_CLOCK");
                enable_apbsaradc_function_clock_impl(clocks, false);
                match unwrap!(clocks.apbsaradc_function_clock) {
                    ApbsaradcFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    ApbsaradcFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    ApbsaradcFunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn apbsaradc_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.apbsaradc_function_clock) {
                ApbsaradcFunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                ApbsaradcFunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                ApbsaradcFunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_ledc_function_clock(
            clocks: &mut ClockTree,
            new_selector: LedcFunctionClockConfig,
        ) {
            let old_selector = clocks.ledc_function_clock.replace(new_selector);
            if clocks.ledc_function_clock_refcount > 0 {
                match new_selector {
                    LedcFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    LedcFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    LedcFunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_ledc_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LedcFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        LedcFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        LedcFunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_ledc_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_ledc_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting LEDC_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.ledc_function_clock_refcount) {
                trace!("Enabling LEDC_FUNCTION_CLOCK");
                match unwrap!(clocks.ledc_function_clock) {
                    LedcFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    LedcFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    LedcFunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_ledc_function_clock_impl(clocks, true);
            }
        }
        pub fn release_ledc_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing LEDC_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.ledc_function_clock_refcount) {
                trace!("Disabling LEDC_FUNCTION_CLOCK");
                enable_ledc_function_clock_impl(clocks, false);
                match unwrap!(clocks.ledc_function_clock) {
                    LedcFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    LedcFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    LedcFunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn ledc_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.ledc_function_clock) {
                LedcFunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                LedcFunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                LedcFunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_mcpwm0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Mcpwm0FunctionClockConfig,
        ) {
            let old_selector = clocks.mcpwm0_function_clock.replace(new_selector);
            if clocks.mcpwm0_function_clock_refcount > 0 {
                match new_selector {
                    Mcpwm0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Mcpwm0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Mcpwm0FunctionClockConfig::PllF160m => request_pll_f160m(clocks),
                }
                configure_mcpwm0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Mcpwm0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        Mcpwm0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Mcpwm0FunctionClockConfig::PllF160m => release_pll_f160m(clocks),
                    }
                }
            } else {
                configure_mcpwm0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_mcpwm0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting MCPWM0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.mcpwm0_function_clock_refcount) {
                trace!("Enabling MCPWM0_FUNCTION_CLOCK");
                match unwrap!(clocks.mcpwm0_function_clock) {
                    Mcpwm0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Mcpwm0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Mcpwm0FunctionClockConfig::PllF160m => request_pll_f160m(clocks),
                }
                enable_mcpwm0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_mcpwm0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing MCPWM0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.mcpwm0_function_clock_refcount) {
                trace!("Disabling MCPWM0_FUNCTION_CLOCK");
                enable_mcpwm0_function_clock_impl(clocks, false);
                match unwrap!(clocks.mcpwm0_function_clock) {
                    Mcpwm0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    Mcpwm0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Mcpwm0FunctionClockConfig::PllF160m => release_pll_f160m(clocks),
                }
            }
        }
        pub fn mcpwm0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.mcpwm0_function_clock) {
                Mcpwm0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                Mcpwm0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Mcpwm0FunctionClockConfig::PllF160m => pll_f160m_frequency(clocks),
            }
        }
        pub fn configure_parlio_tx_function_clock(
            clocks: &mut ClockTree,
            new_selector: ParlioTxFunctionClockConfig,
        ) {
            let old_selector = clocks.parlio_tx_function_clock.replace(new_selector);
            if clocks.parlio_tx_function_clock_refcount > 0 {
                match new_selector {
                    ParlioTxFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    ParlioTxFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    ParlioTxFunctionClockConfig::PllF240m => request_pll_f240m(clocks),
                }
                configure_parlio_tx_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        ParlioTxFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        ParlioTxFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        ParlioTxFunctionClockConfig::PllF240m => release_pll_f240m(clocks),
                    }
                }
            } else {
                configure_parlio_tx_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_parlio_tx_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting PARLIO_TX_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.parlio_tx_function_clock_refcount) {
                trace!("Enabling PARLIO_TX_FUNCTION_CLOCK");
                match unwrap!(clocks.parlio_tx_function_clock) {
                    ParlioTxFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    ParlioTxFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    ParlioTxFunctionClockConfig::PllF240m => request_pll_f240m(clocks),
                }
                enable_parlio_tx_function_clock_impl(clocks, true);
            }
        }
        pub fn release_parlio_tx_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing PARLIO_TX_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.parlio_tx_function_clock_refcount) {
                trace!("Disabling PARLIO_TX_FUNCTION_CLOCK");
                enable_parlio_tx_function_clock_impl(clocks, false);
                match unwrap!(clocks.parlio_tx_function_clock) {
                    ParlioTxFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    ParlioTxFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    ParlioTxFunctionClockConfig::PllF240m => release_pll_f240m(clocks),
                }
            }
        }
        pub fn parlio_tx_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.parlio_tx_function_clock) {
                ParlioTxFunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                ParlioTxFunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                ParlioTxFunctionClockConfig::PllF240m => pll_f240m_frequency(clocks),
            }
        }
        pub fn configure_rmt_function_clock(
            clocks: &mut ClockTree,
            new_selector: RmtFunctionClockConfig,
        ) {
            let old_selector = clocks.rmt_function_clock.replace(new_selector);
            if clocks.rmt_function_clock_refcount > 0 {
                match new_selector {
                    RmtFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    RmtFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    RmtFunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_rmt_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RmtFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        RmtFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        RmtFunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_rmt_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_rmt_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting RMT_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.rmt_function_clock_refcount) {
                trace!("Enabling RMT_FUNCTION_CLOCK");
                match unwrap!(clocks.rmt_function_clock) {
                    RmtFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    RmtFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    RmtFunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_rmt_function_clock_impl(clocks, true);
            }
        }
        pub fn release_rmt_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing RMT_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.rmt_function_clock_refcount) {
                trace!("Disabling RMT_FUNCTION_CLOCK");
                enable_rmt_function_clock_impl(clocks, false);
                match unwrap!(clocks.rmt_function_clock) {
                    RmtFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    RmtFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    RmtFunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn rmt_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.rmt_function_clock) {
                RmtFunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                RmtFunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                RmtFunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_systimer_function_clock(
            clocks: &mut ClockTree,
            new_selector: SystimerFunctionClockConfig,
        ) {
            let old_selector = clocks.systimer_function_clock.replace(new_selector);
            if clocks.systimer_function_clock_refcount > 0 {
                match new_selector {
                    SystimerFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    SystimerFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                configure_systimer_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        SystimerFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        SystimerFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_systimer_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_systimer_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting SYSTIMER_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.systimer_function_clock_refcount) {
                trace!("Enabling SYSTIMER_FUNCTION_CLOCK");
                match unwrap!(clocks.systimer_function_clock) {
                    SystimerFunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    SystimerFunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                enable_systimer_function_clock_impl(clocks, true);
            }
        }
        pub fn release_systimer_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing SYSTIMER_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.systimer_function_clock_refcount) {
                trace!("Disabling SYSTIMER_FUNCTION_CLOCK");
                enable_systimer_function_clock_impl(clocks, false);
                match unwrap!(clocks.systimer_function_clock) {
                    SystimerFunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    SystimerFunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn systimer_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.systimer_function_clock) {
                SystimerFunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                SystimerFunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_timg0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg0_function_clock.replace(new_selector);
            if clocks.timg0_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF48m => request_pll_f48m(clocks),
                }
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Timg0FunctionClockConfig::PllF48m => release_pll_f48m(clocks),
                    }
                }
            } else {
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.timg0_function_clock_refcount) {
                trace!("Enabling TIMG0_FUNCTION_CLOCK");
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF48m => request_pll_f48m(clocks),
                }
                enable_timg0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_function_clock_refcount) {
                trace!("Disabling TIMG0_FUNCTION_CLOCK");
                enable_timg0_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF48m => release_pll_f48m(clocks),
                }
            }
        }
        pub fn timg0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_function_clock) {
                Timg0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Timg0FunctionClockConfig::PllF48m => pll_f48m_frequency(clocks),
            }
        }
        pub fn configure_timg0_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg0_calibration_clock.replace(new_selector);
            if clocks.timg0_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::Xtal32k => request_xtal32k_clk(clocks),
                    Timg0CalibrationClockConfig::OscSlow => request_osc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcSlow => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::Xtal32k => release_xtal32k_clk(clocks),
                        Timg0CalibrationClockConfig::OscSlow => release_osc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcSlow => release_rc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFast => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_calibration_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_CALIBRATION_CLOCK");
            if increment_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                trace!("Enabling TIMG0_CALIBRATION_CLOCK");
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::Xtal32k => request_xtal32k_clk(clocks),
                    Timg0CalibrationClockConfig::OscSlow => request_osc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcSlow => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                enable_timg0_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_calibration_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_CALIBRATION_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                trace!("Disabling TIMG0_CALIBRATION_CLOCK");
                enable_timg0_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::Xtal32k => release_xtal32k_clk(clocks),
                    Timg0CalibrationClockConfig::OscSlow => release_osc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcSlow => release_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn timg0_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_calibration_clock) {
                Timg0CalibrationClockConfig::Xtal32k => xtal32k_clk_frequency(clocks),
                Timg0CalibrationClockConfig::OscSlow => osc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcSlow => rc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_timg0_wdt_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0WdtClockConfig,
        ) {
            let old_selector = clocks.timg0_wdt_clock.replace(new_selector);
            if clocks.timg0_wdt_clock_refcount > 0 {
                match new_selector {
                    Timg0WdtClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_timg0_wdt_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0WdtClockConfig::Xtal => release_xtal_clk(clocks),
                        Timg0WdtClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_timg0_wdt_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_wdt_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_WDT_CLOCK");
            if increment_reference_count(&mut clocks.timg0_wdt_clock_refcount) {
                trace!("Enabling TIMG0_WDT_CLOCK");
                match unwrap!(clocks.timg0_wdt_clock) {
                    Timg0WdtClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_timg0_wdt_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_wdt_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_WDT_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_wdt_clock_refcount) {
                trace!("Disabling TIMG0_WDT_CLOCK");
                enable_timg0_wdt_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_wdt_clock) {
                    Timg0WdtClockConfig::Xtal => release_xtal_clk(clocks),
                    Timg0WdtClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn timg0_wdt_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_wdt_clock) {
                Timg0WdtClockConfig::Xtal => xtal_clk_frequency(clocks),
                Timg0WdtClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Timg0WdtClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_timg1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg1_function_clock.replace(new_selector);
            if clocks.timg1_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF48m => request_pll_f48m(clocks),
                }
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Timg0FunctionClockConfig::PllF48m => release_pll_f48m(clocks),
                    }
                }
            } else {
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.timg1_function_clock_refcount) {
                trace!("Enabling TIMG1_FUNCTION_CLOCK");
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF48m => request_pll_f48m(clocks),
                }
                enable_timg1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_function_clock_refcount) {
                trace!("Disabling TIMG1_FUNCTION_CLOCK");
                enable_timg1_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF48m => release_pll_f48m(clocks),
                }
            }
        }
        pub fn timg1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_function_clock) {
                Timg0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Timg0FunctionClockConfig::PllF48m => pll_f48m_frequency(clocks),
            }
        }
        pub fn configure_timg1_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg1_calibration_clock.replace(new_selector);
            if clocks.timg1_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::Xtal32k => request_xtal32k_clk(clocks),
                    Timg0CalibrationClockConfig::OscSlow => request_osc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcSlow => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::Xtal32k => release_xtal32k_clk(clocks),
                        Timg0CalibrationClockConfig::OscSlow => release_osc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcSlow => release_rc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFast => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_calibration_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_CALIBRATION_CLOCK");
            if increment_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                trace!("Enabling TIMG1_CALIBRATION_CLOCK");
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::Xtal32k => request_xtal32k_clk(clocks),
                    Timg0CalibrationClockConfig::OscSlow => request_osc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcSlow => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                enable_timg1_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_calibration_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_CALIBRATION_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                trace!("Disabling TIMG1_CALIBRATION_CLOCK");
                enable_timg1_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::Xtal32k => release_xtal32k_clk(clocks),
                    Timg0CalibrationClockConfig::OscSlow => release_osc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcSlow => release_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn timg1_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_calibration_clock) {
                Timg0CalibrationClockConfig::Xtal32k => xtal32k_clk_frequency(clocks),
                Timg0CalibrationClockConfig::OscSlow => osc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcSlow => rc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_wdt_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0WdtClockConfig,
        ) {
            let old_selector = clocks.timg1_wdt_clock.replace(new_selector);
            if clocks.timg1_wdt_clock_refcount > 0 {
                match new_selector {
                    Timg0WdtClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_timg1_wdt_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0WdtClockConfig::Xtal => release_xtal_clk(clocks),
                        Timg0WdtClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_timg1_wdt_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_wdt_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_WDT_CLOCK");
            if increment_reference_count(&mut clocks.timg1_wdt_clock_refcount) {
                trace!("Enabling TIMG1_WDT_CLOCK");
                match unwrap!(clocks.timg1_wdt_clock) {
                    Timg0WdtClockConfig::Xtal => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_timg1_wdt_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_wdt_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_WDT_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_wdt_clock_refcount) {
                trace!("Disabling TIMG1_WDT_CLOCK");
                enable_timg1_wdt_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_wdt_clock) {
                    Timg0WdtClockConfig::Xtal => release_xtal_clk(clocks),
                    Timg0WdtClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn timg1_wdt_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_wdt_clock) {
                Timg0WdtClockConfig::Xtal => xtal_clk_frequency(clocks),
                Timg0WdtClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Timg0WdtClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_uart0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0FunctionClockConfig,
        ) {
            let old_selector = clocks.uart0_function_clock.replace(new_selector);
            if clocks.uart0_function_clock_refcount > 0 {
                match new_selector {
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                }
                configure_uart0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                        Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    }
                }
            } else {
                configure_uart0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_uart0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.uart0_function_clock_refcount) {
                trace!("Enabling UART0_FUNCTION_CLOCK");
                match unwrap!(clocks.uart0_function_clock) {
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                }
                enable_uart0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_uart0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.uart0_function_clock_refcount) {
                trace!("Disabling UART0_FUNCTION_CLOCK");
                enable_uart0_function_clock_impl(clocks, false);
                match unwrap!(clocks.uart0_function_clock) {
                    Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                }
            }
        }
        pub fn uart0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.uart0_function_clock) {
                Uart0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Uart0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Uart0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
            }
        }
        pub fn configure_uart1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0FunctionClockConfig,
        ) {
            let old_selector = clocks.uart1_function_clock.replace(new_selector);
            if clocks.uart1_function_clock_refcount > 0 {
                match new_selector {
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                }
                configure_uart1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                        Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                        Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    }
                }
            } else {
                configure_uart1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_uart1_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART1_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.uart1_function_clock_refcount) {
                trace!("Enabling UART1_FUNCTION_CLOCK");
                match unwrap!(clocks.uart1_function_clock) {
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                }
                enable_uart1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_uart1_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART1_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.uart1_function_clock_refcount) {
                trace!("Disabling UART1_FUNCTION_CLOCK");
                enable_uart1_function_clock_impl(clocks, false);
                match unwrap!(clocks.uart1_function_clock) {
                    Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                }
            }
        }
        pub fn uart1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.uart1_function_clock) {
                Uart0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Uart0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
                Uart0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
            }
        }
        /// Clock tree configuration.
        ///
        /// The fields of this struct are optional, with the following caveats:
        /// - If `XTAL_CLK` is not specified, the crystal frequency will be automatically detected
        ///   if possible.
        /// - The CPU and its upstream clock nodes will be set to a default configuration.
        /// - Other unspecified clock sources will not be useable by peripherals.
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[instability::unstable]
        pub struct ClockConfig {
            /// `XTAL_CLK` configuration.
            pub xtal_clk: Option<XtalClkConfig>,
            /// `SOC_ROOT_CLK` configuration.
            pub soc_root_clk: Option<SocRootClkConfig>,
            /// `CPU_CLK` configuration.
            pub cpu_clk: Option<CpuClkConfig>,
            /// `AHB_CLK` configuration.
            pub ahb_clk: Option<AhbClkConfig>,
            /// `APB_CLK` configuration.
            pub apb_clk: Option<ApbClkConfig>,
            /// `LP_FAST_CLK` configuration.
            pub lp_fast_clk: Option<LpFastClkConfig>,
            /// `LP_SLOW_CLK` configuration.
            pub lp_slow_clk: Option<LpSlowClkConfig>,
        }
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {
                    if let Some(config) = self.xtal_clk {
                        configure_xtal_clk(clocks, config);
                    }
                    if let Some(config) = self.soc_root_clk {
                        configure_soc_root_clk(clocks, config);
                    }
                    if let Some(config) = self.cpu_clk {
                        configure_cpu_clk(clocks, config);
                    }
                    if let Some(config) = self.ahb_clk {
                        configure_ahb_clk(clocks, config);
                    }
                    if let Some(config) = self.apb_clk {
                        configure_apb_clk(clocks, config);
                    }
                    if let Some(config) = self.lp_fast_clk {
                        configure_lp_fast_clk(clocks, config);
                    }
                    if let Some(config) = self.lp_slow_clk {
                        configure_lp_slow_clk(clocks, config);
                    }
                });
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount = unwrap!(refcount.checked_add(1), "Reference count overflow");
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount = refcount.saturating_sub(1);
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            /// AES peripheral clock signal
            Aes,
            /// APB_SAR_ADC peripheral clock signal
            ApbSarAdc,
            /// DMA peripheral clock signal
            Dma,
            /// DS peripheral clock signal
            Ds,
            /// ECC peripheral clock signal
            Ecc,
            /// ETM peripheral clock signal
            Etm,
            /// HMAC peripheral clock signal
            Hmac,
            /// I2C_EXT0 peripheral clock signal
            I2cExt0,
            /// I2S0 peripheral clock signal
            I2s0,
            /// LEDC peripheral clock signal
            Ledc,
            /// MCPWM0 peripheral clock signal
            Mcpwm0,
            /// PARL_IO peripheral clock signal
            ParlIo,
            /// PCNT peripheral clock signal
            Pcnt,
            /// RMT peripheral clock signal
            Rmt,
            /// RSA peripheral clock signal
            Rsa,
            /// SHA peripheral clock signal
            Sha,
            /// SYSTIMER peripheral clock signal
            Systimer,
            /// TIMG0 peripheral clock signal
            Timg0,
            /// TIMG1 peripheral clock signal
            Timg1,
            /// TRACE0 peripheral clock signal
            Trace0,
            /// TWAI0 peripheral clock signal
            Twai0,
            /// TWAI1 peripheral clock signal
            Twai1,
            /// UART0 peripheral clock signal
            Uart0,
            /// UART1 peripheral clock signal
            Uart1,
            /// UHCI0 peripheral clock signal
            Uhci0,
            /// USB_DEVICE peripheral clock signal
            UsbDevice,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] = &[
                Self::ApbSarAdc,
                Self::Systimer,
                Self::Timg0,
                Self::Uart0,
                Self::UsbDevice,
            ];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::ApbSarAdc,
                Self::Dma,
                Self::Ds,
                Self::Ecc,
                Self::Etm,
                Self::Hmac,
                Self::I2cExt0,
                Self::I2s0,
                Self::Ledc,
                Self::Mcpwm0,
                Self::ParlIo,
                Self::Pcnt,
                Self::Rmt,
                Self::Rsa,
                Self::Sha,
                Self::Systimer,
                Self::Timg0,
                Self::Timg1,
                Self::Trace0,
                Self::Twai0,
                Self::Twai1,
                Self::Uart0,
                Self::Uart1,
                Self::Uhci0,
                Self::UsbDevice,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .aes_conf()
                        .modify(|_, w| w.aes_clk_en().bit(enable));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .saradc_conf()
                        .modify(|_, w| w.saradc_reg_clk_en().bit(enable));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .gdma_conf()
                        .modify(|_, w| w.gdma_clk_en().bit(enable));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .ds_conf()
                        .modify(|_, w| w.ds_clk_en().bit(enable));
                }
                Peripheral::Ecc => {
                    crate::peripherals::SYSTEM::regs()
                        .ecc_conf()
                        .modify(|_, w| w.ecc_clk_en().bit(enable));
                }
                Peripheral::Etm => {
                    crate::peripherals::SYSTEM::regs()
                        .etm_conf()
                        .modify(|_, w| w.etm_clk_en().bit(enable));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .hmac_conf()
                        .modify(|_, w| w.hmac_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2c0_conf()
                        .modify(|_, w| w.i2c0_clk_en().bit(enable));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2s_conf()
                        .modify(|_, w| w.i2s_clk_en().bit(enable));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .ledc_conf()
                        .modify(|_, w| w.ledc_clk_en().bit(enable));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .pwm_conf()
                        .modify(|_, w| w.pwm_clk_en().bit(enable));
                }
                Peripheral::ParlIo => {
                    crate::peripherals::SYSTEM::regs()
                        .parl_io_conf()
                        .modify(|_, w| w.parl_clk_en().bit(enable));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .pcnt_conf()
                        .modify(|_, w| w.pcnt_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .rmt_conf()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .rsa_conf()
                        .modify(|_, w| w.rsa_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .sha_conf()
                        .modify(|_, w| w.sha_clk_en().bit(enable));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .systimer_conf()
                        .modify(|_, w| w.systimer_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_conf()
                        .modify(|_, w| w.tg0_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_timer_clk_conf()
                        .modify(|_, w| w.tg0_timer_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_conf()
                        .modify(|_, w| w.tg1_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_timer_clk_conf()
                        .modify(|_, w| w.tg1_timer_clk_en().bit(enable));
                }
                Peripheral::Trace0 => {
                    crate::peripherals::SYSTEM::regs()
                        .trace_conf()
                        .modify(|_, w| w.trace_clk_en().bit(enable));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai0_conf()
                        .modify(|_, w| w.twai0_clk_en().bit(enable));
                }
                Peripheral::Twai1 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai1_conf()
                        .modify(|_, w| w.twai1_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(0)
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(1)
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uhci_conf()
                        .modify(|_, w| w.uhci_clk_en().bit(enable));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .usb_device_conf()
                        .modify(|_, w| w.usb_device_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .aes_conf()
                        .modify(|_, w| w.aes_rst_en().bit(reset));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .saradc_conf()
                        .modify(|_, w| w.saradc_reg_rst_en().bit(reset));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .gdma_conf()
                        .modify(|_, w| w.gdma_rst_en().bit(reset));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .ds_conf()
                        .modify(|_, w| w.ds_rst_en().bit(reset));
                }
                Peripheral::Ecc => {
                    crate::peripherals::SYSTEM::regs()
                        .ecc_conf()
                        .modify(|_, w| w.ecc_rst_en().bit(reset));
                }
                Peripheral::Etm => {
                    crate::peripherals::SYSTEM::regs()
                        .etm_conf()
                        .modify(|_, w| w.etm_rst_en().bit(reset));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .hmac_conf()
                        .modify(|_, w| w.hmac_rst_en().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2c0_conf()
                        .modify(|_, w| w.i2c0_rst_en().bit(reset));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2s_conf()
                        .modify(|_, w| w.i2s_rst_en().bit(reset));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .ledc_conf()
                        .modify(|_, w| w.ledc_rst_en().bit(reset));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .pwm_conf()
                        .modify(|_, w| w.pwm_rst_en().bit(reset));
                }
                Peripheral::ParlIo => {
                    crate::peripherals::SYSTEM::regs()
                        .parl_io_conf()
                        .modify(|_, w| w.parl_rst_en().bit(reset));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .pcnt_conf()
                        .modify(|_, w| w.pcnt_rst_en().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .rmt_conf()
                        .modify(|_, w| w.rmt_rst_en().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .rsa_conf()
                        .modify(|_, w| w.rsa_rst_en().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .sha_conf()
                        .modify(|_, w| w.sha_rst_en().bit(reset));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .systimer_conf()
                        .modify(|_, w| w.systimer_rst_en().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_conf()
                        .modify(|_, w| w.tg0_rst_en().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_conf()
                        .modify(|_, w| w.tg1_rst_en().bit(reset));
                }
                Peripheral::Trace0 => {
                    crate::peripherals::SYSTEM::regs()
                        .trace_conf()
                        .modify(|_, w| w.trace_rst_en().bit(reset));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai0_conf()
                        .modify(|_, w| w.twai0_rst_en().bit(reset));
                }
                Peripheral::Twai1 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai1_conf()
                        .modify(|_, w| w.twai1_rst_en().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(0)
                        .conf()
                        .modify(|_, w| w.rst_en().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(1)
                        .conf()
                        .modify(|_, w| w.rst_en().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uhci_conf()
                        .modify(|_, w| w.uhci_rst_en().bit(reset));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .usb_device_conf()
                        .modify(|_, w| w.usb_device_rst_en().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x40800000..0x40860000
    };
    (size as str, "DRAM") => {
        "393216"
    };
    ("DRAM2_UNINIT") => {
        0x0..0x4085E5A0
    };
    (size as str, "DRAM2_UNINIT") => {
        "1082516896"
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sw_interrupt {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, FROM_CPU_INTR0, software_interrupt0)); _for_each_inner!((1,
        FROM_CPU_INTR1, software_interrupt1)); _for_each_inner!((2, FROM_CPU_INTR2,
        software_interrupt2)); _for_each_inner!((3, FROM_CPU_INTR3,
        software_interrupt3)); _for_each_inner!((all(0, FROM_CPU_INTR0,
        software_interrupt0), (1, FROM_CPU_INTR1, software_interrupt1), (2,
        FROM_CPU_INTR2, software_interrupt2), (3, FROM_CPU_INTR3, software_interrupt3)));
    };
}
#[macro_export]
macro_rules! sw_interrupt_delay {
    () => {
        unsafe {
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
        }
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0)); _for_each_inner!((1)); _for_each_inner!((2));
        _for_each_inner!((3)); _for_each_inner!((0, 0)); _for_each_inner!((1, 1));
        _for_each_inner!((2, 0)); _for_each_inner!((3, 1)); _for_each_inner!((all(0),
        (1), (2), (3))); _for_each_inner!((tx(0, 0), (1, 1))); _for_each_inner!((rx(2,
        0), (3, 1)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Pll80MHz, 1)); _for_each_inner!((RcFast, 2));
        _for_each_inner!((Xtal, 3)); _for_each_inner!((RcFast));
        _for_each_inner!((all(Pll80MHz, 1), (RcFast, 2), (Xtal, 3)));
        _for_each_inner!((default(RcFast)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((1568)); _for_each_inner!((1600)); _for_each_inner!((1632));
        _for_each_inner!((1664)); _for_each_inner!((1696)); _for_each_inner!((1728));
        _for_each_inner!((1760)); _for_each_inner!((1792)); _for_each_inner!((1824));
        _for_each_inner!((1856)); _for_each_inner!((1888)); _for_each_inner!((1920));
        _for_each_inner!((1952)); _for_each_inner!((1984)); _for_each_inner!((2016));
        _for_each_inner!((2048)); _for_each_inner!((2080)); _for_each_inner!((2112));
        _for_each_inner!((2144)); _for_each_inner!((2176)); _for_each_inner!((2208));
        _for_each_inner!((2240)); _for_each_inner!((2272)); _for_each_inner!((2304));
        _for_each_inner!((2336)); _for_each_inner!((2368)); _for_each_inner!((2400));
        _for_each_inner!((2432)); _for_each_inner!((2464)); _for_each_inner!((2496));
        _for_each_inner!((2528)); _for_each_inner!((2560)); _for_each_inner!((2592));
        _for_each_inner!((2624)); _for_each_inner!((2656)); _for_each_inner!((2688));
        _for_each_inner!((2720)); _for_each_inner!((2752)); _for_each_inner!((2784));
        _for_each_inner!((2816)); _for_each_inner!((2848)); _for_each_inner!((2880));
        _for_each_inner!((2912)); _for_each_inner!((2944)); _for_each_inner!((2976));
        _for_each_inner!((3008)); _for_each_inner!((3040)); _for_each_inner!((3072));
        _for_each_inner!((all(32), (64), (96), (128), (160), (192), (224), (256), (288),
        (320), (352), (384), (416), (448), (480), (512), (544), (576), (608), (640),
        (672), (704), (736), (768), (800), (832), (864), (896), (928), (960), (992),
        (1024), (1056), (1088), (1120), (1152), (1184), (1216), (1248), (1280), (1312),
        (1344), (1376), (1408), (1440), (1472), (1504), (1536), (1568), (1600), (1632),
        (1664), (1696), (1728), (1760), (1792), (1824), (1856), (1888), (1920), (1952),
        (1984), (2016), (2048), (2080), (2112), (2144), (2176), (2208), (2240), (2272),
        (2304), (2336), (2368), (2400), (2432), (2464), (2496), (2528), (2560), (2592),
        (2624), (2656), (2688), (2720), (2752), (2784), (2816), (2848), (2880), (2912),
        (2944), (2976), (3008), (3040), (3072)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((all(32), (64), (96), (128), (160), (192), (224), (256), (288),
        (320), (352), (384), (416), (448), (480), (512), (544), (576), (608), (640),
        (672), (704), (736), (768), (800), (832), (864), (896), (928), (960), (992),
        (1024), (1056), (1088), (1120), (1152), (1184), (1216), (1248), (1280), (1312),
        (1344), (1376), (1408), (1440), (1472), (1504), (1536)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Sha1, "SHA-1"(sizes : 64, 20, 8) (insecure_against :
        "collision", "length extension"), 0)); _for_each_inner!((Sha224, "SHA-224"(sizes
        : 64, 28, 8) (insecure_against : "length extension"), 1));
        _for_each_inner!((Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against :
        "length extension"), 2)); _for_each_inner!((algos(Sha1, "SHA-1"(sizes : 64, 20,
        8) (insecure_against : "collision", "length extension"), 0), (Sha224,
        "SHA-224"(sizes : 64, 28, 8) (insecure_against : "length extension"), 1),
        (Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against : "length extension"),
        2)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((@ peri_type #[doc = "ASSIST_DEBUG peripheral singleton"]
        ASSIST_DEBUG <= BUS_MONITOR() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "APB_SARADC peripheral singleton"] APB_SARADC <= APB_SARADC() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "CLIC peripheral singleton"] CLIC <=
        CLINT() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "DMA peripheral singleton"] DMA <= DMA() (unstable))); _for_each_inner!((@
        peri_type #[doc = "DS peripheral singleton"] DS <= DS() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "ECC peripheral singleton"] ECC <= ECC()
        (unstable))); _for_each_inner!((@ peri_type #[doc = "ECDSA peripheral singleton"]
        ECDSA <= ECDSA() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "ETM peripheral singleton"] ETM <= SOC_ETM() (unstable))); _for_each_inner!((@
        peri_type #[doc = "HMAC peripheral singleton"] HMAC <= HMAC() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "HP_APM peripheral singleton"] HP_APM <=
        HP_APM() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "HP_SYS peripheral singleton"] HP_SYS <= HP_SYS() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "HUK peripheral singleton"] HUK <= HUK()
        (unstable))); _for_each_inner!((@ peri_type #[doc =
        "I2C_ANA_MST peripheral singleton"] I2C_ANA_MST <= I2C_ANA_MST() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "I2C0 peripheral singleton"] I2C0 <=
        I2C0(I2C_EXT0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type #[doc =
        "I2S0 peripheral singleton"] I2S0 <= I2S0(I2S0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type #[doc = "INTERRUPT_CORE0 peripheral singleton"]
        INTERRUPT_CORE0 <= INTERRUPT_CORE0() (unstable))); _for_each_inner!((@ peri_type
        #[doc = "INTPRI peripheral singleton"] INTPRI <= INTPRI() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "IO_MUX peripheral singleton"] IO_MUX <=
        IO_MUX() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "KEYMNG peripheral singleton"] KEYMNG <= KEYMNG() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_ANA peripheral singleton"] LP_ANA <=
        LP_ANA() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "LP_AON peripheral singleton"] LP_AON <= LP_AON() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_APM0 peripheral singleton"] LP_APM0 <=
        LP_APM0() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "LPWR peripheral singleton"] LPWR <= LP_CLKRST() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_I2C0 peripheral singleton"] LP_I2C0 <=
        LP_I2C0() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "LP_I2C_ANA_MST peripheral singleton"] LP_I2C_ANA_MST <= LP_I2C_ANA_MST()
        (unstable))); _for_each_inner!((@ peri_type #[doc =
        "LP_IO_MUX peripheral singleton"] LP_IO_MUX <= LP_IO_MUX() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_PERI peripheral singleton"] LP_PERI <=
        LPPERI() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "LP_TEE peripheral singleton"] LP_TEE <= LP_TEE() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_TIMER peripheral singleton"] LP_TIMER
        <= LP_TIMER() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "LP_UART peripheral singleton"] LP_UART <= LP_UART() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_WDT peripheral singleton"] LP_WDT <=
        LP_WDT() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "MCPWM0 peripheral singleton"] MCPWM0 <= MCPWM0() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "MEM_MONITOR peripheral singleton"]
        MEM_MONITOR <= MEM_MONITOR() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "MODEM_LPCON peripheral singleton"] MODEM_LPCON <= MODEM_LPCON() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "MODEM_SYSCON peripheral singleton"]
        MODEM_SYSCON <= MODEM_SYSCON() (unstable))); _for_each_inner!((@ peri_type #[doc
        = "PARL_IO peripheral singleton"] PARL_IO <= PARL_IO(PARL_IO_RX : {
        bind_rx_interrupt, enable_rx_interrupt, disable_rx_interrupt }, PARL_IO_TX : {
        bind_tx_interrupt, enable_tx_interrupt, disable_tx_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type #[doc = "PAU peripheral singleton"] PAU <= PAU()
        (unstable))); _for_each_inner!((@ peri_type #[doc = "PCR peripheral singleton"]
        PCR <= PCR() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "PMU peripheral singleton"] PMU <= PMU() (unstable))); _for_each_inner!((@
        peri_type #[doc = "PVT_MONITOR peripheral singleton"] PVT_MONITOR <= PVT()
        (unstable))); _for_each_inner!((@ peri_type #[doc = "RMT peripheral singleton"]
        RMT <= RMT() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "RSA peripheral singleton"] RSA <= RSA(RSA : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type #[doc = "SHA peripheral singleton"] SHA <= SHA(SHA
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type #[doc = "SLC peripheral singleton"]
        SLC <= SLC() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "SYSTEM peripheral singleton"] SYSTEM <= PCR() (unstable))); _for_each_inner!((@
        peri_type #[doc = "SYSTIMER peripheral singleton"] SYSTIMER <= SYSTIMER()
        (unstable))); _for_each_inner!((@ peri_type #[doc = "TEE peripheral singleton"]
        TEE <= TEE() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "TIMG0 peripheral singleton"] TIMG0 <= TIMG0() (unstable))); _for_each_inner!((@
        peri_type #[doc = "TIMG1 peripheral singleton"] TIMG1 <= TIMG1() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "TRACE0 peripheral singleton"] TRACE0 <=
        TRACE() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "UART0 peripheral singleton"] UART0 <= UART0(UART0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type #[doc = "UART1 peripheral singleton"] UART1 <=
        UART1(UART1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type #[doc =
        "UHCI0 peripheral singleton"] UHCI0 <= UHCI0() (unstable))); _for_each_inner!((@
        peri_type #[doc = "USB_DEVICE peripheral singleton"] USB_DEVICE <=
        USB_DEVICE(USB_DEVICE : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type #[doc =
        "BT peripheral singleton"] BT <= virtual() (unstable))); _for_each_inner!((@
        peri_type #[doc = "FLASH peripheral singleton"] FLASH <= virtual() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "LP_CORE peripheral singleton"] LP_CORE <=
        virtual() (unstable))); _for_each_inner!((@ peri_type #[doc =
        "SW_INTERRUPT peripheral singleton"] SW_INTERRUPT <= virtual() (unstable)));
        _for_each_inner!((@ peri_type #[doc = "WIFI peripheral singleton"] WIFI <=
        virtual() (unstable))); _for_each_inner!((ASSIST_DEBUG(unstable)));
        _for_each_inner!((APB_SARADC(unstable))); _for_each_inner!((CLIC(unstable)));
        _for_each_inner!((DMA(unstable))); _for_each_inner!((DS(unstable)));
        _for_each_inner!((ECC(unstable))); _for_each_inner!((ECDSA(unstable)));
        _for_each_inner!((ETM(unstable))); _for_each_inner!((HMAC(unstable)));
        _for_each_inner!((HP_APM(unstable))); _for_each_inner!((HP_SYS(unstable)));
        _for_each_inner!((HUK(unstable))); _for_each_inner!((I2C_ANA_MST(unstable)));
        _for_each_inner!((I2C0(unstable))); _for_each_inner!((I2S0(unstable)));
        _for_each_inner!((INTERRUPT_CORE0(unstable)));
        _for_each_inner!((INTPRI(unstable))); _for_each_inner!((IO_MUX(unstable)));
        _for_each_inner!((KEYMNG(unstable))); _for_each_inner!((LP_ANA(unstable)));
        _for_each_inner!((LP_AON(unstable))); _for_each_inner!((LP_APM0(unstable)));
        _for_each_inner!((LPWR(unstable))); _for_each_inner!((LP_I2C0(unstable)));
        _for_each_inner!((LP_I2C_ANA_MST(unstable)));
        _for_each_inner!((LP_IO_MUX(unstable))); _for_each_inner!((LP_PERI(unstable)));
        _for_each_inner!((LP_TEE(unstable))); _for_each_inner!((LP_TIMER(unstable)));
        _for_each_inner!((LP_UART(unstable))); _for_each_inner!((LP_WDT(unstable)));
        _for_each_inner!((MCPWM0(unstable))); _for_each_inner!((MEM_MONITOR(unstable)));
        _for_each_inner!((MODEM_LPCON(unstable)));
        _for_each_inner!((MODEM_SYSCON(unstable)));
        _for_each_inner!((PARL_IO(unstable))); _for_each_inner!((PAU(unstable)));
        _for_each_inner!((PCR(unstable))); _for_each_inner!((PMU(unstable)));
        _for_each_inner!((PVT_MONITOR(unstable))); _for_each_inner!((RMT(unstable)));
        _for_each_inner!((RSA(unstable))); _for_each_inner!((SHA(unstable)));
        _for_each_inner!((SLC(unstable))); _for_each_inner!((SYSTEM(unstable)));
        _for_each_inner!((SYSTIMER(unstable))); _for_each_inner!((TEE(unstable)));
        _for_each_inner!((TIMG0(unstable))); _for_each_inner!((TIMG1(unstable)));
        _for_each_inner!((TRACE0(unstable))); _for_each_inner!((UART0(unstable)));
        _for_each_inner!((UART1(unstable))); _for_each_inner!((UHCI0(unstable)));
        _for_each_inner!((USB_DEVICE(unstable))); _for_each_inner!((BT(unstable)));
        _for_each_inner!((FLASH(unstable))); _for_each_inner!((LP_CORE(unstable)));
        _for_each_inner!((SW_INTERRUPT(unstable))); _for_each_inner!((WIFI(unstable)));
        _for_each_inner!((all(@ peri_type #[doc = "ASSIST_DEBUG peripheral singleton"]
        ASSIST_DEBUG <= BUS_MONITOR() (unstable)), (@ peri_type #[doc =
        "APB_SARADC peripheral singleton"] APB_SARADC <= APB_SARADC() (unstable)), (@
        peri_type #[doc = "CLIC peripheral singleton"] CLIC <= CLINT() (unstable)), (@
        peri_type #[doc = "DMA peripheral singleton"] DMA <= DMA() (unstable)), (@
        peri_type #[doc = "DS peripheral singleton"] DS <= DS() (unstable)), (@ peri_type
        #[doc = "ECC peripheral singleton"] ECC <= ECC() (unstable)), (@ peri_type #[doc
        = "ECDSA peripheral singleton"] ECDSA <= ECDSA() (unstable)), (@ peri_type #[doc
        = "ETM peripheral singleton"] ETM <= SOC_ETM() (unstable)), (@ peri_type #[doc =
        "HMAC peripheral singleton"] HMAC <= HMAC() (unstable)), (@ peri_type #[doc =
        "HP_APM peripheral singleton"] HP_APM <= HP_APM() (unstable)), (@ peri_type #[doc
        = "HP_SYS peripheral singleton"] HP_SYS <= HP_SYS() (unstable)), (@ peri_type
        #[doc = "HUK peripheral singleton"] HUK <= HUK() (unstable)), (@ peri_type #[doc
        = "I2C_ANA_MST peripheral singleton"] I2C_ANA_MST <= I2C_ANA_MST() (unstable)),
        (@ peri_type #[doc = "I2C0 peripheral singleton"] I2C0 <= I2C0(I2C_EXT0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "I2S0 peripheral singleton"] I2S0 <= I2S0(I2S0
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "INTERRUPT_CORE0 peripheral singleton"]
        INTERRUPT_CORE0 <= INTERRUPT_CORE0() (unstable)), (@ peri_type #[doc =
        "INTPRI peripheral singleton"] INTPRI <= INTPRI() (unstable)), (@ peri_type #[doc
        = "IO_MUX peripheral singleton"] IO_MUX <= IO_MUX() (unstable)), (@ peri_type
        #[doc = "KEYMNG peripheral singleton"] KEYMNG <= KEYMNG() (unstable)), (@
        peri_type #[doc = "LP_ANA peripheral singleton"] LP_ANA <= LP_ANA() (unstable)),
        (@ peri_type #[doc = "LP_AON peripheral singleton"] LP_AON <= LP_AON()
        (unstable)), (@ peri_type #[doc = "LP_APM0 peripheral singleton"] LP_APM0 <=
        LP_APM0() (unstable)), (@ peri_type #[doc = "LPWR peripheral singleton"] LPWR <=
        LP_CLKRST() (unstable)), (@ peri_type #[doc = "LP_I2C0 peripheral singleton"]
        LP_I2C0 <= LP_I2C0() (unstable)), (@ peri_type #[doc =
        "LP_I2C_ANA_MST peripheral singleton"] LP_I2C_ANA_MST <= LP_I2C_ANA_MST()
        (unstable)), (@ peri_type #[doc = "LP_IO_MUX peripheral singleton"] LP_IO_MUX <=
        LP_IO_MUX() (unstable)), (@ peri_type #[doc = "LP_PERI peripheral singleton"]
        LP_PERI <= LPPERI() (unstable)), (@ peri_type #[doc =
        "LP_TEE peripheral singleton"] LP_TEE <= LP_TEE() (unstable)), (@ peri_type #[doc
        = "LP_TIMER peripheral singleton"] LP_TIMER <= LP_TIMER() (unstable)), (@
        peri_type #[doc = "LP_UART peripheral singleton"] LP_UART <= LP_UART()
        (unstable)), (@ peri_type #[doc = "LP_WDT peripheral singleton"] LP_WDT <=
        LP_WDT() (unstable)), (@ peri_type #[doc = "MCPWM0 peripheral singleton"] MCPWM0
        <= MCPWM0() (unstable)), (@ peri_type #[doc = "MEM_MONITOR peripheral singleton"]
        MEM_MONITOR <= MEM_MONITOR() (unstable)), (@ peri_type #[doc =
        "MODEM_LPCON peripheral singleton"] MODEM_LPCON <= MODEM_LPCON() (unstable)), (@
        peri_type #[doc = "MODEM_SYSCON peripheral singleton"] MODEM_SYSCON <=
        MODEM_SYSCON() (unstable)), (@ peri_type #[doc = "PARL_IO peripheral singleton"]
        PARL_IO <= PARL_IO(PARL_IO_RX : { bind_rx_interrupt, enable_rx_interrupt,
        disable_rx_interrupt }, PARL_IO_TX : { bind_tx_interrupt, enable_tx_interrupt,
        disable_tx_interrupt }) (unstable)), (@ peri_type #[doc =
        "PAU peripheral singleton"] PAU <= PAU() (unstable)), (@ peri_type #[doc =
        "PCR peripheral singleton"] PCR <= PCR() (unstable)), (@ peri_type #[doc =
        "PMU peripheral singleton"] PMU <= PMU() (unstable)), (@ peri_type #[doc =
        "PVT_MONITOR peripheral singleton"] PVT_MONITOR <= PVT() (unstable)), (@
        peri_type #[doc = "RMT peripheral singleton"] RMT <= RMT() (unstable)), (@
        peri_type #[doc = "RSA peripheral singleton"] RSA <= RSA(RSA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "SHA peripheral singleton"] SHA <= SHA(SHA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "SLC peripheral singleton"] SLC <= SLC()
        (unstable)), (@ peri_type #[doc = "SYSTEM peripheral singleton"] SYSTEM <= PCR()
        (unstable)), (@ peri_type #[doc = "SYSTIMER peripheral singleton"] SYSTIMER <=
        SYSTIMER() (unstable)), (@ peri_type #[doc = "TEE peripheral singleton"] TEE <=
        TEE() (unstable)), (@ peri_type #[doc = "TIMG0 peripheral singleton"] TIMG0 <=
        TIMG0() (unstable)), (@ peri_type #[doc = "TIMG1 peripheral singleton"] TIMG1 <=
        TIMG1() (unstable)), (@ peri_type #[doc = "TRACE0 peripheral singleton"] TRACE0
        <= TRACE() (unstable)), (@ peri_type #[doc = "UART0 peripheral singleton"] UART0
        <= UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type #[doc =
        "UART1 peripheral singleton"] UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type #[doc
        = "UHCI0 peripheral singleton"] UHCI0 <= UHCI0() (unstable)), (@ peri_type #[doc
        = "USB_DEVICE peripheral singleton"] USB_DEVICE <= USB_DEVICE(USB_DEVICE : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "BT peripheral singleton"] BT <= virtual()
        (unstable)), (@ peri_type #[doc = "FLASH peripheral singleton"] FLASH <=
        virtual() (unstable)), (@ peri_type #[doc = "LP_CORE peripheral singleton"]
        LP_CORE <= virtual() (unstable)), (@ peri_type #[doc =
        "SW_INTERRUPT peripheral singleton"] SW_INTERRUPT <= virtual() (unstable)), (@
        peri_type #[doc = "WIFI peripheral singleton"] WIFI <= virtual() (unstable))));
        _for_each_inner!((singletons(ASSIST_DEBUG(unstable)), (APB_SARADC(unstable)),
        (CLIC(unstable)), (DMA(unstable)), (DS(unstable)), (ECC(unstable)),
        (ECDSA(unstable)), (ETM(unstable)), (HMAC(unstable)), (HP_APM(unstable)),
        (HP_SYS(unstable)), (HUK(unstable)), (I2C_ANA_MST(unstable)), (I2C0(unstable)),
        (I2S0(unstable)), (INTERRUPT_CORE0(unstable)), (INTPRI(unstable)),
        (IO_MUX(unstable)), (KEYMNG(unstable)), (LP_ANA(unstable)), (LP_AON(unstable)),
        (LP_APM0(unstable)), (LPWR(unstable)), (LP_I2C0(unstable)),
        (LP_I2C_ANA_MST(unstable)), (LP_IO_MUX(unstable)), (LP_PERI(unstable)),
        (LP_TEE(unstable)), (LP_TIMER(unstable)), (LP_UART(unstable)),
        (LP_WDT(unstable)), (MCPWM0(unstable)), (MEM_MONITOR(unstable)),
        (MODEM_LPCON(unstable)), (MODEM_SYSCON(unstable)), (PARL_IO(unstable)),
        (PAU(unstable)), (PCR(unstable)), (PMU(unstable)), (PVT_MONITOR(unstable)),
        (RMT(unstable)), (RSA(unstable)), (SHA(unstable)), (SLC(unstable)),
        (SYSTEM(unstable)), (SYSTIMER(unstable)), (TEE(unstable)), (TIMG0(unstable)),
        (TIMG1(unstable)), (TRACE0(unstable)), (UART0(unstable)), (UART1(unstable)),
        (UHCI0(unstable)), (USB_DEVICE(unstable)), (BT(unstable)), (FLASH(unstable)),
        (LP_CORE(unstable)), (SW_INTERRUPT(unstable)), (WIFI(unstable))));
    };
}
