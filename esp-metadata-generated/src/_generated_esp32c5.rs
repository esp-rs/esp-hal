// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32c5"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32c5"
    };
    ("arch") => {
        "riscv"
    };
    ("cores") => {
        1
    };
    ("cores", str) => {
        stringify!(1)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-c5_technical_reference_manual_en.pdf"
    };
    ("aes.dma") => {
        true
    };
    ("aes.has_split_text_registers") => {
        true
    };
    ("aes.endianness_configurable") => {
        false
    };
    ("assist_debug.has_sp_monitor") => {
        false
    };
    ("assist_debug.has_region_monitor") => {
        false
    };
    ("bt.controller") => {
        "npl"
    };
    ("dedicated_gpio.needs_initialization") => {
        false
    };
    ("dedicated_gpio.channel_count") => {
        8
    };
    ("dedicated_gpio.channel_count", str) => {
        stringify!(8)
    };
    ("dma.kind") => {
        "gdma"
    };
    ("dma.supports_mem2mem") => {
        true
    };
    ("dma.separate_in_out_interrupts") => {
        true
    };
    ("dma.max_priority") => {
        5
    };
    ("dma.max_priority", str) => {
        stringify!(5)
    };
    ("dma.gdma_version") => {
        2
    };
    ("dma.gdma_version", str) => {
        stringify!(2)
    };
    ("ecc.working_modes") => {
        11
    };
    ("ecc.working_modes", str) => {
        stringify!(11)
    };
    ("gpio.has_bank_1") => {
        false
    };
    ("gpio.gpio_function") => {
        1
    };
    ("gpio.gpio_function", str) => {
        stringify!(1)
    };
    ("gpio.constant_0_input") => {
        96
    };
    ("gpio.constant_0_input", str) => {
        stringify!(96)
    };
    ("gpio.constant_1_input") => {
        64
    };
    ("gpio.constant_1_input", str) => {
        stringify!(64)
    };
    ("gpio.remap_iomux_pin_registers") => {
        false
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        116
    };
    ("gpio.input_signal_max", str) => {
        stringify!(116)
    };
    ("gpio.output_signal_max") => {
        256
    };
    ("gpio.output_signal_max", str) => {
        stringify!(256)
    };
    ("i2c_master.has_fsm_timeouts") => {
        true
    };
    ("i2c_master.has_hw_bus_clear") => {
        false
    };
    ("i2c_master.has_bus_timeout_enable") => {
        true
    };
    ("i2c_master.separate_filter_config_registers") => {
        false
    };
    ("i2c_master.can_estimate_nack_reason") => {
        true
    };
    ("i2c_master.has_conf_update") => {
        true
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        true
    };
    ("i2c_master.has_arbitration_en") => {
        true
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        true
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        true
    };
    ("i2c_master.max_bus_timeout") => {
        31
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(31)
    };
    ("i2c_master.ll_intr_mask") => {
        262143
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(262143)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("interrupts.status_registers") => {
        3
    };
    ("interrupts.status_registers", str) => {
        stringify!(3)
    };
    ("interrupts.disabled_interrupt") => {
        0
    };
    ("lp_i2c_master.fifo_size") => {
        16
    };
    ("lp_i2c_master.fifo_size", str) => {
        stringify!(16)
    };
    ("lp_uart.ram_size") => {
        32
    };
    ("lp_uart.ram_size", str) => {
        stringify!(32)
    };
    ("parl_io.version") => {
        2
    };
    ("parl_io.version", str) => {
        stringify!(2)
    };
    ("phy.combo_module") => {
        false
    };
    ("rmt.ram_start") => {
        1610638336
    };
    ("rmt.ram_start", str) => {
        stringify!(1610638336)
    };
    ("rmt.channel_ram_size") => {
        48
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(48)
    };
    ("rmt.has_tx_immediate_stop") => {
        true
    };
    ("rmt.has_tx_loop_count") => {
        true
    };
    ("rmt.has_tx_loop_auto_stop") => {
        true
    };
    ("rmt.has_tx_carrier_data_only") => {
        true
    };
    ("rmt.has_tx_sync") => {
        true
    };
    ("rmt.has_rx_wrap") => {
        true
    };
    ("rmt.has_rx_demodulation") => {
        true
    };
    ("rmt.has_dma") => {
        false
    };
    ("rmt.has_per_channel_clock") => {
        false
    };
    ("rng.apb_cycle_wait_num") => {
        16
    };
    ("rng.apb_cycle_wait_num", str) => {
        stringify!(16)
    };
    ("rng.trng_supported") => {
        false
    };
    ("rsa.size_increment") => {
        32
    };
    ("rsa.size_increment", str) => {
        stringify!(32)
    };
    ("rsa.memory_size_bytes") => {
        384
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(384)
    };
    ("sha.dma") => {
        true
    };
    ("sleep.light_sleep") => {
        false
    };
    ("sleep.deep_sleep") => {
        false
    };
    ("soc.cpu_has_branch_predictor") => {
        true
    };
    ("soc.cpu_has_csr_pc") => {
        false
    };
    ("soc.multi_core_enabled") => {
        false
    };
    ("soc.cpu_csr_prv_mode") => {
        2064
    };
    ("soc.cpu_csr_prv_mode", str) => {
        stringify!(2064)
    };
    ("soc.rc_fast_clk_default") => {
        17500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(17500000)
    };
    ("spi_master.supports_dma") => {
        true
    };
    ("spi_master.has_octal") => {
        false
    };
    ("spi_master.has_app_interrupts") => {
        true
    };
    ("spi_master.has_dma_segmented_transfer") => {
        true
    };
    ("spi_master.has_clk_pre_div") => {
        true
    };
    ("spi_slave.supports_dma") => {
        false
    };
    ("timergroup.timg_has_timer1") => {
        false
    };
    ("timergroup.timg_has_divcnt_rst") => {
        true
    };
    ("uart.ram_size") => {
        128
    };
    ("uart.ram_size", str) => {
        stringify!(128)
    };
    ("uart.peripheral_controls_mem_clk") => {
        true
    };
    ("uhci.combined_uart_selector_field") => {
        true
    };
    ("wifi.has_wifi6") => {
        false
    };
    ("wifi.mac_version") => {
        3
    };
    ("wifi.mac_version", str) => {
        stringify!(3)
    };
    ("wifi.has_5g") => {
        true
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_aes_key_length {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_aes_key_length { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_aes_key_length!((128));
        _for_each_inner_aes_key_length!((256)); _for_each_inner_aes_key_length!((128, 0,
        4)); _for_each_inner_aes_key_length!((256, 2, 6));
        _for_each_inner_aes_key_length!((bits(128), (256)));
        _for_each_inner_aes_key_length!((modes(128, 0, 4), (256, 2, 6)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_dedicated_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_dedicated_gpio { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_dedicated_gpio!((0));
        _for_each_inner_dedicated_gpio!((1)); _for_each_inner_dedicated_gpio!((2));
        _for_each_inner_dedicated_gpio!((3)); _for_each_inner_dedicated_gpio!((4));
        _for_each_inner_dedicated_gpio!((5)); _for_each_inner_dedicated_gpio!((6));
        _for_each_inner_dedicated_gpio!((7)); _for_each_inner_dedicated_gpio!((0, 0,
        CPU_GPIO_0)); _for_each_inner_dedicated_gpio!((0, 1, CPU_GPIO_1));
        _for_each_inner_dedicated_gpio!((0, 2, CPU_GPIO_2));
        _for_each_inner_dedicated_gpio!((0, 3, CPU_GPIO_3));
        _for_each_inner_dedicated_gpio!((0, 4, CPU_GPIO_4));
        _for_each_inner_dedicated_gpio!((0, 5, CPU_GPIO_5));
        _for_each_inner_dedicated_gpio!((0, 6, CPU_GPIO_6));
        _for_each_inner_dedicated_gpio!((0, 7, CPU_GPIO_7));
        _for_each_inner_dedicated_gpio!((channels(0), (1), (2), (3), (4), (5), (6),
        (7))); _for_each_inner_dedicated_gpio!((signals(0, 0, CPU_GPIO_0), (0, 1,
        CPU_GPIO_1), (0, 2, CPU_GPIO_2), (0, 3, CPU_GPIO_3), (0, 4, CPU_GPIO_4), (0, 5,
        CPU_GPIO_5), (0, 6, CPU_GPIO_6), (0, 7, CPU_GPIO_7)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_interrupt {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_interrupt { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_interrupt!(([disabled 0] 0));
        _for_each_inner_interrupt!(([reserved 0] 1));
        _for_each_inner_interrupt!(([reserved 1] 2));
        _for_each_inner_interrupt!(([reserved 2] 3));
        _for_each_inner_interrupt!(([reserved 3] 4));
        _for_each_inner_interrupt!(([reserved 4] 5));
        _for_each_inner_interrupt!(([reserved 5] 6));
        _for_each_inner_interrupt!(([reserved 6] 7));
        _for_each_inner_interrupt!(([reserved 7] 8));
        _for_each_inner_interrupt!(([reserved 8] 9));
        _for_each_inner_interrupt!(([reserved 9] 10));
        _for_each_inner_interrupt!(([reserved 10] 11));
        _for_each_inner_interrupt!(([reserved 11] 12));
        _for_each_inner_interrupt!(([reserved 12] 13));
        _for_each_inner_interrupt!(([reserved 13] 14));
        _for_each_inner_interrupt!(([reserved 14] 15));
        _for_each_inner_interrupt!(([vector 0] 16)); _for_each_inner_interrupt!(([vector
        1] 17)); _for_each_inner_interrupt!(([vector 2] 18));
        _for_each_inner_interrupt!(([vector 3] 19)); _for_each_inner_interrupt!(([vector
        4] 20)); _for_each_inner_interrupt!(([vector 5] 21));
        _for_each_inner_interrupt!(([vector 6] 22)); _for_each_inner_interrupt!(([vector
        7] 23)); _for_each_inner_interrupt!(([direct_bindable 0] 24));
        _for_each_inner_interrupt!(([direct_bindable 1] 25));
        _for_each_inner_interrupt!(([direct_bindable 2] 26));
        _for_each_inner_interrupt!(([direct_bindable 3] 27));
        _for_each_inner_interrupt!(([direct_bindable 4] 28));
        _for_each_inner_interrupt!(([direct_bindable 5] 29));
        _for_each_inner_interrupt!(([direct_bindable 6] 30));
        _for_each_inner_interrupt!(([direct_bindable 7] 31));
        _for_each_inner_interrupt!(([direct_bindable 8] 32));
        _for_each_inner_interrupt!(([direct_bindable 9] 33));
        _for_each_inner_interrupt!(([direct_bindable 10] 34));
        _for_each_inner_interrupt!(([direct_bindable 11] 35));
        _for_each_inner_interrupt!(([direct_bindable 12] 36));
        _for_each_inner_interrupt!(([direct_bindable 13] 37));
        _for_each_inner_interrupt!(([direct_bindable 14] 38));
        _for_each_inner_interrupt!(([direct_bindable 15] 39));
        _for_each_inner_interrupt!(([direct_bindable 16] 40));
        _for_each_inner_interrupt!(([direct_bindable 17] 41));
        _for_each_inner_interrupt!(([direct_bindable 18] 42));
        _for_each_inner_interrupt!(([direct_bindable 19] 43));
        _for_each_inner_interrupt!(([direct_bindable 20] 44));
        _for_each_inner_interrupt!(([direct_bindable 21] 45));
        _for_each_inner_interrupt!(([direct_bindable 22] 46));
        _for_each_inner_interrupt!(([direct_bindable 23] 47));
        _for_each_inner_interrupt!((all([disabled 0] 0), ([reserved 0] 1), ([reserved 1]
        2), ([reserved 2] 3), ([reserved 3] 4), ([reserved 4] 5), ([reserved 5] 6),
        ([reserved 6] 7), ([reserved 7] 8), ([reserved 8] 9), ([reserved 9] 10),
        ([reserved 10] 11), ([reserved 11] 12), ([reserved 12] 13), ([reserved 13] 14),
        ([reserved 14] 15), ([vector 0] 16), ([vector 1] 17), ([vector 2] 18), ([vector
        3] 19), ([vector 4] 20), ([vector 5] 21), ([vector 6] 22), ([vector 7] 23),
        ([direct_bindable 0] 24), ([direct_bindable 1] 25), ([direct_bindable 2] 26),
        ([direct_bindable 3] 27), ([direct_bindable 4] 28), ([direct_bindable 5] 29),
        ([direct_bindable 6] 30), ([direct_bindable 7] 31), ([direct_bindable 8] 32),
        ([direct_bindable 9] 33), ([direct_bindable 10] 34), ([direct_bindable 11] 35),
        ([direct_bindable 12] 36), ([direct_bindable 13] 37), ([direct_bindable 14] 38),
        ([direct_bindable 15] 39), ([direct_bindable 16] 40), ([direct_bindable 17] 41),
        ([direct_bindable 18] 42), ([direct_bindable 19] 43), ([direct_bindable 20] 44),
        ([direct_bindable 21] 45), ([direct_bindable 22] 46), ([direct_bindable 23]
        47)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_interrupt_priority {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_interrupt_priority { $(($pattern) => $code;)*
        ($other : tt) => {} } _for_each_inner_interrupt_priority!((0, 1, Priority1));
        _for_each_inner_interrupt_priority!((1, 2, Priority2));
        _for_each_inner_interrupt_priority!((2, 3, Priority3));
        _for_each_inner_interrupt_priority!((3, 4, Priority4));
        _for_each_inner_interrupt_priority!((4, 5, Priority5));
        _for_each_inner_interrupt_priority!((5, 6, Priority6));
        _for_each_inner_interrupt_priority!((6, 7, Priority7));
        _for_each_inner_interrupt_priority!((7, 8, Priority8));
        _for_each_inner_interrupt_priority!((all(0, 1, Priority1), (1, 2, Priority2), (2,
        3, Priority3), (3, 4, Priority4), (4, 5, Priority5), (5, 6, Priority6), (6, 7,
        Priority7), (7, 8, Priority8)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sw_interrupt {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_sw_interrupt { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_sw_interrupt!((0, FROM_CPU_INTR0,
        software_interrupt0)); _for_each_inner_sw_interrupt!((1, FROM_CPU_INTR1,
        software_interrupt1)); _for_each_inner_sw_interrupt!((2, FROM_CPU_INTR2,
        software_interrupt2)); _for_each_inner_sw_interrupt!((3, FROM_CPU_INTR3,
        software_interrupt3)); _for_each_inner_sw_interrupt!((all(0, FROM_CPU_INTR0,
        software_interrupt0), (1, FROM_CPU_INTR1, software_interrupt1), (2,
        FROM_CPU_INTR2, software_interrupt2), (3, FROM_CPU_INTR3, software_interrupt3)));
    };
}
#[macro_export]
macro_rules! sw_interrupt_delay {
    () => {
        unsafe {
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
        }
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rmt_channel { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_rmt_channel!((0)); _for_each_inner_rmt_channel!((1));
        _for_each_inner_rmt_channel!((2)); _for_each_inner_rmt_channel!((3));
        _for_each_inner_rmt_channel!((0, 0)); _for_each_inner_rmt_channel!((1, 1));
        _for_each_inner_rmt_channel!((2, 0)); _for_each_inner_rmt_channel!((3, 1));
        _for_each_inner_rmt_channel!((all(0), (1), (2), (3)));
        _for_each_inner_rmt_channel!((tx(0, 0), (1, 1)));
        _for_each_inner_rmt_channel!((rx(2, 0), (3, 1)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rmt_clock_source { $(($pattern) => $code;)* ($other
        : tt) => {} } _for_each_inner_rmt_clock_source!((Xtal, 0));
        _for_each_inner_rmt_clock_source!((RcFast, 1));
        _for_each_inner_rmt_clock_source!((Pll80MHz, 2));
        _for_each_inner_rmt_clock_source!((Pll80MHz));
        _for_each_inner_rmt_clock_source!((all(Xtal, 0), (RcFast, 1), (Pll80MHz, 2)));
        _for_each_inner_rmt_clock_source!((default(Pll80MHz)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rsa_exponentiation { $(($pattern) => $code;)*
        ($other : tt) => {} } _for_each_inner_rsa_exponentiation!((32));
        _for_each_inner_rsa_exponentiation!((64));
        _for_each_inner_rsa_exponentiation!((96));
        _for_each_inner_rsa_exponentiation!((128));
        _for_each_inner_rsa_exponentiation!((160));
        _for_each_inner_rsa_exponentiation!((192));
        _for_each_inner_rsa_exponentiation!((224));
        _for_each_inner_rsa_exponentiation!((256));
        _for_each_inner_rsa_exponentiation!((288));
        _for_each_inner_rsa_exponentiation!((320));
        _for_each_inner_rsa_exponentiation!((352));
        _for_each_inner_rsa_exponentiation!((384));
        _for_each_inner_rsa_exponentiation!((416));
        _for_each_inner_rsa_exponentiation!((448));
        _for_each_inner_rsa_exponentiation!((480));
        _for_each_inner_rsa_exponentiation!((512));
        _for_each_inner_rsa_exponentiation!((544));
        _for_each_inner_rsa_exponentiation!((576));
        _for_each_inner_rsa_exponentiation!((608));
        _for_each_inner_rsa_exponentiation!((640));
        _for_each_inner_rsa_exponentiation!((672));
        _for_each_inner_rsa_exponentiation!((704));
        _for_each_inner_rsa_exponentiation!((736));
        _for_each_inner_rsa_exponentiation!((768));
        _for_each_inner_rsa_exponentiation!((800));
        _for_each_inner_rsa_exponentiation!((832));
        _for_each_inner_rsa_exponentiation!((864));
        _for_each_inner_rsa_exponentiation!((896));
        _for_each_inner_rsa_exponentiation!((928));
        _for_each_inner_rsa_exponentiation!((960));
        _for_each_inner_rsa_exponentiation!((992));
        _for_each_inner_rsa_exponentiation!((1024));
        _for_each_inner_rsa_exponentiation!((1056));
        _for_each_inner_rsa_exponentiation!((1088));
        _for_each_inner_rsa_exponentiation!((1120));
        _for_each_inner_rsa_exponentiation!((1152));
        _for_each_inner_rsa_exponentiation!((1184));
        _for_each_inner_rsa_exponentiation!((1216));
        _for_each_inner_rsa_exponentiation!((1248));
        _for_each_inner_rsa_exponentiation!((1280));
        _for_each_inner_rsa_exponentiation!((1312));
        _for_each_inner_rsa_exponentiation!((1344));
        _for_each_inner_rsa_exponentiation!((1376));
        _for_each_inner_rsa_exponentiation!((1408));
        _for_each_inner_rsa_exponentiation!((1440));
        _for_each_inner_rsa_exponentiation!((1472));
        _for_each_inner_rsa_exponentiation!((1504));
        _for_each_inner_rsa_exponentiation!((1536));
        _for_each_inner_rsa_exponentiation!((1568));
        _for_each_inner_rsa_exponentiation!((1600));
        _for_each_inner_rsa_exponentiation!((1632));
        _for_each_inner_rsa_exponentiation!((1664));
        _for_each_inner_rsa_exponentiation!((1696));
        _for_each_inner_rsa_exponentiation!((1728));
        _for_each_inner_rsa_exponentiation!((1760));
        _for_each_inner_rsa_exponentiation!((1792));
        _for_each_inner_rsa_exponentiation!((1824));
        _for_each_inner_rsa_exponentiation!((1856));
        _for_each_inner_rsa_exponentiation!((1888));
        _for_each_inner_rsa_exponentiation!((1920));
        _for_each_inner_rsa_exponentiation!((1952));
        _for_each_inner_rsa_exponentiation!((1984));
        _for_each_inner_rsa_exponentiation!((2016));
        _for_each_inner_rsa_exponentiation!((2048));
        _for_each_inner_rsa_exponentiation!((2080));
        _for_each_inner_rsa_exponentiation!((2112));
        _for_each_inner_rsa_exponentiation!((2144));
        _for_each_inner_rsa_exponentiation!((2176));
        _for_each_inner_rsa_exponentiation!((2208));
        _for_each_inner_rsa_exponentiation!((2240));
        _for_each_inner_rsa_exponentiation!((2272));
        _for_each_inner_rsa_exponentiation!((2304));
        _for_each_inner_rsa_exponentiation!((2336));
        _for_each_inner_rsa_exponentiation!((2368));
        _for_each_inner_rsa_exponentiation!((2400));
        _for_each_inner_rsa_exponentiation!((2432));
        _for_each_inner_rsa_exponentiation!((2464));
        _for_each_inner_rsa_exponentiation!((2496));
        _for_each_inner_rsa_exponentiation!((2528));
        _for_each_inner_rsa_exponentiation!((2560));
        _for_each_inner_rsa_exponentiation!((2592));
        _for_each_inner_rsa_exponentiation!((2624));
        _for_each_inner_rsa_exponentiation!((2656));
        _for_each_inner_rsa_exponentiation!((2688));
        _for_each_inner_rsa_exponentiation!((2720));
        _for_each_inner_rsa_exponentiation!((2752));
        _for_each_inner_rsa_exponentiation!((2784));
        _for_each_inner_rsa_exponentiation!((2816));
        _for_each_inner_rsa_exponentiation!((2848));
        _for_each_inner_rsa_exponentiation!((2880));
        _for_each_inner_rsa_exponentiation!((2912));
        _for_each_inner_rsa_exponentiation!((2944));
        _for_each_inner_rsa_exponentiation!((2976));
        _for_each_inner_rsa_exponentiation!((3008));
        _for_each_inner_rsa_exponentiation!((3040));
        _for_each_inner_rsa_exponentiation!((3072));
        _for_each_inner_rsa_exponentiation!((all(32), (64), (96), (128), (160), (192),
        (224), (256), (288), (320), (352), (384), (416), (448), (480), (512), (544),
        (576), (608), (640), (672), (704), (736), (768), (800), (832), (864), (896),
        (928), (960), (992), (1024), (1056), (1088), (1120), (1152), (1184), (1216),
        (1248), (1280), (1312), (1344), (1376), (1408), (1440), (1472), (1504), (1536),
        (1568), (1600), (1632), (1664), (1696), (1728), (1760), (1792), (1824), (1856),
        (1888), (1920), (1952), (1984), (2016), (2048), (2080), (2112), (2144), (2176),
        (2208), (2240), (2272), (2304), (2336), (2368), (2400), (2432), (2464), (2496),
        (2528), (2560), (2592), (2624), (2656), (2688), (2720), (2752), (2784), (2816),
        (2848), (2880), (2912), (2944), (2976), (3008), (3040), (3072)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rsa_multiplication { $(($pattern) => $code;)*
        ($other : tt) => {} } _for_each_inner_rsa_multiplication!((32));
        _for_each_inner_rsa_multiplication!((64));
        _for_each_inner_rsa_multiplication!((96));
        _for_each_inner_rsa_multiplication!((128));
        _for_each_inner_rsa_multiplication!((160));
        _for_each_inner_rsa_multiplication!((192));
        _for_each_inner_rsa_multiplication!((224));
        _for_each_inner_rsa_multiplication!((256));
        _for_each_inner_rsa_multiplication!((288));
        _for_each_inner_rsa_multiplication!((320));
        _for_each_inner_rsa_multiplication!((352));
        _for_each_inner_rsa_multiplication!((384));
        _for_each_inner_rsa_multiplication!((416));
        _for_each_inner_rsa_multiplication!((448));
        _for_each_inner_rsa_multiplication!((480));
        _for_each_inner_rsa_multiplication!((512));
        _for_each_inner_rsa_multiplication!((544));
        _for_each_inner_rsa_multiplication!((576));
        _for_each_inner_rsa_multiplication!((608));
        _for_each_inner_rsa_multiplication!((640));
        _for_each_inner_rsa_multiplication!((672));
        _for_each_inner_rsa_multiplication!((704));
        _for_each_inner_rsa_multiplication!((736));
        _for_each_inner_rsa_multiplication!((768));
        _for_each_inner_rsa_multiplication!((800));
        _for_each_inner_rsa_multiplication!((832));
        _for_each_inner_rsa_multiplication!((864));
        _for_each_inner_rsa_multiplication!((896));
        _for_each_inner_rsa_multiplication!((928));
        _for_each_inner_rsa_multiplication!((960));
        _for_each_inner_rsa_multiplication!((992));
        _for_each_inner_rsa_multiplication!((1024));
        _for_each_inner_rsa_multiplication!((1056));
        _for_each_inner_rsa_multiplication!((1088));
        _for_each_inner_rsa_multiplication!((1120));
        _for_each_inner_rsa_multiplication!((1152));
        _for_each_inner_rsa_multiplication!((1184));
        _for_each_inner_rsa_multiplication!((1216));
        _for_each_inner_rsa_multiplication!((1248));
        _for_each_inner_rsa_multiplication!((1280));
        _for_each_inner_rsa_multiplication!((1312));
        _for_each_inner_rsa_multiplication!((1344));
        _for_each_inner_rsa_multiplication!((1376));
        _for_each_inner_rsa_multiplication!((1408));
        _for_each_inner_rsa_multiplication!((1440));
        _for_each_inner_rsa_multiplication!((1472));
        _for_each_inner_rsa_multiplication!((1504));
        _for_each_inner_rsa_multiplication!((1536));
        _for_each_inner_rsa_multiplication!((all(32), (64), (96), (128), (160), (192),
        (224), (256), (288), (320), (352), (384), (416), (448), (480), (512), (544),
        (576), (608), (640), (672), (704), (736), (768), (800), (832), (864), (896),
        (928), (960), (992), (1024), (1056), (1088), (1120), (1152), (1184), (1216),
        (1248), (1280), (1312), (1344), (1376), (1408), (1440), (1472), (1504), (1536)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_sha_algorithm { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_sha_algorithm!((Sha1, "SHA-1"(sizes : 64, 20, 8)
        (insecure_against : "collision", "length extension"), 0));
        _for_each_inner_sha_algorithm!((Sha224, "SHA-224"(sizes : 64, 28, 8)
        (insecure_against : "length extension"), 1));
        _for_each_inner_sha_algorithm!((Sha256, "SHA-256"(sizes : 64, 32, 8)
        (insecure_against : "length extension"), 2));
        _for_each_inner_sha_algorithm!((algos(Sha1, "SHA-1"(sizes : 64, 20, 8)
        (insecure_against : "collision", "length extension"), 0), (Sha224,
        "SHA-224"(sizes : 64, 28, 8) (insecure_against : "length extension"), 1),
        (Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against : "length extension"),
        2)));
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, no_run
/// // XTAL_CLK
///
/// fn configure_xtal_clk_impl(_clocks: &mut ClockTree, _config: XtalClkConfig) {
///     todo!()
/// }
///
/// // PLL_CLK
///
/// fn enable_pll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_FAST_CLK
///
/// fn enable_rc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL32K_CLK
///
/// fn enable_xtal32k_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // OSC_SLOW_CLK
///
/// fn enable_osc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_SLOW_CLK
///
/// fn enable_rc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F12M
///
/// fn enable_pll_f12m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F20M
///
/// fn enable_pll_f20m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F40M
///
/// fn enable_pll_f40m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F48M
///
/// fn enable_pll_f48m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F60M
///
/// fn enable_pll_f60m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F80M
///
/// fn enable_pll_f80m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F120M
///
/// fn enable_pll_f120m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F160M
///
/// fn enable_pll_f160m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F240M
///
/// fn enable_pll_f240m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // HP_ROOT_CLK
///
/// fn enable_hp_root_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_hp_root_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<HpRootClkConfig>,
///     _new_selector: HpRootClkConfig,
/// ) {
///     todo!()
/// }
///
/// // CPU_CLK
///
/// fn enable_cpu_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_clk_impl(_clocks: &mut ClockTree, _new_config: CpuClkConfig) {
///     todo!()
/// }
///
/// // AHB_CLK
///
/// fn enable_ahb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ahb_clk_impl(_clocks: &mut ClockTree, _new_config: AhbClkConfig) {
///     todo!()
/// }
///
/// // APB_CLK
///
/// fn enable_apb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apb_clk_impl(_clocks: &mut ClockTree, _new_config: ApbClkConfig) {
///     todo!()
/// }
///
/// // XTAL_D2_CLK
///
/// fn enable_xtal_d2_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // LP_FAST_CLK
///
/// fn enable_lp_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_lp_fast_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LpFastClkConfig>,
///     _new_selector: LpFastClkConfig,
/// ) {
///     todo!()
/// }
///
/// // LP_SLOW_CLK
///
/// fn enable_lp_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_lp_slow_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LpSlowClkConfig>,
///     _new_selector: LpSlowClkConfig,
/// ) {
///     todo!()
/// }
///
/// // CRYPTO_CLK
///
/// fn enable_crypto_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_crypto_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<CryptoClkConfig>,
///     _new_selector: CryptoClkConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG_CALIBRATION_CLOCK
///
/// fn enable_timg_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<TimgCalibrationClockConfig>,
///     _new_selector: TimgCalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // PARLIO_RX_CLOCK
///
/// fn enable_parlio_rx_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_parlio_rx_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<ParlioRxClockConfig>,
///     _new_selector: ParlioRxClockConfig,
/// ) {
///     todo!()
/// }
///
/// // PARLIO_TX_CLOCK
///
/// fn enable_parlio_tx_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_parlio_tx_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<ParlioTxClockConfig>,
///     _new_selector: ParlioTxClockConfig,
/// ) {
///     todo!()
/// }
///
/// // RMT_SCLK
///
/// fn enable_rmt_sclk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_rmt_sclk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RmtSclkConfig>,
///     _new_selector: RmtSclkConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_FUNCTION_CLOCK
///
/// fn enable_timg0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_WDT_CLOCK
///
/// fn enable_timg0_wdt_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_wdt_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0WdtClockConfig>,
///     _new_selector: Timg0WdtClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_FUNCTION_CLOCK
///
/// fn enable_timg1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_WDT_CLOCK
///
/// fn enable_timg1_wdt_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_wdt_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0WdtClockConfig>,
///     _new_selector: Timg0WdtClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART0_FUNCTION_CLOCK
///
/// fn enable_uart0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0FunctionClockConfig>,
///     _new_selector: Uart0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART1_FUNCTION_CLOCK
///
/// fn enable_uart1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0FunctionClockConfig>,
///     _new_selector: Uart0FunctionClockConfig,
/// ) {
///     todo!()
/// }
/// ```
macro_rules! define_clock_tree_types {
    () => {
        /// Selects the output frequency of `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum XtalClkConfig {
            /// 40 MHz
            _40,
            /// 48 MHz
            _48,
        }
        impl XtalClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    XtalClkConfig::_40 => 40000000,
                    XtalClkConfig::_48 => 48000000,
                }
            }
        }
        /// The list of clock signals that the `HP_ROOT_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HpRootClkConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_F160M`.
            PllF160m,
            /// Selects `PLL_F240M`.
            PllF240m,
        }
        /// Configures the `CPU_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct CpuClkConfig(u32);
        impl CpuClkConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`CPU_CLK` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `AHB_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct AhbClkConfig(u32);
        impl AhbClkConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`AHB_CLK` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `APB_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = AHB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct ApbClkConfig(u32);
        impl ApbClkConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`APB_CLK` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `LP_FAST_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LpFastClkConfig {
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `XTAL_D2_CLK`.
            XtalD2,
            /// Selects `XTAL_CLK`.
            Xtal,
        }
        /// The list of clock signals that the `LP_SLOW_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LpSlowClkConfig {
            /// Selects `RC_SLOW_CLK`.
            RcSlow,
            /// Selects `XTAL32K_CLK`.
            Xtal32k,
            /// Selects `OSC_SLOW_CLK`.
            OscSlow,
        }
        /// The list of clock signals that the `CRYPTO_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CryptoClkConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            Fosc,
            /// Selects `PLL_CLK`.
            PllF480m,
        }
        /// The list of clock signals that the `TIMG_CALIBRATION_CLOCK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TimgCalibrationClockConfig {
            /// Selects `OSC_SLOW_CLK`.
            OscSlowClk,
            /// Selects `RC_SLOW_CLK`.
            RcSlowClk,
            /// Selects `RC_FAST_CLK`.
            RcFastDivClk,
            /// Selects `XTAL32K_CLK`.
            Xtal32kClk,
        }
        /// The list of clock signals that the `PARLIO_RX_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ParlioRxClockConfig {
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            #[default]
            /// Selects `PLL_F240M`.
            PllF240m,
        }
        /// The list of clock signals that the `PARLIO_TX_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ParlioTxClockConfig {
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            #[default]
            /// Selects `PLL_F240M`.
            PllF240m,
        }
        /// The list of clock signals that the `RMT_SCLK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RmtSclkConfig {
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            #[default]
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `TIMG0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0FunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `TIMG0_WDT_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0WdtClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `PLL_F80M`.
            PllF80m,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
        }
        /// The list of clock signals that the `UART0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uart0FunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `PLL_F80M`.
            PllF80m,
            /// Selects `RC_FAST_CLK`.
            RcFast,
        }
        /// Represents the device's clock tree.
        pub struct ClockTree {
            xtal_clk: Option<XtalClkConfig>,
            hp_root_clk: Option<HpRootClkConfig>,
            cpu_clk: Option<CpuClkConfig>,
            ahb_clk: Option<AhbClkConfig>,
            apb_clk: Option<ApbClkConfig>,
            lp_fast_clk: Option<LpFastClkConfig>,
            lp_slow_clk: Option<LpSlowClkConfig>,
            crypto_clk: Option<CryptoClkConfig>,
            timg_calibration_clock: Option<TimgCalibrationClockConfig>,
            parlio_rx_clock: Option<ParlioRxClockConfig>,
            parlio_tx_clock: Option<ParlioTxClockConfig>,
            rmt_sclk: Option<RmtSclkConfig>,
            timg0_function_clock: Option<Timg0FunctionClockConfig>,
            timg0_wdt_clock: Option<Timg0WdtClockConfig>,
            timg1_function_clock: Option<Timg0FunctionClockConfig>,
            timg1_wdt_clock: Option<Timg0WdtClockConfig>,
            uart0_function_clock: Option<Uart0FunctionClockConfig>,
            uart1_function_clock: Option<Uart0FunctionClockConfig>,
            pll_clk_refcount: u32,
            rc_fast_clk_refcount: u32,
            xtal32k_clk_refcount: u32,
            osc_slow_clk_refcount: u32,
            rc_slow_clk_refcount: u32,
            pll_f12m_refcount: u32,
            pll_f20m_refcount: u32,
            pll_f40m_refcount: u32,
            pll_f48m_refcount: u32,
            pll_f60m_refcount: u32,
            pll_f80m_refcount: u32,
            pll_f120m_refcount: u32,
            pll_f240m_refcount: u32,
            hp_root_clk_refcount: u32,
            cpu_clk_refcount: u32,
            apb_clk_refcount: u32,
            lp_fast_clk_refcount: u32,
            lp_slow_clk_refcount: u32,
            crypto_clk_refcount: u32,
            timg_calibration_clock_refcount: u32,
            parlio_rx_clock_refcount: u32,
            parlio_tx_clock_refcount: u32,
            rmt_sclk_refcount: u32,
            timg0_function_clock_refcount: u32,
            timg0_wdt_clock_refcount: u32,
            timg1_function_clock_refcount: u32,
            timg1_wdt_clock_refcount: u32,
            uart0_function_clock_refcount: u32,
            uart1_function_clock_refcount: u32,
        }
        impl ClockTree {
            /// Locks the clock tree for exclusive access.
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
            /// Returns the current configuration of the XTAL_CLK clock tree node
            pub fn xtal_clk(&self) -> Option<XtalClkConfig> {
                self.xtal_clk
            }
            /// Returns the current configuration of the HP_ROOT_CLK clock tree node
            pub fn hp_root_clk(&self) -> Option<HpRootClkConfig> {
                self.hp_root_clk
            }
            /// Returns the current configuration of the CPU_CLK clock tree node
            pub fn cpu_clk(&self) -> Option<CpuClkConfig> {
                self.cpu_clk
            }
            /// Returns the current configuration of the AHB_CLK clock tree node
            pub fn ahb_clk(&self) -> Option<AhbClkConfig> {
                self.ahb_clk
            }
            /// Returns the current configuration of the APB_CLK clock tree node
            pub fn apb_clk(&self) -> Option<ApbClkConfig> {
                self.apb_clk
            }
            /// Returns the current configuration of the LP_FAST_CLK clock tree node
            pub fn lp_fast_clk(&self) -> Option<LpFastClkConfig> {
                self.lp_fast_clk
            }
            /// Returns the current configuration of the LP_SLOW_CLK clock tree node
            pub fn lp_slow_clk(&self) -> Option<LpSlowClkConfig> {
                self.lp_slow_clk
            }
            /// Returns the current configuration of the CRYPTO_CLK clock tree node
            pub fn crypto_clk(&self) -> Option<CryptoClkConfig> {
                self.crypto_clk
            }
            /// Returns the current configuration of the TIMG_CALIBRATION_CLOCK clock tree node
            pub fn timg_calibration_clock(&self) -> Option<TimgCalibrationClockConfig> {
                self.timg_calibration_clock
            }
            /// Returns the current configuration of the PARLIO_RX_CLOCK clock tree node
            pub fn parlio_rx_clock(&self) -> Option<ParlioRxClockConfig> {
                self.parlio_rx_clock
            }
            /// Returns the current configuration of the PARLIO_TX_CLOCK clock tree node
            pub fn parlio_tx_clock(&self) -> Option<ParlioTxClockConfig> {
                self.parlio_tx_clock
            }
            /// Returns the current configuration of the RMT_SCLK clock tree node
            pub fn rmt_sclk(&self) -> Option<RmtSclkConfig> {
                self.rmt_sclk
            }
            /// Returns the current configuration of the TIMG0_FUNCTION_CLOCK clock tree node
            pub fn timg0_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg0_function_clock
            }
            /// Returns the current configuration of the TIMG0_WDT_CLOCK clock tree node
            pub fn timg0_wdt_clock(&self) -> Option<Timg0WdtClockConfig> {
                self.timg0_wdt_clock
            }
            /// Returns the current configuration of the TIMG1_FUNCTION_CLOCK clock tree node
            pub fn timg1_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg1_function_clock
            }
            /// Returns the current configuration of the TIMG1_WDT_CLOCK clock tree node
            pub fn timg1_wdt_clock(&self) -> Option<Timg0WdtClockConfig> {
                self.timg1_wdt_clock
            }
            /// Returns the current configuration of the UART0_FUNCTION_CLOCK clock tree node
            pub fn uart0_function_clock(&self) -> Option<Uart0FunctionClockConfig> {
                self.uart0_function_clock
            }
            /// Returns the current configuration of the UART1_FUNCTION_CLOCK clock tree node
            pub fn uart1_function_clock(&self) -> Option<Uart0FunctionClockConfig> {
                self.uart1_function_clock
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {
                xtal_clk: None,
                hp_root_clk: None,
                cpu_clk: None,
                ahb_clk: None,
                apb_clk: None,
                lp_fast_clk: None,
                lp_slow_clk: None,
                crypto_clk: None,
                timg_calibration_clock: None,
                parlio_rx_clock: None,
                parlio_tx_clock: None,
                rmt_sclk: None,
                timg0_function_clock: None,
                timg0_wdt_clock: None,
                timg1_function_clock: None,
                timg1_wdt_clock: None,
                uart0_function_clock: None,
                uart1_function_clock: None,
                pll_clk_refcount: 0,
                rc_fast_clk_refcount: 0,
                xtal32k_clk_refcount: 0,
                osc_slow_clk_refcount: 0,
                rc_slow_clk_refcount: 0,
                pll_f12m_refcount: 0,
                pll_f20m_refcount: 0,
                pll_f40m_refcount: 0,
                pll_f48m_refcount: 0,
                pll_f60m_refcount: 0,
                pll_f80m_refcount: 0,
                pll_f120m_refcount: 0,
                pll_f240m_refcount: 0,
                hp_root_clk_refcount: 0,
                cpu_clk_refcount: 0,
                apb_clk_refcount: 0,
                lp_fast_clk_refcount: 0,
                lp_slow_clk_refcount: 0,
                crypto_clk_refcount: 0,
                timg_calibration_clock_refcount: 0,
                parlio_rx_clock_refcount: 0,
                parlio_tx_clock_refcount: 0,
                rmt_sclk_refcount: 0,
                timg0_function_clock_refcount: 0,
                timg0_wdt_clock_refcount: 0,
                timg1_function_clock_refcount: 0,
                timg1_wdt_clock_refcount: 0,
                uart0_function_clock_refcount: 0,
                uart1_function_clock_refcount: 0,
            });
        pub fn configure_xtal_clk(clocks: &mut ClockTree, config: XtalClkConfig) {
            clocks.xtal_clk = Some(config);
            configure_xtal_clk_impl(clocks, config);
        }
        pub fn xtal_clk_config(clocks: &mut ClockTree) -> Option<XtalClkConfig> {
            clocks.xtal_clk
        }
        fn request_xtal_clk(_clocks: &mut ClockTree) {}
        fn release_xtal_clk(_clocks: &mut ClockTree) {}
        pub fn xtal_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.xtal_clk).value()
        }
        pub fn request_pll_clk(clocks: &mut ClockTree) {
            trace!("Requesting PLL_CLK");
            if increment_reference_count(&mut clocks.pll_clk_refcount) {
                trace!("Enabling PLL_CLK");
                request_xtal_clk(clocks);
                enable_pll_clk_impl(clocks, true);
            }
        }
        pub fn release_pll_clk(clocks: &mut ClockTree) {
            trace!("Releasing PLL_CLK");
            if decrement_reference_count(&mut clocks.pll_clk_refcount) {
                trace!("Disabling PLL_CLK");
                enable_pll_clk_impl(clocks, false);
                release_xtal_clk(clocks);
            }
        }
        pub fn pll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            480000000
        }
        pub fn request_rc_fast_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_FAST_CLK");
            if increment_reference_count(&mut clocks.rc_fast_clk_refcount) {
                trace!("Enabling RC_FAST_CLK");
                enable_rc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_FAST_CLK");
            if decrement_reference_count(&mut clocks.rc_fast_clk_refcount) {
                trace!("Disabling RC_FAST_CLK");
                enable_rc_fast_clk_impl(clocks, false);
            }
        }
        pub fn rc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            20000000
        }
        pub fn request_xtal32k_clk(clocks: &mut ClockTree) {
            trace!("Requesting XTAL32K_CLK");
            if increment_reference_count(&mut clocks.xtal32k_clk_refcount) {
                trace!("Enabling XTAL32K_CLK");
                enable_xtal32k_clk_impl(clocks, true);
            }
        }
        pub fn release_xtal32k_clk(clocks: &mut ClockTree) {
            trace!("Releasing XTAL32K_CLK");
            if decrement_reference_count(&mut clocks.xtal32k_clk_refcount) {
                trace!("Disabling XTAL32K_CLK");
                enable_xtal32k_clk_impl(clocks, false);
            }
        }
        pub fn xtal32k_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_osc_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting OSC_SLOW_CLK");
            if increment_reference_count(&mut clocks.osc_slow_clk_refcount) {
                trace!("Enabling OSC_SLOW_CLK");
                enable_osc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_osc_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing OSC_SLOW_CLK");
            if decrement_reference_count(&mut clocks.osc_slow_clk_refcount) {
                trace!("Disabling OSC_SLOW_CLK");
                enable_osc_slow_clk_impl(clocks, false);
            }
        }
        pub fn osc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_rc_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_SLOW_CLK");
            if increment_reference_count(&mut clocks.rc_slow_clk_refcount) {
                trace!("Enabling RC_SLOW_CLK");
                enable_rc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_SLOW_CLK");
            if decrement_reference_count(&mut clocks.rc_slow_clk_refcount) {
                trace!("Disabling RC_SLOW_CLK");
                enable_rc_slow_clk_impl(clocks, false);
            }
        }
        pub fn rc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            130000
        }
        pub fn request_pll_f12m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F12M");
            if increment_reference_count(&mut clocks.pll_f12m_refcount) {
                trace!("Enabling PLL_F12M");
                request_pll_clk(clocks);
                enable_pll_f12m_impl(clocks, true);
            }
        }
        pub fn release_pll_f12m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F12M");
            if decrement_reference_count(&mut clocks.pll_f12m_refcount) {
                trace!("Disabling PLL_F12M");
                enable_pll_f12m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f12m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 40)
        }
        pub fn request_pll_f20m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F20M");
            if increment_reference_count(&mut clocks.pll_f20m_refcount) {
                trace!("Enabling PLL_F20M");
                request_pll_clk(clocks);
                enable_pll_f20m_impl(clocks, true);
            }
        }
        pub fn release_pll_f20m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F20M");
            if decrement_reference_count(&mut clocks.pll_f20m_refcount) {
                trace!("Disabling PLL_F20M");
                enable_pll_f20m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f20m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 24)
        }
        pub fn request_pll_f40m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F40M");
            if increment_reference_count(&mut clocks.pll_f40m_refcount) {
                trace!("Enabling PLL_F40M");
                request_pll_clk(clocks);
                enable_pll_f40m_impl(clocks, true);
            }
        }
        pub fn release_pll_f40m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F40M");
            if decrement_reference_count(&mut clocks.pll_f40m_refcount) {
                trace!("Disabling PLL_F40M");
                enable_pll_f40m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f40m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 12)
        }
        pub fn request_pll_f48m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F48M");
            if increment_reference_count(&mut clocks.pll_f48m_refcount) {
                trace!("Enabling PLL_F48M");
                request_pll_clk(clocks);
                enable_pll_f48m_impl(clocks, true);
            }
        }
        pub fn release_pll_f48m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F48M");
            if decrement_reference_count(&mut clocks.pll_f48m_refcount) {
                trace!("Disabling PLL_F48M");
                enable_pll_f48m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f48m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 10)
        }
        pub fn request_pll_f60m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F60M");
            if increment_reference_count(&mut clocks.pll_f60m_refcount) {
                trace!("Enabling PLL_F60M");
                request_pll_clk(clocks);
                enable_pll_f60m_impl(clocks, true);
            }
        }
        pub fn release_pll_f60m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F60M");
            if decrement_reference_count(&mut clocks.pll_f60m_refcount) {
                trace!("Disabling PLL_F60M");
                enable_pll_f60m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f60m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 8)
        }
        pub fn request_pll_f80m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F80M");
            if increment_reference_count(&mut clocks.pll_f80m_refcount) {
                trace!("Enabling PLL_F80M");
                request_pll_clk(clocks);
                enable_pll_f80m_impl(clocks, true);
            }
        }
        pub fn release_pll_f80m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F80M");
            if decrement_reference_count(&mut clocks.pll_f80m_refcount) {
                trace!("Disabling PLL_F80M");
                enable_pll_f80m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f80m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 6)
        }
        pub fn request_pll_f120m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F120M");
            if increment_reference_count(&mut clocks.pll_f120m_refcount) {
                trace!("Enabling PLL_F120M");
                request_pll_clk(clocks);
                enable_pll_f120m_impl(clocks, true);
            }
        }
        pub fn release_pll_f120m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F120M");
            if decrement_reference_count(&mut clocks.pll_f120m_refcount) {
                trace!("Disabling PLL_F120M");
                enable_pll_f120m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f120m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 4)
        }
        pub fn request_pll_f160m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F160M");
            trace!("Enabling PLL_F160M");
            request_pll_clk(clocks);
            enable_pll_f160m_impl(clocks, true);
        }
        pub fn release_pll_f160m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F160M");
            trace!("Disabling PLL_F160M");
            enable_pll_f160m_impl(clocks, false);
            release_pll_clk(clocks);
        }
        pub fn pll_f160m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 3)
        }
        pub fn request_pll_f240m(clocks: &mut ClockTree) {
            trace!("Requesting PLL_F240M");
            if increment_reference_count(&mut clocks.pll_f240m_refcount) {
                trace!("Enabling PLL_F240M");
                request_pll_clk(clocks);
                enable_pll_f240m_impl(clocks, true);
            }
        }
        pub fn release_pll_f240m(clocks: &mut ClockTree) {
            trace!("Releasing PLL_F240M");
            if decrement_reference_count(&mut clocks.pll_f240m_refcount) {
                trace!("Disabling PLL_F240M");
                enable_pll_f240m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f240m_frequency(clocks: &mut ClockTree) -> u32 {
            (pll_clk_frequency(clocks) / 2)
        }
        pub fn configure_hp_root_clk(clocks: &mut ClockTree, new_selector: HpRootClkConfig) {
            let old_selector = clocks.hp_root_clk.replace(new_selector);
            if clocks.hp_root_clk_refcount > 0 {
                match new_selector {
                    HpRootClkConfig::Xtal => request_xtal_clk(clocks),
                    HpRootClkConfig::RcFast => request_rc_fast_clk(clocks),
                    HpRootClkConfig::PllF160m => request_pll_f160m(clocks),
                    HpRootClkConfig::PllF240m => request_pll_f240m(clocks),
                }
                configure_hp_root_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        HpRootClkConfig::Xtal => release_xtal_clk(clocks),
                        HpRootClkConfig::RcFast => release_rc_fast_clk(clocks),
                        HpRootClkConfig::PllF160m => release_pll_f160m(clocks),
                        HpRootClkConfig::PllF240m => release_pll_f240m(clocks),
                    }
                }
            } else {
                configure_hp_root_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn hp_root_clk_config(clocks: &mut ClockTree) -> Option<HpRootClkConfig> {
            clocks.hp_root_clk
        }
        pub fn request_hp_root_clk(clocks: &mut ClockTree) {
            trace!("Requesting HP_ROOT_CLK");
            if increment_reference_count(&mut clocks.hp_root_clk_refcount) {
                trace!("Enabling HP_ROOT_CLK");
                match unwrap!(clocks.hp_root_clk) {
                    HpRootClkConfig::Xtal => request_xtal_clk(clocks),
                    HpRootClkConfig::RcFast => request_rc_fast_clk(clocks),
                    HpRootClkConfig::PllF160m => request_pll_f160m(clocks),
                    HpRootClkConfig::PllF240m => request_pll_f240m(clocks),
                }
                enable_hp_root_clk_impl(clocks, true);
            }
        }
        pub fn release_hp_root_clk(clocks: &mut ClockTree) {
            trace!("Releasing HP_ROOT_CLK");
            if decrement_reference_count(&mut clocks.hp_root_clk_refcount) {
                trace!("Disabling HP_ROOT_CLK");
                enable_hp_root_clk_impl(clocks, false);
                match unwrap!(clocks.hp_root_clk) {
                    HpRootClkConfig::Xtal => release_xtal_clk(clocks),
                    HpRootClkConfig::RcFast => release_rc_fast_clk(clocks),
                    HpRootClkConfig::PllF160m => release_pll_f160m(clocks),
                    HpRootClkConfig::PllF240m => release_pll_f240m(clocks),
                }
            }
        }
        pub fn hp_root_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.hp_root_clk) {
                HpRootClkConfig::Xtal => xtal_clk_frequency(clocks),
                HpRootClkConfig::RcFast => rc_fast_clk_frequency(clocks),
                HpRootClkConfig::PllF160m => pll_f160m_frequency(clocks),
                HpRootClkConfig::PllF240m => pll_f240m_frequency(clocks),
            }
        }
        pub fn configure_cpu_clk(clocks: &mut ClockTree, config: CpuClkConfig) {
            clocks.cpu_clk = Some(config);
            configure_cpu_clk_impl(clocks, config);
        }
        pub fn cpu_clk_config(clocks: &mut ClockTree) -> Option<CpuClkConfig> {
            clocks.cpu_clk
        }
        pub fn request_cpu_clk(clocks: &mut ClockTree) {
            trace!("Requesting CPU_CLK");
            if increment_reference_count(&mut clocks.cpu_clk_refcount) {
                trace!("Enabling CPU_CLK");
                request_hp_root_clk(clocks);
                enable_cpu_clk_impl(clocks, true);
            }
        }
        pub fn release_cpu_clk(clocks: &mut ClockTree) {
            trace!("Releasing CPU_CLK");
            if decrement_reference_count(&mut clocks.cpu_clk_refcount) {
                trace!("Disabling CPU_CLK");
                enable_cpu_clk_impl(clocks, false);
                release_hp_root_clk(clocks);
            }
        }
        pub fn cpu_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.cpu_clk).value() + 1))
        }
        pub fn configure_ahb_clk(clocks: &mut ClockTree, config: AhbClkConfig) {
            clocks.ahb_clk = Some(config);
            configure_ahb_clk_impl(clocks, config);
        }
        pub fn ahb_clk_config(clocks: &mut ClockTree) -> Option<AhbClkConfig> {
            clocks.ahb_clk
        }
        pub fn request_ahb_clk(clocks: &mut ClockTree) {
            trace!("Requesting AHB_CLK");
            trace!("Enabling AHB_CLK");
            request_hp_root_clk(clocks);
            enable_ahb_clk_impl(clocks, true);
        }
        pub fn release_ahb_clk(clocks: &mut ClockTree) {
            trace!("Releasing AHB_CLK");
            trace!("Disabling AHB_CLK");
            enable_ahb_clk_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn ahb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.ahb_clk).value() + 1))
        }
        pub fn configure_apb_clk(clocks: &mut ClockTree, config: ApbClkConfig) {
            clocks.apb_clk = Some(config);
            configure_apb_clk_impl(clocks, config);
        }
        pub fn apb_clk_config(clocks: &mut ClockTree) -> Option<ApbClkConfig> {
            clocks.apb_clk
        }
        pub fn request_apb_clk(clocks: &mut ClockTree) {
            trace!("Requesting APB_CLK");
            if increment_reference_count(&mut clocks.apb_clk_refcount) {
                trace!("Enabling APB_CLK");
                request_ahb_clk(clocks);
                enable_apb_clk_impl(clocks, true);
            }
        }
        pub fn release_apb_clk(clocks: &mut ClockTree) {
            trace!("Releasing APB_CLK");
            if decrement_reference_count(&mut clocks.apb_clk_refcount) {
                trace!("Disabling APB_CLK");
                enable_apb_clk_impl(clocks, false);
                release_ahb_clk(clocks);
            }
        }
        pub fn apb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (ahb_clk_frequency(clocks) / (unwrap!(clocks.apb_clk).value() + 1))
        }
        pub fn request_xtal_d2_clk(clocks: &mut ClockTree) {
            trace!("Requesting XTAL_D2_CLK");
            trace!("Enabling XTAL_D2_CLK");
            request_xtal_clk(clocks);
            enable_xtal_d2_clk_impl(clocks, true);
        }
        pub fn release_xtal_d2_clk(clocks: &mut ClockTree) {
            trace!("Releasing XTAL_D2_CLK");
            trace!("Disabling XTAL_D2_CLK");
            enable_xtal_d2_clk_impl(clocks, false);
            release_xtal_clk(clocks);
        }
        pub fn xtal_d2_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (xtal_clk_frequency(clocks) / 2)
        }
        pub fn configure_lp_fast_clk(clocks: &mut ClockTree, new_selector: LpFastClkConfig) {
            let old_selector = clocks.lp_fast_clk.replace(new_selector);
            if clocks.lp_fast_clk_refcount > 0 {
                match new_selector {
                    LpFastClkConfig::RcFast => request_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2 => request_xtal_d2_clk(clocks),
                    LpFastClkConfig::Xtal => request_xtal_clk(clocks),
                }
                configure_lp_fast_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LpFastClkConfig::RcFast => release_rc_fast_clk(clocks),
                        LpFastClkConfig::XtalD2 => release_xtal_d2_clk(clocks),
                        LpFastClkConfig::Xtal => release_xtal_clk(clocks),
                    }
                }
            } else {
                configure_lp_fast_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn lp_fast_clk_config(clocks: &mut ClockTree) -> Option<LpFastClkConfig> {
            clocks.lp_fast_clk
        }
        pub fn request_lp_fast_clk(clocks: &mut ClockTree) {
            trace!("Requesting LP_FAST_CLK");
            if increment_reference_count(&mut clocks.lp_fast_clk_refcount) {
                trace!("Enabling LP_FAST_CLK");
                match unwrap!(clocks.lp_fast_clk) {
                    LpFastClkConfig::RcFast => request_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2 => request_xtal_d2_clk(clocks),
                    LpFastClkConfig::Xtal => request_xtal_clk(clocks),
                }
                enable_lp_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_lp_fast_clk(clocks: &mut ClockTree) {
            trace!("Releasing LP_FAST_CLK");
            if decrement_reference_count(&mut clocks.lp_fast_clk_refcount) {
                trace!("Disabling LP_FAST_CLK");
                enable_lp_fast_clk_impl(clocks, false);
                match unwrap!(clocks.lp_fast_clk) {
                    LpFastClkConfig::RcFast => release_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2 => release_xtal_d2_clk(clocks),
                    LpFastClkConfig::Xtal => release_xtal_clk(clocks),
                }
            }
        }
        pub fn lp_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.lp_fast_clk) {
                LpFastClkConfig::RcFast => rc_fast_clk_frequency(clocks),
                LpFastClkConfig::XtalD2 => xtal_d2_clk_frequency(clocks),
                LpFastClkConfig::Xtal => xtal_clk_frequency(clocks),
            }
        }
        pub fn configure_lp_slow_clk(clocks: &mut ClockTree, new_selector: LpSlowClkConfig) {
            let old_selector = clocks.lp_slow_clk.replace(new_selector);
            if clocks.lp_slow_clk_refcount > 0 {
                match new_selector {
                    LpSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    LpSlowClkConfig::Xtal32k => request_xtal32k_clk(clocks),
                    LpSlowClkConfig::OscSlow => request_osc_slow_clk(clocks),
                }
                configure_lp_slow_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LpSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                        LpSlowClkConfig::Xtal32k => release_xtal32k_clk(clocks),
                        LpSlowClkConfig::OscSlow => release_osc_slow_clk(clocks),
                    }
                }
            } else {
                configure_lp_slow_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn lp_slow_clk_config(clocks: &mut ClockTree) -> Option<LpSlowClkConfig> {
            clocks.lp_slow_clk
        }
        pub fn request_lp_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting LP_SLOW_CLK");
            if increment_reference_count(&mut clocks.lp_slow_clk_refcount) {
                trace!("Enabling LP_SLOW_CLK");
                match unwrap!(clocks.lp_slow_clk) {
                    LpSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    LpSlowClkConfig::Xtal32k => request_xtal32k_clk(clocks),
                    LpSlowClkConfig::OscSlow => request_osc_slow_clk(clocks),
                }
                enable_lp_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_lp_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing LP_SLOW_CLK");
            if decrement_reference_count(&mut clocks.lp_slow_clk_refcount) {
                trace!("Disabling LP_SLOW_CLK");
                enable_lp_slow_clk_impl(clocks, false);
                match unwrap!(clocks.lp_slow_clk) {
                    LpSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                    LpSlowClkConfig::Xtal32k => release_xtal32k_clk(clocks),
                    LpSlowClkConfig::OscSlow => release_osc_slow_clk(clocks),
                }
            }
        }
        pub fn lp_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.lp_slow_clk) {
                LpSlowClkConfig::RcSlow => rc_slow_clk_frequency(clocks),
                LpSlowClkConfig::Xtal32k => xtal32k_clk_frequency(clocks),
                LpSlowClkConfig::OscSlow => osc_slow_clk_frequency(clocks),
            }
        }
        pub fn configure_crypto_clk(clocks: &mut ClockTree, new_selector: CryptoClkConfig) {
            let old_selector = clocks.crypto_clk.replace(new_selector);
            if clocks.crypto_clk_refcount > 0 {
                match new_selector {
                    CryptoClkConfig::Xtal => request_xtal_clk(clocks),
                    CryptoClkConfig::Fosc => request_rc_fast_clk(clocks),
                    CryptoClkConfig::PllF480m => request_pll_clk(clocks),
                }
                configure_crypto_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        CryptoClkConfig::Xtal => release_xtal_clk(clocks),
                        CryptoClkConfig::Fosc => release_rc_fast_clk(clocks),
                        CryptoClkConfig::PllF480m => release_pll_clk(clocks),
                    }
                }
            } else {
                configure_crypto_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn crypto_clk_config(clocks: &mut ClockTree) -> Option<CryptoClkConfig> {
            clocks.crypto_clk
        }
        pub fn request_crypto_clk(clocks: &mut ClockTree) {
            trace!("Requesting CRYPTO_CLK");
            if increment_reference_count(&mut clocks.crypto_clk_refcount) {
                trace!("Enabling CRYPTO_CLK");
                match unwrap!(clocks.crypto_clk) {
                    CryptoClkConfig::Xtal => request_xtal_clk(clocks),
                    CryptoClkConfig::Fosc => request_rc_fast_clk(clocks),
                    CryptoClkConfig::PllF480m => request_pll_clk(clocks),
                }
                enable_crypto_clk_impl(clocks, true);
            }
        }
        pub fn release_crypto_clk(clocks: &mut ClockTree) {
            trace!("Releasing CRYPTO_CLK");
            if decrement_reference_count(&mut clocks.crypto_clk_refcount) {
                trace!("Disabling CRYPTO_CLK");
                enable_crypto_clk_impl(clocks, false);
                match unwrap!(clocks.crypto_clk) {
                    CryptoClkConfig::Xtal => release_xtal_clk(clocks),
                    CryptoClkConfig::Fosc => release_rc_fast_clk(clocks),
                    CryptoClkConfig::PllF480m => release_pll_clk(clocks),
                }
            }
        }
        pub fn crypto_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.crypto_clk) {
                CryptoClkConfig::Xtal => xtal_clk_frequency(clocks),
                CryptoClkConfig::Fosc => rc_fast_clk_frequency(clocks),
                CryptoClkConfig::PllF480m => pll_clk_frequency(clocks),
            }
        }
        pub fn configure_timg_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: TimgCalibrationClockConfig,
        ) {
            let old_selector = clocks.timg_calibration_clock.replace(new_selector);
            if clocks.timg_calibration_clock_refcount > 0 {
                match new_selector {
                    TimgCalibrationClockConfig::OscSlowClk => request_osc_slow_clk(clocks),
                    TimgCalibrationClockConfig::RcSlowClk => request_rc_slow_clk(clocks),
                    TimgCalibrationClockConfig::RcFastDivClk => request_rc_fast_clk(clocks),
                    TimgCalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        TimgCalibrationClockConfig::OscSlowClk => release_osc_slow_clk(clocks),
                        TimgCalibrationClockConfig::RcSlowClk => release_rc_slow_clk(clocks),
                        TimgCalibrationClockConfig::RcFastDivClk => release_rc_fast_clk(clocks),
                        TimgCalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg_calibration_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<TimgCalibrationClockConfig> {
            clocks.timg_calibration_clock
        }
        pub fn request_timg_calibration_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG_CALIBRATION_CLOCK");
            if increment_reference_count(&mut clocks.timg_calibration_clock_refcount) {
                trace!("Enabling TIMG_CALIBRATION_CLOCK");
                match unwrap!(clocks.timg_calibration_clock) {
                    TimgCalibrationClockConfig::OscSlowClk => request_osc_slow_clk(clocks),
                    TimgCalibrationClockConfig::RcSlowClk => request_rc_slow_clk(clocks),
                    TimgCalibrationClockConfig::RcFastDivClk => request_rc_fast_clk(clocks),
                    TimgCalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg_calibration_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG_CALIBRATION_CLOCK");
            if decrement_reference_count(&mut clocks.timg_calibration_clock_refcount) {
                trace!("Disabling TIMG_CALIBRATION_CLOCK");
                enable_timg_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg_calibration_clock) {
                    TimgCalibrationClockConfig::OscSlowClk => release_osc_slow_clk(clocks),
                    TimgCalibrationClockConfig::RcSlowClk => release_rc_slow_clk(clocks),
                    TimgCalibrationClockConfig::RcFastDivClk => release_rc_fast_clk(clocks),
                    TimgCalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg_calibration_clock) {
                TimgCalibrationClockConfig::OscSlowClk => osc_slow_clk_frequency(clocks),
                TimgCalibrationClockConfig::RcSlowClk => rc_slow_clk_frequency(clocks),
                TimgCalibrationClockConfig::RcFastDivClk => rc_fast_clk_frequency(clocks),
                TimgCalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        pub fn configure_parlio_rx_clock(
            clocks: &mut ClockTree,
            new_selector: ParlioRxClockConfig,
        ) {
            let old_selector = clocks.parlio_rx_clock.replace(new_selector);
            if clocks.parlio_rx_clock_refcount > 0 {
                match new_selector {
                    ParlioRxClockConfig::XtalClk => request_xtal_clk(clocks),
                    ParlioRxClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    ParlioRxClockConfig::PllF240m => request_pll_f240m(clocks),
                }
                configure_parlio_rx_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        ParlioRxClockConfig::XtalClk => release_xtal_clk(clocks),
                        ParlioRxClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        ParlioRxClockConfig::PllF240m => release_pll_f240m(clocks),
                    }
                }
            } else {
                configure_parlio_rx_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn parlio_rx_clock_config(clocks: &mut ClockTree) -> Option<ParlioRxClockConfig> {
            clocks.parlio_rx_clock
        }
        pub fn request_parlio_rx_clock(clocks: &mut ClockTree) {
            trace!("Requesting PARLIO_RX_CLOCK");
            if increment_reference_count(&mut clocks.parlio_rx_clock_refcount) {
                trace!("Enabling PARLIO_RX_CLOCK");
                match unwrap!(clocks.parlio_rx_clock) {
                    ParlioRxClockConfig::XtalClk => request_xtal_clk(clocks),
                    ParlioRxClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    ParlioRxClockConfig::PllF240m => request_pll_f240m(clocks),
                }
                enable_parlio_rx_clock_impl(clocks, true);
            }
        }
        pub fn release_parlio_rx_clock(clocks: &mut ClockTree) {
            trace!("Releasing PARLIO_RX_CLOCK");
            if decrement_reference_count(&mut clocks.parlio_rx_clock_refcount) {
                trace!("Disabling PARLIO_RX_CLOCK");
                enable_parlio_rx_clock_impl(clocks, false);
                match unwrap!(clocks.parlio_rx_clock) {
                    ParlioRxClockConfig::XtalClk => release_xtal_clk(clocks),
                    ParlioRxClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    ParlioRxClockConfig::PllF240m => release_pll_f240m(clocks),
                }
            }
        }
        pub fn parlio_rx_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.parlio_rx_clock) {
                ParlioRxClockConfig::XtalClk => xtal_clk_frequency(clocks),
                ParlioRxClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                ParlioRxClockConfig::PllF240m => pll_f240m_frequency(clocks),
            }
        }
        pub fn configure_parlio_tx_clock(
            clocks: &mut ClockTree,
            new_selector: ParlioTxClockConfig,
        ) {
            let old_selector = clocks.parlio_tx_clock.replace(new_selector);
            if clocks.parlio_tx_clock_refcount > 0 {
                match new_selector {
                    ParlioTxClockConfig::XtalClk => request_xtal_clk(clocks),
                    ParlioTxClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    ParlioTxClockConfig::PllF240m => request_pll_f240m(clocks),
                }
                configure_parlio_tx_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        ParlioTxClockConfig::XtalClk => release_xtal_clk(clocks),
                        ParlioTxClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        ParlioTxClockConfig::PllF240m => release_pll_f240m(clocks),
                    }
                }
            } else {
                configure_parlio_tx_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn parlio_tx_clock_config(clocks: &mut ClockTree) -> Option<ParlioTxClockConfig> {
            clocks.parlio_tx_clock
        }
        pub fn request_parlio_tx_clock(clocks: &mut ClockTree) {
            trace!("Requesting PARLIO_TX_CLOCK");
            if increment_reference_count(&mut clocks.parlio_tx_clock_refcount) {
                trace!("Enabling PARLIO_TX_CLOCK");
                match unwrap!(clocks.parlio_tx_clock) {
                    ParlioTxClockConfig::XtalClk => request_xtal_clk(clocks),
                    ParlioTxClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    ParlioTxClockConfig::PllF240m => request_pll_f240m(clocks),
                }
                enable_parlio_tx_clock_impl(clocks, true);
            }
        }
        pub fn release_parlio_tx_clock(clocks: &mut ClockTree) {
            trace!("Releasing PARLIO_TX_CLOCK");
            if decrement_reference_count(&mut clocks.parlio_tx_clock_refcount) {
                trace!("Disabling PARLIO_TX_CLOCK");
                enable_parlio_tx_clock_impl(clocks, false);
                match unwrap!(clocks.parlio_tx_clock) {
                    ParlioTxClockConfig::XtalClk => release_xtal_clk(clocks),
                    ParlioTxClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    ParlioTxClockConfig::PllF240m => release_pll_f240m(clocks),
                }
            }
        }
        pub fn parlio_tx_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.parlio_tx_clock) {
                ParlioTxClockConfig::XtalClk => xtal_clk_frequency(clocks),
                ParlioTxClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                ParlioTxClockConfig::PllF240m => pll_f240m_frequency(clocks),
            }
        }
        pub fn configure_rmt_sclk(clocks: &mut ClockTree, new_selector: RmtSclkConfig) {
            let old_selector = clocks.rmt_sclk.replace(new_selector);
            if clocks.rmt_sclk_refcount > 0 {
                match new_selector {
                    RmtSclkConfig::XtalClk => request_xtal_clk(clocks),
                    RmtSclkConfig::RcFastClk => request_rc_fast_clk(clocks),
                    RmtSclkConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_rmt_sclk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RmtSclkConfig::XtalClk => release_xtal_clk(clocks),
                        RmtSclkConfig::RcFastClk => release_rc_fast_clk(clocks),
                        RmtSclkConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_rmt_sclk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn rmt_sclk_config(clocks: &mut ClockTree) -> Option<RmtSclkConfig> {
            clocks.rmt_sclk
        }
        pub fn request_rmt_sclk(clocks: &mut ClockTree) {
            trace!("Requesting RMT_SCLK");
            if increment_reference_count(&mut clocks.rmt_sclk_refcount) {
                trace!("Enabling RMT_SCLK");
                match unwrap!(clocks.rmt_sclk) {
                    RmtSclkConfig::XtalClk => request_xtal_clk(clocks),
                    RmtSclkConfig::RcFastClk => request_rc_fast_clk(clocks),
                    RmtSclkConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_rmt_sclk_impl(clocks, true);
            }
        }
        pub fn release_rmt_sclk(clocks: &mut ClockTree) {
            trace!("Releasing RMT_SCLK");
            if decrement_reference_count(&mut clocks.rmt_sclk_refcount) {
                trace!("Disabling RMT_SCLK");
                enable_rmt_sclk_impl(clocks, false);
                match unwrap!(clocks.rmt_sclk) {
                    RmtSclkConfig::XtalClk => release_xtal_clk(clocks),
                    RmtSclkConfig::RcFastClk => release_rc_fast_clk(clocks),
                    RmtSclkConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn rmt_sclk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.rmt_sclk) {
                RmtSclkConfig::XtalClk => xtal_clk_frequency(clocks),
                RmtSclkConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                RmtSclkConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_timg0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg0_function_clock.replace(new_selector);
            if clocks.timg0_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg0_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Timg0FunctionClockConfig> {
            clocks.timg0_function_clock
        }
        pub fn request_timg0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.timg0_function_clock_refcount) {
                trace!("Enabling TIMG0_FUNCTION_CLOCK");
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_timg0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_function_clock_refcount) {
                trace!("Disabling TIMG0_FUNCTION_CLOCK");
                enable_timg0_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn timg0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_function_clock) {
                Timg0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Timg0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_timg0_wdt_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0WdtClockConfig,
        ) {
            let old_selector = clocks.timg0_wdt_clock.replace(new_selector);
            if clocks.timg0_wdt_clock_refcount > 0 {
                match new_selector {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                configure_timg0_wdt_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                        Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_timg0_wdt_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg0_wdt_clock_config(clocks: &mut ClockTree) -> Option<Timg0WdtClockConfig> {
            clocks.timg0_wdt_clock
        }
        pub fn request_timg0_wdt_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_WDT_CLOCK");
            if increment_reference_count(&mut clocks.timg0_wdt_clock_refcount) {
                trace!("Enabling TIMG0_WDT_CLOCK");
                match unwrap!(clocks.timg0_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                enable_timg0_wdt_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_wdt_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_WDT_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_wdt_clock_refcount) {
                trace!("Disabling TIMG0_WDT_CLOCK");
                enable_timg0_wdt_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn timg0_wdt_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_wdt_clock) {
                Timg0WdtClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0WdtClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Timg0WdtClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg1_function_clock.replace(new_selector);
            if clocks.timg1_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg1_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Timg0FunctionClockConfig> {
            clocks.timg1_function_clock
        }
        pub fn request_timg1_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.timg1_function_clock_refcount) {
                trace!("Enabling TIMG1_FUNCTION_CLOCK");
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_timg1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_function_clock_refcount) {
                trace!("Disabling TIMG1_FUNCTION_CLOCK");
                enable_timg1_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn timg1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_function_clock) {
                Timg0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Timg0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_timg1_wdt_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0WdtClockConfig,
        ) {
            let old_selector = clocks.timg1_wdt_clock.replace(new_selector);
            if clocks.timg1_wdt_clock_refcount > 0 {
                match new_selector {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                configure_timg1_wdt_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                        Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_timg1_wdt_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg1_wdt_clock_config(clocks: &mut ClockTree) -> Option<Timg0WdtClockConfig> {
            clocks.timg1_wdt_clock
        }
        pub fn request_timg1_wdt_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_WDT_CLOCK");
            if increment_reference_count(&mut clocks.timg1_wdt_clock_refcount) {
                trace!("Enabling TIMG1_WDT_CLOCK");
                match unwrap!(clocks.timg1_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                enable_timg1_wdt_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_wdt_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_WDT_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_wdt_clock_refcount) {
                trace!("Disabling TIMG1_WDT_CLOCK");
                enable_timg1_wdt_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn timg1_wdt_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_wdt_clock) {
                Timg0WdtClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0WdtClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Timg0WdtClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_uart0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0FunctionClockConfig,
        ) {
            let old_selector = clocks.uart0_function_clock.replace(new_selector);
            if clocks.uart0_function_clock_refcount > 0 {
                match new_selector {
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                configure_uart0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                        Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_uart0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn uart0_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Uart0FunctionClockConfig> {
            clocks.uart0_function_clock
        }
        pub fn request_uart0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.uart0_function_clock_refcount) {
                trace!("Enabling UART0_FUNCTION_CLOCK");
                match unwrap!(clocks.uart0_function_clock) {
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                enable_uart0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_uart0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.uart0_function_clock_refcount) {
                trace!("Disabling UART0_FUNCTION_CLOCK");
                enable_uart0_function_clock_impl(clocks, false);
                match unwrap!(clocks.uart0_function_clock) {
                    Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn uart0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.uart0_function_clock) {
                Uart0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                Uart0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Uart0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_uart1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0FunctionClockConfig,
        ) {
            let old_selector = clocks.uart1_function_clock.replace(new_selector);
            if clocks.uart1_function_clock_refcount > 0 {
                match new_selector {
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                configure_uart1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                        Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                        Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_uart1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn uart1_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Uart0FunctionClockConfig> {
            clocks.uart1_function_clock
        }
        pub fn request_uart1_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART1_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.uart1_function_clock_refcount) {
                trace!("Enabling UART1_FUNCTION_CLOCK");
                match unwrap!(clocks.uart1_function_clock) {
                    Uart0FunctionClockConfig::Xtal => request_xtal_clk(clocks),
                    Uart0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => request_rc_fast_clk(clocks),
                }
                enable_uart1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_uart1_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART1_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.uart1_function_clock_refcount) {
                trace!("Disabling UART1_FUNCTION_CLOCK");
                enable_uart1_function_clock_impl(clocks, false);
                match unwrap!(clocks.uart1_function_clock) {
                    Uart0FunctionClockConfig::Xtal => release_xtal_clk(clocks),
                    Uart0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    Uart0FunctionClockConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn uart1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.uart1_function_clock) {
                Uart0FunctionClockConfig::Xtal => xtal_clk_frequency(clocks),
                Uart0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Uart0FunctionClockConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        /// Clock tree configuration.
        ///
        /// The fields of this struct are optional, with the following caveats:
        /// - If `XTAL_CLK` is not specified, the crystal frequency will be automatically detected
        ///   if possible.
        /// - The CPU and its upstream clock nodes will be set to a default configuration.
        /// - Other unspecified clock sources will not be useable by peripherals.
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[instability::unstable]
        pub struct ClockConfig {
            /// `XTAL_CLK` configuration.
            pub xtal_clk: Option<XtalClkConfig>,
            /// `HP_ROOT_CLK` configuration.
            pub hp_root_clk: Option<HpRootClkConfig>,
            /// `CPU_CLK` configuration.
            pub cpu_clk: Option<CpuClkConfig>,
            /// `AHB_CLK` configuration.
            pub ahb_clk: Option<AhbClkConfig>,
            /// `APB_CLK` configuration.
            pub apb_clk: Option<ApbClkConfig>,
            /// `LP_FAST_CLK` configuration.
            pub lp_fast_clk: Option<LpFastClkConfig>,
            /// `LP_SLOW_CLK` configuration.
            pub lp_slow_clk: Option<LpSlowClkConfig>,
            /// `CRYPTO_CLK` configuration.
            pub crypto_clk: Option<CryptoClkConfig>,
            /// `TIMG_CALIBRATION_CLOCK` configuration.
            pub timg_calibration_clock: Option<TimgCalibrationClockConfig>,
        }
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {
                    if let Some(config) = self.xtal_clk {
                        configure_xtal_clk(clocks, config);
                    }
                    if let Some(config) = self.hp_root_clk {
                        configure_hp_root_clk(clocks, config);
                    }
                    if let Some(config) = self.cpu_clk {
                        configure_cpu_clk(clocks, config);
                    }
                    if let Some(config) = self.ahb_clk {
                        configure_ahb_clk(clocks, config);
                    }
                    if let Some(config) = self.apb_clk {
                        configure_apb_clk(clocks, config);
                    }
                    if let Some(config) = self.lp_fast_clk {
                        configure_lp_fast_clk(clocks, config);
                    }
                    if let Some(config) = self.lp_slow_clk {
                        configure_lp_slow_clk(clocks, config);
                    }
                    if let Some(config) = self.crypto_clk {
                        configure_crypto_clk(clocks, config);
                    }
                    if let Some(config) = self.timg_calibration_clock {
                        configure_timg_calibration_clock(clocks, config);
                    }
                });
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount = unwrap!(refcount.checked_add(1), "Reference count overflow");
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount = refcount.saturating_sub(1);
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            /// AES peripheral clock signal
            Aes,
            /// DMA peripheral clock signal
            Dma,
            /// ECC peripheral clock signal
            Ecc,
            /// I2C_EXT0 peripheral clock signal
            I2cExt0,
            /// PARL_IO peripheral clock signal
            ParlIo,
            /// PCNT peripheral clock signal
            Pcnt,
            /// RMT peripheral clock signal
            Rmt,
            /// RSA peripheral clock signal
            Rsa,
            /// SHA peripheral clock signal
            Sha,
            /// SPI2 peripheral clock signal
            Spi2,
            /// SYSTIMER peripheral clock signal
            Systimer,
            /// TIMG0 peripheral clock signal
            Timg0,
            /// TIMG1 peripheral clock signal
            Timg1,
            /// UART0 peripheral clock signal
            Uart0,
            /// UART1 peripheral clock signal
            Uart1,
            /// UHCI0 peripheral clock signal
            Uhci0,
            /// USB_DEVICE peripheral clock signal
            UsbDevice,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] = &[
                Self::Systimer,
                Self::Timg0,
                Self::Uart0,
                Self::Uart1,
                Self::UsbDevice,
            ];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::Dma,
                Self::Ecc,
                Self::I2cExt0,
                Self::ParlIo,
                Self::Pcnt,
                Self::Rmt,
                Self::Rsa,
                Self::Sha,
                Self::Spi2,
                Self::Systimer,
                Self::Timg0,
                Self::Timg1,
                Self::Uart0,
                Self::Uart1,
                Self::Uhci0,
                Self::UsbDevice,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .aes_conf()
                        .modify(|_, w| w.aes_clk_en().bit(enable));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .gdma_conf()
                        .modify(|_, w| w.gdma_clk_en().bit(enable));
                }
                Peripheral::Ecc => {
                    crate::peripherals::SYSTEM::regs()
                        .ecc_conf()
                        .modify(|_, w| w.ecc_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2c0_conf()
                        .modify(|_, w| w.i2c0_clk_en().bit(enable));
                }
                Peripheral::ParlIo => {
                    crate::peripherals::SYSTEM::regs()
                        .parl_io_conf()
                        .modify(|_, w| w.parl_clk_en().bit(enable));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .pcnt_conf()
                        .modify(|_, w| w.pcnt_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .rmt_conf()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .rsa_conf()
                        .modify(|_, w| w.rsa_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .sha_conf()
                        .modify(|_, w| w.sha_clk_en().bit(enable));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .spi2_conf()
                        .modify(|_, w| w.spi2_clk_en().bit(enable));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .systimer_conf()
                        .modify(|_, w| w.systimer_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_conf()
                        .modify(|_, w| w.tg0_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_timer_clk_conf()
                        .modify(|_, w| w.tg0_timer_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_conf()
                        .modify(|_, w| w.tg1_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_timer_clk_conf()
                        .modify(|_, w| w.tg1_timer_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(0)
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(1)
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uhci_conf()
                        .modify(|_, w| w.uhci_clk_en().bit(enable));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .usb_device_conf()
                        .modify(|_, w| w.usb_device_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .aes_conf()
                        .modify(|_, w| w.aes_rst_en().bit(reset));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .gdma_conf()
                        .modify(|_, w| w.gdma_rst_en().bit(reset));
                }
                Peripheral::Ecc => {
                    crate::peripherals::SYSTEM::regs()
                        .ecc_conf()
                        .modify(|_, w| w.ecc_rst_en().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2c0_conf()
                        .modify(|_, w| w.i2c0_rst_en().bit(reset));
                }
                Peripheral::ParlIo => {
                    crate::peripherals::SYSTEM::regs()
                        .parl_io_conf()
                        .modify(|_, w| w.parl_rst_en().bit(reset));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .pcnt_conf()
                        .modify(|_, w| w.pcnt_rst_en().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .rmt_conf()
                        .modify(|_, w| w.rmt_rst_en().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .rsa_conf()
                        .modify(|_, w| w.rsa_rst_en().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .sha_conf()
                        .modify(|_, w| w.sha_rst_en().bit(reset));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .spi2_conf()
                        .modify(|_, w| w.spi2_rst_en().bit(reset));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .systimer_conf()
                        .modify(|_, w| w.systimer_rst_en().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_conf()
                        .modify(|_, w| w.tg0_rst_en().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_conf()
                        .modify(|_, w| w.tg1_rst_en().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(0)
                        .conf()
                        .modify(|_, w| w.rst_en().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(1)
                        .conf()
                        .modify(|_, w| w.rst_en().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uhci_conf()
                        .modify(|_, w| w.uhci_rst_en().bit(reset));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .usb_device_conf()
                        .modify(|_, w| w.usb_device_rst_en().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x40800000..0x40860000
    };
    (size as str, "DRAM") => {
        "393216"
    };
    ("DRAM2_UNINIT") => {
        0x0..0x4085E5A0
    };
    (size as str, "DRAM2_UNINIT") => {
        "1082516896"
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($id:literal, $instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
/// - `$id`: the index of the I2C instance
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(0, I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_i2c_master { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_i2c_master!((0, I2C0, I2cExt0, I2CEXT0_SCL,
        I2CEXT0_SDA)); _for_each_inner_i2c_master!((all(0, I2C0, I2cExt0, I2CEXT0_SCL,
        I2CEXT0_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($id:literal, $instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident,
/// $rts:ident)`
///
/// Macro fragments:
///
/// - `$id`: the index of the UART instance
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(0, UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_uart { $(($pattern) => $code;)* ($other : tt) => {}
        } _for_each_inner_uart!((0, UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner_uart!((1, UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner_uart!((all(0, UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (1,
        UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident [$($cs:ident),*] [$($sio:ident),*]
/// $($is_qspi:literal)?)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_spi_master { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_spi_master!((SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1,
        FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true));
        _for_each_inner_spi_master!((all(SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2,
        FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$sclk`, `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_spi_slave { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_spi_slave!((SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0));
        _for_each_inner_spi_slave!((all(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_peripheral { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO0 peripheral singleton"] GPIO0 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO1 peripheral singleton"]
        GPIO1 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO2 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO2 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO3 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO3 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO4 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO4 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO5 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO5 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO6 peripheral singleton"]
        GPIO6 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO7 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO7 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO8 peripheral singleton"]
        GPIO8 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO9 peripheral singleton"] GPIO9 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO10 peripheral singleton"]
        GPIO10 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO11 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO11 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO12 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO12 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO13 peripheral singleton"]
        GPIO13 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO14 peripheral singleton"] GPIO14 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO23 peripheral singleton"]
        GPIO23 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO24 peripheral singleton"] GPIO24 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO25 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO25 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO26 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO26 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO27 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO27 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO28 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO28 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "AES peripheral singleton"] AES
        <= AES(AES : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }) (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "APB_SARADC peripheral singleton"] APB_SARADC <= APB_SARADC() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "CLINT peripheral singleton"]
        CLINT <= CLINT() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "DMA peripheral singleton"] DMA <= DMA() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "DS peripheral singleton"] DS <=
        DS() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "ECC peripheral singleton"] ECC <= ECC() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "ECDSA peripheral singleton"]
        ECDSA <= ECDSA() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "EFUSE peripheral singleton"] EFUSE <= EFUSE() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "ETM peripheral singleton"] ETM
        <= SOC_ETM() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO peripheral singleton"] GPIO <= GPIO() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO_SD peripheral singleton"]
        GPIO_SD <= GPIO_EXT() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "HMAC peripheral singleton"] HMAC <= HMAC() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "HP_APM peripheral singleton"]
        HP_APM <= HP_APM() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "HP_SYS peripheral singleton"] HP_SYS <= HP_SYS() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "HUK peripheral singleton"] HUK
        <= HUK() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "I2C_ANA_MST peripheral singleton"] I2C_ANA_MST <= I2C_ANA_MST() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "I2C0 peripheral singleton"]
        I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "I2S0 peripheral singleton"] I2S0 <= I2S0(I2S0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "INTERRUPT_CORE0 peripheral singleton"] INTERRUPT_CORE0 <= INTERRUPT_CORE0()
        (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "INTPRI peripheral singleton"] INTPRI <= INTPRI() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "IO_MUX peripheral singleton"]
        IO_MUX <= IO_MUX() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "KEYMNG peripheral singleton"] KEYMNG <= KEYMNG() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LP_ANA peripheral singleton"]
        LP_ANA <= LP_ANA() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "LP_AON peripheral singleton"] LP_AON <= LP_AON() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LP_APM0 peripheral singleton"]
        LP_APM0 <= LP_APM0() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc
        = "LP_CLKRST peripheral singleton"] LP_CLKRST <= LP_CLKRST() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "LP_I2C_ANA_MST peripheral singleton"] LP_I2C_ANA_MST <= LP_I2C_ANA_MST()
        (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "LP_IO_MUX peripheral singleton"] LP_IO_MUX <= LP_IO_MUX() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LP_PERI peripheral singleton"]
        LP_PERI <= LPPERI() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc
        = "LP_TEE peripheral singleton"] LP_TEE <= LP_TEE() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LP_TIMER peripheral singleton"]
        LP_TIMER <= LP_TIMER() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "LP_UART peripheral singleton"] LP_UART <= LP_UART() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LP_WDT peripheral singleton"]
        LP_WDT <= LP_WDT() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "LPWR peripheral singleton"] LPWR <= LP_CLKRST() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "MCPWM0 peripheral singleton"]
        MCPWM0 <= MCPWM0() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "MEM_MONITOR peripheral singleton"] MEM_MONITOR <= MEM_MONITOR() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "MODEM_LPCON peripheral singleton"] MODEM_LPCON <= MODEM_LPCON() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "MODEM_SYSCON peripheral singleton"] MODEM_SYSCON <= MODEM_SYSCON() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "PARL_IO peripheral singleton"]
        PARL_IO <= PARL_IO(PARL_IO_RX : { bind_rx_interrupt, enable_rx_interrupt,
        disable_rx_interrupt }, PARL_IO_TX : { bind_tx_interrupt, enable_tx_interrupt,
        disable_tx_interrupt }) (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "PAU peripheral singleton"] PAU <= PAU() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "PCNT peripheral singleton"]
        PCNT <= PCNT() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "PCR peripheral singleton"] PCR <= PCR() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "PMU peripheral singleton"] PMU
        <= PMU() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "PVT_MONITOR peripheral singleton"] PVT_MONITOR <= PVT() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "RMT peripheral singleton"] RMT
        <= RMT() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "RNG peripheral singleton"] RNG <= RNG() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "RSA peripheral singleton"] RSA
        <= RSA(RSA : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }) (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SHA peripheral singleton"] SHA <= SHA(SHA : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SLC peripheral singleton"] SLC
        <= SLC() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SPI2 peripheral singleton"] SPI2 <= SPI2(SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SYSTEM peripheral singleton"]
        SYSTEM <= PCR() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SYSTIMER peripheral singleton"] SYSTIMER <= SYSTIMER() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "TEE peripheral singleton"] TEE
        <= TEE() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "TIMG0 peripheral singleton"] TIMG0 <= TIMG0() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "TIMG1 peripheral singleton"]
        TIMG1 <= TIMG1() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "TRACE0 peripheral singleton"] TRACE0 <= TRACE() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "UART0 peripheral singleton"]
        UART0 <= UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "UART1 peripheral singleton"] UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner_peripheral!((@ peri_type #[doc = "UHCI0 peripheral singleton"]
        UHCI0 <= UHCI0() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "USB_DEVICE peripheral singleton"] USB_DEVICE <= USB_DEVICE(USB_DEVICE : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "DMA_CH0 peripheral singleton"] DMA_CH0 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "DMA_CH1 peripheral singleton"]
        DMA_CH1 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc
        = "DMA_CH2 peripheral singleton"] DMA_CH2 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "BT peripheral singleton"] BT <=
        virtual(LP_TIMER : { bind_lp_timer_interrupt, enable_lp_timer_interrupt,
        disable_lp_timer_interrupt }, BT_MAC : { bind_mac_interrupt,
        enable_mac_interrupt, disable_mac_interrupt }) (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "FLASH peripheral singleton"]
        FLASH <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO_DEDICATED peripheral singleton"] GPIO_DEDICATED <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LP_CORE peripheral singleton"]
        LP_CORE <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc
        = "SW_INTERRUPT peripheral singleton"] SW_INTERRUPT <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "WIFI peripheral singleton"]
        WIFI <= virtual(WIFI_BB : { bind_bb_interrupt, enable_bb_interrupt,
        disable_bb_interrupt }, WIFI_MAC : { bind_mac_interrupt, enable_mac_interrupt,
        disable_mac_interrupt }, WIFI_PWR : { bind_pwr_interrupt, enable_pwr_interrupt,
        disable_pwr_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "MEM2MEM0 peripheral singleton"] MEM2MEM0 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "MEM2MEM1 peripheral singleton"]
        MEM2MEM1 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "MEM2MEM2 peripheral singleton"] MEM2MEM2 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "MEM2MEM3 peripheral singleton"]
        MEM2MEM3 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "MEM2MEM4 peripheral singleton"] MEM2MEM4 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "MEM2MEM5 peripheral singleton"]
        MEM2MEM5 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "MEM2MEM6 peripheral singleton"] MEM2MEM6 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "MEM2MEM7 peripheral singleton"]
        MEM2MEM7 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "MEM2MEM8 peripheral singleton"] MEM2MEM8 <= virtual() (unstable)));
        _for_each_inner_peripheral!((GPIO0)); _for_each_inner_peripheral!((GPIO1));
        _for_each_inner_peripheral!((GPIO2)); _for_each_inner_peripheral!((GPIO3));
        _for_each_inner_peripheral!((GPIO4)); _for_each_inner_peripheral!((GPIO5));
        _for_each_inner_peripheral!((GPIO6)); _for_each_inner_peripheral!((GPIO7));
        _for_each_inner_peripheral!((GPIO8)); _for_each_inner_peripheral!((GPIO9));
        _for_each_inner_peripheral!((GPIO10)); _for_each_inner_peripheral!((GPIO11));
        _for_each_inner_peripheral!((GPIO12)); _for_each_inner_peripheral!((GPIO13));
        _for_each_inner_peripheral!((GPIO14)); _for_each_inner_peripheral!((GPIO23));
        _for_each_inner_peripheral!((GPIO24)); _for_each_inner_peripheral!((GPIO25));
        _for_each_inner_peripheral!((GPIO26)); _for_each_inner_peripheral!((GPIO27));
        _for_each_inner_peripheral!((GPIO28));
        _for_each_inner_peripheral!((AES(unstable)));
        _for_each_inner_peripheral!((APB_SARADC(unstable)));
        _for_each_inner_peripheral!((CLINT(unstable)));
        _for_each_inner_peripheral!((DMA(unstable)));
        _for_each_inner_peripheral!((DS(unstable)));
        _for_each_inner_peripheral!((ECC(unstable)));
        _for_each_inner_peripheral!((ECDSA(unstable)));
        _for_each_inner_peripheral!((ETM(unstable)));
        _for_each_inner_peripheral!((GPIO(unstable)));
        _for_each_inner_peripheral!((GPIO_SD(unstable)));
        _for_each_inner_peripheral!((HMAC(unstable)));
        _for_each_inner_peripheral!((HP_APM(unstable)));
        _for_each_inner_peripheral!((HP_SYS(unstable)));
        _for_each_inner_peripheral!((HUK(unstable)));
        _for_each_inner_peripheral!((I2C_ANA_MST(unstable)));
        _for_each_inner_peripheral!((I2C0));
        _for_each_inner_peripheral!((I2S0(unstable)));
        _for_each_inner_peripheral!((INTERRUPT_CORE0(unstable)));
        _for_each_inner_peripheral!((INTPRI(unstable)));
        _for_each_inner_peripheral!((IO_MUX(unstable)));
        _for_each_inner_peripheral!((KEYMNG(unstable)));
        _for_each_inner_peripheral!((LP_ANA(unstable)));
        _for_each_inner_peripheral!((LP_AON(unstable)));
        _for_each_inner_peripheral!((LP_APM0(unstable)));
        _for_each_inner_peripheral!((LP_CLKRST(unstable)));
        _for_each_inner_peripheral!((LP_I2C_ANA_MST(unstable)));
        _for_each_inner_peripheral!((LP_IO_MUX(unstable)));
        _for_each_inner_peripheral!((LP_PERI(unstable)));
        _for_each_inner_peripheral!((LP_TEE(unstable)));
        _for_each_inner_peripheral!((LP_TIMER(unstable)));
        _for_each_inner_peripheral!((LP_UART(unstable)));
        _for_each_inner_peripheral!((LP_WDT(unstable)));
        _for_each_inner_peripheral!((LPWR(unstable)));
        _for_each_inner_peripheral!((MCPWM0(unstable)));
        _for_each_inner_peripheral!((MEM_MONITOR(unstable)));
        _for_each_inner_peripheral!((MODEM_LPCON(unstable)));
        _for_each_inner_peripheral!((MODEM_SYSCON(unstable)));
        _for_each_inner_peripheral!((PARL_IO(unstable)));
        _for_each_inner_peripheral!((PAU(unstable)));
        _for_each_inner_peripheral!((PCNT(unstable)));
        _for_each_inner_peripheral!((PCR(unstable)));
        _for_each_inner_peripheral!((PMU(unstable)));
        _for_each_inner_peripheral!((PVT_MONITOR(unstable)));
        _for_each_inner_peripheral!((RMT(unstable)));
        _for_each_inner_peripheral!((RNG(unstable)));
        _for_each_inner_peripheral!((RSA(unstable)));
        _for_each_inner_peripheral!((SHA(unstable)));
        _for_each_inner_peripheral!((SLC(unstable)));
        _for_each_inner_peripheral!((SPI2));
        _for_each_inner_peripheral!((SYSTEM(unstable)));
        _for_each_inner_peripheral!((SYSTIMER(unstable)));
        _for_each_inner_peripheral!((TEE(unstable)));
        _for_each_inner_peripheral!((TIMG0(unstable)));
        _for_each_inner_peripheral!((TIMG1(unstable)));
        _for_each_inner_peripheral!((TRACE0(unstable)));
        _for_each_inner_peripheral!((UART0)); _for_each_inner_peripheral!((UART1));
        _for_each_inner_peripheral!((UHCI0(unstable)));
        _for_each_inner_peripheral!((USB_DEVICE(unstable)));
        _for_each_inner_peripheral!((DMA_CH0(unstable)));
        _for_each_inner_peripheral!((DMA_CH1(unstable)));
        _for_each_inner_peripheral!((DMA_CH2(unstable)));
        _for_each_inner_peripheral!((BT(unstable)));
        _for_each_inner_peripheral!((FLASH(unstable)));
        _for_each_inner_peripheral!((GPIO_DEDICATED(unstable)));
        _for_each_inner_peripheral!((LP_CORE(unstable)));
        _for_each_inner_peripheral!((SW_INTERRUPT(unstable)));
        _for_each_inner_peripheral!((WIFI));
        _for_each_inner_peripheral!((MEM2MEM0(unstable)));
        _for_each_inner_peripheral!((MEM2MEM1(unstable)));
        _for_each_inner_peripheral!((MEM2MEM2(unstable)));
        _for_each_inner_peripheral!((MEM2MEM3(unstable)));
        _for_each_inner_peripheral!((MEM2MEM4(unstable)));
        _for_each_inner_peripheral!((MEM2MEM5(unstable)));
        _for_each_inner_peripheral!((MEM2MEM6(unstable)));
        _for_each_inner_peripheral!((MEM2MEM7(unstable)));
        _for_each_inner_peripheral!((MEM2MEM8(unstable)));
        _for_each_inner_peripheral!((MEM2MEM0, Mem2mem0, 0));
        _for_each_inner_peripheral!((SPI2, Spi2, 1)); _for_each_inner_peripheral!((UHCI0,
        Uhci0, 2)); _for_each_inner_peripheral!((I2S0, I2s0, 3));
        _for_each_inner_peripheral!((MEM2MEM1, Mem2mem1, 4));
        _for_each_inner_peripheral!((MEM2MEM2, Mem2mem2, 5));
        _for_each_inner_peripheral!((AES, Aes, 6)); _for_each_inner_peripheral!((SHA,
        Sha, 7)); _for_each_inner_peripheral!((APB_SARADC, ApbSaradc, 8));
        _for_each_inner_peripheral!((PARL_IO, ParlIo, 9));
        _for_each_inner_peripheral!((MEM2MEM3, Mem2mem3, 10));
        _for_each_inner_peripheral!((MEM2MEM4, Mem2mem4, 11));
        _for_each_inner_peripheral!((MEM2MEM5, Mem2mem5, 12));
        _for_each_inner_peripheral!((MEM2MEM6, Mem2mem6, 13));
        _for_each_inner_peripheral!((MEM2MEM7, Mem2mem7, 14));
        _for_each_inner_peripheral!((MEM2MEM8, Mem2mem8, 15));
        _for_each_inner_peripheral!((all(@ peri_type #[doc =
        "GPIO0 peripheral singleton"] GPIO0 <= virtual()), (@ peri_type #[doc =
        "GPIO1 peripheral singleton"] GPIO1 <= virtual()), (@ peri_type #[doc =
        "GPIO2 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO2 <= virtual()), (@ peri_type #[doc =
        "GPIO3 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO3 <= virtual()), (@ peri_type #[doc =
        "GPIO4 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO4 <= virtual()), (@ peri_type #[doc =
        "GPIO5 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO5 <= virtual()), (@ peri_type #[doc =
        "GPIO6 peripheral singleton"] GPIO6 <= virtual()), (@ peri_type #[doc =
        "GPIO7 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO7 <= virtual()), (@ peri_type #[doc =
        "GPIO8 peripheral singleton"] GPIO8 <= virtual()), (@ peri_type #[doc =
        "GPIO9 peripheral singleton"] GPIO9 <= virtual()), (@ peri_type #[doc =
        "GPIO10 peripheral singleton"] GPIO10 <= virtual()), (@ peri_type #[doc =
        "GPIO11 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO11 <= virtual()), (@ peri_type #[doc =
        "GPIO12 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO12 <= virtual()), (@ peri_type #[doc =
        "GPIO13 peripheral singleton"] GPIO13 <= virtual()), (@ peri_type #[doc =
        "GPIO14 peripheral singleton"] GPIO14 <= virtual()), (@ peri_type #[doc =
        "GPIO23 peripheral singleton"] GPIO23 <= virtual()), (@ peri_type #[doc =
        "GPIO24 peripheral singleton"] GPIO24 <= virtual()), (@ peri_type #[doc =
        "GPIO25 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO25 <= virtual()), (@ peri_type #[doc =
        "GPIO26 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO26 <= virtual()), (@ peri_type #[doc =
        "GPIO27 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO27 <= virtual()), (@ peri_type #[doc =
        "GPIO28 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO28 <= virtual()), (@ peri_type #[doc =
        "AES peripheral singleton"] AES <= AES(AES : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type #[doc
        = "APB_SARADC peripheral singleton"] APB_SARADC <= APB_SARADC() (unstable)), (@
        peri_type #[doc = "CLINT peripheral singleton"] CLINT <= CLINT() (unstable)), (@
        peri_type #[doc = "DMA peripheral singleton"] DMA <= DMA() (unstable)), (@
        peri_type #[doc = "DS peripheral singleton"] DS <= DS() (unstable)), (@ peri_type
        #[doc = "ECC peripheral singleton"] ECC <= ECC() (unstable)), (@ peri_type #[doc
        = "ECDSA peripheral singleton"] ECDSA <= ECDSA() (unstable)), (@ peri_type #[doc
        = "EFUSE peripheral singleton"] EFUSE <= EFUSE() (unstable)), (@ peri_type #[doc
        = "ETM peripheral singleton"] ETM <= SOC_ETM() (unstable)), (@ peri_type #[doc =
        "GPIO peripheral singleton"] GPIO <= GPIO() (unstable)), (@ peri_type #[doc =
        "GPIO_SD peripheral singleton"] GPIO_SD <= GPIO_EXT() (unstable)), (@ peri_type
        #[doc = "HMAC peripheral singleton"] HMAC <= HMAC() (unstable)), (@ peri_type
        #[doc = "HP_APM peripheral singleton"] HP_APM <= HP_APM() (unstable)), (@
        peri_type #[doc = "HP_SYS peripheral singleton"] HP_SYS <= HP_SYS() (unstable)),
        (@ peri_type #[doc = "HUK peripheral singleton"] HUK <= HUK() (unstable)), (@
        peri_type #[doc = "I2C_ANA_MST peripheral singleton"] I2C_ANA_MST <=
        I2C_ANA_MST() (unstable)), (@ peri_type #[doc = "I2C0 peripheral singleton"] I2C0
        <= I2C0(I2C_EXT0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type #[doc = "I2S0 peripheral singleton"]
        I2S0 <= I2S0(I2S0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type #[doc =
        "INTERRUPT_CORE0 peripheral singleton"] INTERRUPT_CORE0 <= INTERRUPT_CORE0()
        (unstable)), (@ peri_type #[doc = "INTPRI peripheral singleton"] INTPRI <=
        INTPRI() (unstable)), (@ peri_type #[doc = "IO_MUX peripheral singleton"] IO_MUX
        <= IO_MUX() (unstable)), (@ peri_type #[doc = "KEYMNG peripheral singleton"]
        KEYMNG <= KEYMNG() (unstable)), (@ peri_type #[doc =
        "LP_ANA peripheral singleton"] LP_ANA <= LP_ANA() (unstable)), (@ peri_type #[doc
        = "LP_AON peripheral singleton"] LP_AON <= LP_AON() (unstable)), (@ peri_type
        #[doc = "LP_APM0 peripheral singleton"] LP_APM0 <= LP_APM0() (unstable)), (@
        peri_type #[doc = "LP_CLKRST peripheral singleton"] LP_CLKRST <= LP_CLKRST()
        (unstable)), (@ peri_type #[doc = "LP_I2C_ANA_MST peripheral singleton"]
        LP_I2C_ANA_MST <= LP_I2C_ANA_MST() (unstable)), (@ peri_type #[doc =
        "LP_IO_MUX peripheral singleton"] LP_IO_MUX <= LP_IO_MUX() (unstable)), (@
        peri_type #[doc = "LP_PERI peripheral singleton"] LP_PERI <= LPPERI()
        (unstable)), (@ peri_type #[doc = "LP_TEE peripheral singleton"] LP_TEE <=
        LP_TEE() (unstable)), (@ peri_type #[doc = "LP_TIMER peripheral singleton"]
        LP_TIMER <= LP_TIMER() (unstable)), (@ peri_type #[doc =
        "LP_UART peripheral singleton"] LP_UART <= LP_UART() (unstable)), (@ peri_type
        #[doc = "LP_WDT peripheral singleton"] LP_WDT <= LP_WDT() (unstable)), (@
        peri_type #[doc = "LPWR peripheral singleton"] LPWR <= LP_CLKRST() (unstable)),
        (@ peri_type #[doc = "MCPWM0 peripheral singleton"] MCPWM0 <= MCPWM0()
        (unstable)), (@ peri_type #[doc = "MEM_MONITOR peripheral singleton"] MEM_MONITOR
        <= MEM_MONITOR() (unstable)), (@ peri_type #[doc =
        "MODEM_LPCON peripheral singleton"] MODEM_LPCON <= MODEM_LPCON() (unstable)), (@
        peri_type #[doc = "MODEM_SYSCON peripheral singleton"] MODEM_SYSCON <=
        MODEM_SYSCON() (unstable)), (@ peri_type #[doc = "PARL_IO peripheral singleton"]
        PARL_IO <= PARL_IO(PARL_IO_RX : { bind_rx_interrupt, enable_rx_interrupt,
        disable_rx_interrupt }, PARL_IO_TX : { bind_tx_interrupt, enable_tx_interrupt,
        disable_tx_interrupt }) (unstable)), (@ peri_type #[doc =
        "PAU peripheral singleton"] PAU <= PAU() (unstable)), (@ peri_type #[doc =
        "PCNT peripheral singleton"] PCNT <= PCNT() (unstable)), (@ peri_type #[doc =
        "PCR peripheral singleton"] PCR <= PCR() (unstable)), (@ peri_type #[doc =
        "PMU peripheral singleton"] PMU <= PMU() (unstable)), (@ peri_type #[doc =
        "PVT_MONITOR peripheral singleton"] PVT_MONITOR <= PVT() (unstable)), (@
        peri_type #[doc = "RMT peripheral singleton"] RMT <= RMT() (unstable)), (@
        peri_type #[doc = "RNG peripheral singleton"] RNG <= RNG() (unstable)), (@
        peri_type #[doc = "RSA peripheral singleton"] RSA <= RSA(RSA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "SHA peripheral singleton"] SHA <= SHA(SHA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "SLC peripheral singleton"] SLC <= SLC()
        (unstable)), (@ peri_type #[doc = "SPI2 peripheral singleton"] SPI2 <= SPI2(SPI2
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type #[doc = "SYSTEM peripheral singleton"] SYSTEM <= PCR() (unstable)), (@
        peri_type #[doc = "SYSTIMER peripheral singleton"] SYSTIMER <= SYSTIMER()
        (unstable)), (@ peri_type #[doc = "TEE peripheral singleton"] TEE <= TEE()
        (unstable)), (@ peri_type #[doc = "TIMG0 peripheral singleton"] TIMG0 <= TIMG0()
        (unstable)), (@ peri_type #[doc = "TIMG1 peripheral singleton"] TIMG1 <= TIMG1()
        (unstable)), (@ peri_type #[doc = "TRACE0 peripheral singleton"] TRACE0 <=
        TRACE() (unstable)), (@ peri_type #[doc = "UART0 peripheral singleton"] UART0 <=
        UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type #[doc = "UART1 peripheral singleton"]
        UART1 <= UART1(UART1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type #[doc = "UHCI0 peripheral singleton"]
        UHCI0 <= UHCI0() (unstable)), (@ peri_type #[doc =
        "USB_DEVICE peripheral singleton"] USB_DEVICE <= USB_DEVICE(USB_DEVICE : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "DMA_CH0 peripheral singleton"] DMA_CH0 <=
        virtual() (unstable)), (@ peri_type #[doc = "DMA_CH1 peripheral singleton"]
        DMA_CH1 <= virtual() (unstable)), (@ peri_type #[doc =
        "DMA_CH2 peripheral singleton"] DMA_CH2 <= virtual() (unstable)), (@ peri_type
        #[doc = "BT peripheral singleton"] BT <= virtual(LP_TIMER : {
        bind_lp_timer_interrupt, enable_lp_timer_interrupt, disable_lp_timer_interrupt },
        BT_MAC : { bind_mac_interrupt, enable_mac_interrupt, disable_mac_interrupt })
        (unstable)), (@ peri_type #[doc = "FLASH peripheral singleton"] FLASH <=
        virtual() (unstable)), (@ peri_type #[doc =
        "GPIO_DEDICATED peripheral singleton"] GPIO_DEDICATED <= virtual() (unstable)),
        (@ peri_type #[doc = "LP_CORE peripheral singleton"] LP_CORE <= virtual()
        (unstable)), (@ peri_type #[doc = "SW_INTERRUPT peripheral singleton"]
        SW_INTERRUPT <= virtual() (unstable)), (@ peri_type #[doc =
        "WIFI peripheral singleton"] WIFI <= virtual(WIFI_BB : { bind_bb_interrupt,
        enable_bb_interrupt, disable_bb_interrupt }, WIFI_MAC : { bind_mac_interrupt,
        enable_mac_interrupt, disable_mac_interrupt }, WIFI_PWR : { bind_pwr_interrupt,
        enable_pwr_interrupt, disable_pwr_interrupt })), (@ peri_type #[doc =
        "MEM2MEM0 peripheral singleton"] MEM2MEM0 <= virtual() (unstable)), (@ peri_type
        #[doc = "MEM2MEM1 peripheral singleton"] MEM2MEM1 <= virtual() (unstable)), (@
        peri_type #[doc = "MEM2MEM2 peripheral singleton"] MEM2MEM2 <= virtual()
        (unstable)), (@ peri_type #[doc = "MEM2MEM3 peripheral singleton"] MEM2MEM3 <=
        virtual() (unstable)), (@ peri_type #[doc = "MEM2MEM4 peripheral singleton"]
        MEM2MEM4 <= virtual() (unstable)), (@ peri_type #[doc =
        "MEM2MEM5 peripheral singleton"] MEM2MEM5 <= virtual() (unstable)), (@ peri_type
        #[doc = "MEM2MEM6 peripheral singleton"] MEM2MEM6 <= virtual() (unstable)), (@
        peri_type #[doc = "MEM2MEM7 peripheral singleton"] MEM2MEM7 <= virtual()
        (unstable)), (@ peri_type #[doc = "MEM2MEM8 peripheral singleton"] MEM2MEM8 <=
        virtual() (unstable)))); _for_each_inner_peripheral!((singletons(GPIO0), (GPIO1),
        (GPIO2), (GPIO3), (GPIO4), (GPIO5), (GPIO6), (GPIO7), (GPIO8), (GPIO9), (GPIO10),
        (GPIO11), (GPIO12), (GPIO13), (GPIO14), (GPIO23), (GPIO24), (GPIO25), (GPIO26),
        (GPIO27), (GPIO28), (AES(unstable)), (APB_SARADC(unstable)), (CLINT(unstable)),
        (DMA(unstable)), (DS(unstable)), (ECC(unstable)), (ECDSA(unstable)),
        (ETM(unstable)), (GPIO(unstable)), (GPIO_SD(unstable)), (HMAC(unstable)),
        (HP_APM(unstable)), (HP_SYS(unstable)), (HUK(unstable)), (I2C_ANA_MST(unstable)),
        (I2C0), (I2S0(unstable)), (INTERRUPT_CORE0(unstable)), (INTPRI(unstable)),
        (IO_MUX(unstable)), (KEYMNG(unstable)), (LP_ANA(unstable)), (LP_AON(unstable)),
        (LP_APM0(unstable)), (LP_CLKRST(unstable)), (LP_I2C_ANA_MST(unstable)),
        (LP_IO_MUX(unstable)), (LP_PERI(unstable)), (LP_TEE(unstable)),
        (LP_TIMER(unstable)), (LP_UART(unstable)), (LP_WDT(unstable)), (LPWR(unstable)),
        (MCPWM0(unstable)), (MEM_MONITOR(unstable)), (MODEM_LPCON(unstable)),
        (MODEM_SYSCON(unstable)), (PARL_IO(unstable)), (PAU(unstable)), (PCNT(unstable)),
        (PCR(unstable)), (PMU(unstable)), (PVT_MONITOR(unstable)), (RMT(unstable)),
        (RNG(unstable)), (RSA(unstable)), (SHA(unstable)), (SLC(unstable)), (SPI2),
        (SYSTEM(unstable)), (SYSTIMER(unstable)), (TEE(unstable)), (TIMG0(unstable)),
        (TIMG1(unstable)), (TRACE0(unstable)), (UART0), (UART1), (UHCI0(unstable)),
        (USB_DEVICE(unstable)), (DMA_CH0(unstable)), (DMA_CH1(unstable)),
        (DMA_CH2(unstable)), (BT(unstable)), (FLASH(unstable)),
        (GPIO_DEDICATED(unstable)), (LP_CORE(unstable)), (SW_INTERRUPT(unstable)),
        (WIFI), (MEM2MEM0(unstable)), (MEM2MEM1(unstable)), (MEM2MEM2(unstable)),
        (MEM2MEM3(unstable)), (MEM2MEM4(unstable)), (MEM2MEM5(unstable)),
        (MEM2MEM6(unstable)), (MEM2MEM7(unstable)), (MEM2MEM8(unstable))));
        _for_each_inner_peripheral!((dma_eligible(MEM2MEM0, Mem2mem0, 0), (SPI2, Spi2,
        1), (UHCI0, Uhci0, 2), (I2S0, I2s0, 3), (MEM2MEM1, Mem2mem1, 4), (MEM2MEM2,
        Mem2mem2, 5), (AES, Aes, 6), (SHA, Sha, 7), (APB_SARADC, ApbSaradc, 8), (PARL_IO,
        ParlIo, 9), (MEM2MEM3, Mem2mem3, 10), (MEM2MEM4, Mem2mem4, 11), (MEM2MEM5,
        Mem2mem5, 12), (MEM2MEM6, Mem2mem6, 13), (MEM2MEM7, Mem2mem7, 14), (MEM2MEM8,
        Mem2mem8, 15)));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_gpio { $(($pattern) => $code;)* ($other : tt) => {}
        } _for_each_inner_gpio!((0, GPIO0() () ([Input] [Output])));
        _for_each_inner_gpio!((1, GPIO1() () ([Input] [Output])));
        _for_each_inner_gpio!((2, GPIO2(_0 => MTMS _2 => FSPIQ) (_2 => FSPIQ) ([Input]
        [Output]))); _for_each_inner_gpio!((3, GPIO3(_0 => MTDI) () ([Input] [Output])));
        _for_each_inner_gpio!((4, GPIO4(_0 => MTCK _2 => FSPIHD) (_2 => FSPIHD) ([Input]
        [Output]))); _for_each_inner_gpio!((5, GPIO5(_0 => MTDO _2 => FSPIWP) (_2 =>
        FSPIWP) ([Input] [Output]))); _for_each_inner_gpio!((6, GPIO6(_2 => FSPICLK) (_2
        => FSPICLK) ([Input] [Output]))); _for_each_inner_gpio!((7, GPIO7(_0 =>
        SDIO_DATA1 _2 => FSPID) (_2 => FSPID) ([Input] [Output])));
        _for_each_inner_gpio!((8, GPIO8(_0 => SDIO_DATA0) () ([Input] [Output])));
        _for_each_inner_gpio!((9, GPIO9(_0 => SDIO_CLK) () ([Input] [Output])));
        _for_each_inner_gpio!((10, GPIO10(_0 => SDIO_CMD _2 => FSPICS0) (_2 => FSPICS0)
        ([Input] [Output]))); _for_each_inner_gpio!((11, GPIO11() (_0 => U0TXD) ([Input]
        [Output]))); _for_each_inner_gpio!((12, GPIO12(_0 => U0RXD) () ([Input]
        [Output]))); _for_each_inner_gpio!((13, GPIO13(_0 => SDIO_DATA3) () ([Input]
        [Output]))); _for_each_inner_gpio!((14, GPIO14(_0 => SDIO_DATA2) () ([Input]
        [Output]))); _for_each_inner_gpio!((23, GPIO23() () ([Input] [Output])));
        _for_each_inner_gpio!((24, GPIO24() () ([Input] [Output])));
        _for_each_inner_gpio!((25, GPIO25() () ([Input] [Output])));
        _for_each_inner_gpio!((26, GPIO26() () ([Input] [Output])));
        _for_each_inner_gpio!((27, GPIO27() () ([Input] [Output])));
        _for_each_inner_gpio!((28, GPIO28() () ([Input] [Output])));
        _for_each_inner_gpio!((all(0, GPIO0() () ([Input] [Output])), (1, GPIO1() ()
        ([Input] [Output])), (2, GPIO2(_0 => MTMS _2 => FSPIQ) (_2 => FSPIQ) ([Input]
        [Output])), (3, GPIO3(_0 => MTDI) () ([Input] [Output])), (4, GPIO4(_0 => MTCK _2
        => FSPIHD) (_2 => FSPIHD) ([Input] [Output])), (5, GPIO5(_0 => MTDO _2 => FSPIWP)
        (_2 => FSPIWP) ([Input] [Output])), (6, GPIO6(_2 => FSPICLK) (_2 => FSPICLK)
        ([Input] [Output])), (7, GPIO7(_0 => SDIO_DATA1 _2 => FSPID) (_2 => FSPID)
        ([Input] [Output])), (8, GPIO8(_0 => SDIO_DATA0) () ([Input] [Output])), (9,
        GPIO9(_0 => SDIO_CLK) () ([Input] [Output])), (10, GPIO10(_0 => SDIO_CMD _2 =>
        FSPICS0) (_2 => FSPICS0) ([Input] [Output])), (11, GPIO11() (_0 => U0TXD)
        ([Input] [Output])), (12, GPIO12(_0 => U0RXD) () ([Input] [Output])), (13,
        GPIO13(_0 => SDIO_DATA3) () ([Input] [Output])), (14, GPIO14(_0 => SDIO_DATA2) ()
        ([Input] [Output])), (23, GPIO23() () ([Input] [Output])), (24, GPIO24() ()
        ([Input] [Output])), (25, GPIO25() () ([Input] [Output])), (26, GPIO26() ()
        ([Input] [Output])), (27, GPIO27() () ([Input] [Output])), (28, GPIO28() ()
        ([Input] [Output]))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_analog_function { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_analog_function!((XTAL_32K_P, GPIO0));
        _for_each_inner_analog_function!((XTAL_32K_N, GPIO1));
        _for_each_inner_analog_function!((ADC1_CH0, GPIO1));
        _for_each_inner_analog_function!((ADC1_CH1, GPIO2));
        _for_each_inner_analog_function!((ADC1_CH2, GPIO3));
        _for_each_inner_analog_function!((ADC1_CH3, GPIO4));
        _for_each_inner_analog_function!((ADC1_CH4, GPIO5));
        _for_each_inner_analog_function!((ADC1_CH5, GPIO6));
        _for_each_inner_analog_function!((ZCD0, GPIO8));
        _for_each_inner_analog_function!((ZCD1, GPIO9));
        _for_each_inner_analog_function!((USB_DM, GPIO13));
        _for_each_inner_analog_function!((USB_DP, GPIO14));
        _for_each_inner_analog_function!(((ADC1_CH0, ADCn_CHm, 1, 0), GPIO1));
        _for_each_inner_analog_function!(((ADC1_CH1, ADCn_CHm, 1, 1), GPIO2));
        _for_each_inner_analog_function!(((ADC1_CH2, ADCn_CHm, 1, 2), GPIO3));
        _for_each_inner_analog_function!(((ADC1_CH3, ADCn_CHm, 1, 3), GPIO4));
        _for_each_inner_analog_function!(((ADC1_CH4, ADCn_CHm, 1, 4), GPIO5));
        _for_each_inner_analog_function!(((ADC1_CH5, ADCn_CHm, 1, 5), GPIO6));
        _for_each_inner_analog_function!(((ZCD0, ZCDn, 0), GPIO8));
        _for_each_inner_analog_function!(((ZCD1, ZCDn, 1), GPIO9));
        _for_each_inner_analog_function!((all(XTAL_32K_P, GPIO0), (XTAL_32K_N, GPIO1),
        (ADC1_CH0, GPIO1), (ADC1_CH1, GPIO2), (ADC1_CH2, GPIO3), (ADC1_CH3, GPIO4),
        (ADC1_CH4, GPIO5), (ADC1_CH5, GPIO6), (ZCD0, GPIO8), (ZCD1, GPIO9), (USB_DM,
        GPIO13), (USB_DP, GPIO14)));
        _for_each_inner_analog_function!((all_expanded((ADC1_CH0, ADCn_CHm, 1, 0),
        GPIO1), ((ADC1_CH1, ADCn_CHm, 1, 1), GPIO2), ((ADC1_CH2, ADCn_CHm, 1, 2), GPIO3),
        ((ADC1_CH3, ADCn_CHm, 1, 3), GPIO4), ((ADC1_CH4, ADCn_CHm, 1, 4), GPIO5),
        ((ADC1_CH5, ADCn_CHm, 1, 5), GPIO6), ((ZCD0, ZCDn, 0), GPIO8), ((ZCD1, ZCDn, 1),
        GPIO9)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_lp_function { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_lp_function!((LP_UART_DTRN, GPIO0));
        _for_each_inner_lp_function!((LP_GPIO0, GPIO0));
        _for_each_inner_lp_function!((LP_UART_DSRN, GPIO1));
        _for_each_inner_lp_function!((LP_GPIO1, GPIO1));
        _for_each_inner_lp_function!((LP_UART_RTSN, GPIO2));
        _for_each_inner_lp_function!((LP_GPIO2, GPIO2));
        _for_each_inner_lp_function!((LP_I2C_SDA, GPIO2));
        _for_each_inner_lp_function!((LP_UART_CTSN, GPIO3));
        _for_each_inner_lp_function!((LP_GPIO3, GPIO3));
        _for_each_inner_lp_function!((LP_I2C_SCL, GPIO3));
        _for_each_inner_lp_function!((LP_UART_RXD_PAD, GPIO4));
        _for_each_inner_lp_function!((LP_GPIO4, GPIO4));
        _for_each_inner_lp_function!((LP_UART_TXD_PAD, GPIO5));
        _for_each_inner_lp_function!((LP_GPIO5, GPIO5));
        _for_each_inner_lp_function!((LP_GPIO6, GPIO6));
        _for_each_inner_lp_function!(((LP_GPIO0, LP_GPIOn, 0), GPIO0));
        _for_each_inner_lp_function!(((LP_GPIO1, LP_GPIOn, 1), GPIO1));
        _for_each_inner_lp_function!(((LP_GPIO2, LP_GPIOn, 2), GPIO2));
        _for_each_inner_lp_function!(((LP_GPIO3, LP_GPIOn, 3), GPIO3));
        _for_each_inner_lp_function!(((LP_GPIO4, LP_GPIOn, 4), GPIO4));
        _for_each_inner_lp_function!(((LP_GPIO5, LP_GPIOn, 5), GPIO5));
        _for_each_inner_lp_function!(((LP_GPIO6, LP_GPIOn, 6), GPIO6));
        _for_each_inner_lp_function!((all(LP_UART_DTRN, GPIO0), (LP_GPIO0, GPIO0),
        (LP_UART_DSRN, GPIO1), (LP_GPIO1, GPIO1), (LP_UART_RTSN, GPIO2), (LP_GPIO2,
        GPIO2), (LP_I2C_SDA, GPIO2), (LP_UART_CTSN, GPIO3), (LP_GPIO3, GPIO3),
        (LP_I2C_SCL, GPIO3), (LP_UART_RXD_PAD, GPIO4), (LP_GPIO4, GPIO4),
        (LP_UART_TXD_PAD, GPIO5), (LP_GPIO5, GPIO5), (LP_GPIO6, GPIO6)));
        _for_each_inner_lp_function!((all_expanded((LP_GPIO0, LP_GPIOn, 0), GPIO0),
        ((LP_GPIO1, LP_GPIOn, 1), GPIO1), ((LP_GPIO2, LP_GPIOn, 2), GPIO2), ((LP_GPIO3,
        LP_GPIOn, 3), GPIO3), ((LP_GPIO4, LP_GPIOn, 4), GPIO4), ((LP_GPIO5, LP_GPIOn, 5),
        GPIO5), ((LP_GPIO6, LP_GPIOn, 6), GPIO6)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            U0RXD               = 6,
            U0CTS               = 7,
            U0DSR               = 8,
            U1RXD               = 9,
            U1CTS               = 10,
            U1DSR               = 11,
            I2S_MCLK            = 12,
            I2SO_BCK            = 13,
            I2SO_WS             = 14,
            I2SI_SD             = 15,
            I2SI_BCK            = 16,
            I2SI_WS             = 17,
            CPU_GPIO_0          = 27,
            CPU_GPIO_1          = 28,
            CPU_GPIO_2          = 29,
            CPU_GPIO_3          = 30,
            CPU_GPIO_4          = 31,
            CPU_GPIO_5          = 32,
            CPU_GPIO_6          = 33,
            CPU_GPIO_7          = 34,
            USB_JTAG_TDO_BRIDGE = 35,
            I2CEXT0_SCL         = 46,
            I2CEXT0_SDA         = 47,
            PARL_RX_DATA0       = 48,
            PARL_RX_DATA1       = 49,
            PARL_RX_DATA2       = 50,
            PARL_RX_DATA3       = 51,
            PARL_RX_DATA4       = 52,
            PARL_RX_DATA5       = 53,
            PARL_RX_DATA6       = 54,
            PARL_RX_DATA7       = 55,
            FSPICLK             = 56,
            FSPIQ               = 57,
            FSPID               = 58,
            FSPIHD              = 59,
            FSPIWP              = 60,
            FSPICS0             = 61,
            PARL_RX_CLK         = 62,
            PARL_TX_CLK         = 63,
            RMT_SIG_0           = 64,
            RMT_SIG_1           = 65,
            TWAI0_RX            = 66,
            TWAI1_RX            = 70,
            PCNT0_RST           = 76,
            PCNT1_RST           = 77,
            PCNT2_RST           = 78,
            PCNT3_RST           = 79,
            PWM0_SYNC0          = 80,
            PWM0_SYNC1          = 81,
            PWM0_SYNC2          = 82,
            PWM0_F0             = 83,
            PWM0_F1             = 84,
            PWM0_F2             = 85,
            PWM0_CAP0           = 86,
            PWM0_CAP1           = 87,
            PWM0_CAP2           = 88,
            SIG_IN_FUNC97       = 97,
            SIG_IN_FUNC98       = 98,
            SIG_IN_FUNC99       = 99,
            SIG_IN_FUNC100      = 100,
            PCNT0_SIG_CH0       = 101,
            PCNT0_SIG_CH1       = 102,
            PCNT0_CTRL_CH0      = 103,
            PCNT0_CTRL_CH1      = 104,
            PCNT1_SIG_CH0       = 105,
            PCNT1_SIG_CH1       = 106,
            PCNT1_CTRL_CH0      = 107,
            PCNT1_CTRL_CH1      = 108,
            PCNT2_SIG_CH0       = 109,
            PCNT2_SIG_CH1       = 110,
            PCNT2_CTRL_CH0      = 111,
            PCNT2_CTRL_CH1      = 112,
            PCNT3_SIG_CH0       = 113,
            PCNT3_SIG_CH1       = 114,
            PCNT3_CTRL_CH0      = 115,
            PCNT3_CTRL_CH1      = 116,
            SDIO_CLK,
            SDIO_CMD,
            SDIO_DATA0,
            SDIO_DATA1,
            SDIO_DATA2,
            SDIO_DATA3,
            MTDI,
            MTDO,
            MTCK,
            MTMS,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            LEDC_LS_SIG0     = 0,
            LEDC_LS_SIG1     = 1,
            LEDC_LS_SIG2     = 2,
            LEDC_LS_SIG3     = 3,
            LEDC_LS_SIG4     = 4,
            LEDC_LS_SIG5     = 5,
            U0TXD            = 6,
            U0RTS            = 7,
            U0DTR            = 8,
            U1TXD            = 9,
            U1RTS            = 10,
            U1DTR            = 11,
            I2S_MCLK         = 12,
            I2SO_BCK         = 13,
            I2SO_WS          = 14,
            I2SO_SD          = 15,
            I2SI_BCK         = 16,
            I2SI_WS          = 17,
            I2SO_SD1         = 18,
            CPU_GPIO_0       = 27,
            CPU_GPIO_1       = 28,
            CPU_GPIO_2       = 29,
            CPU_GPIO_3       = 30,
            CPU_GPIO_4       = 31,
            CPU_GPIO_5       = 32,
            CPU_GPIO_6       = 33,
            CPU_GPIO_7       = 34,
            I2CEXT0_SCL      = 46,
            I2CEXT0_SDA      = 47,
            PARL_TX_DATA0    = 48,
            PARL_TX_DATA1    = 49,
            PARL_TX_DATA2    = 50,
            PARL_TX_DATA3    = 51,
            PARL_TX_DATA4    = 52,
            PARL_TX_DATA5    = 53,
            PARL_TX_DATA6    = 54,
            PARL_TX_DATA7    = 55,
            FSPICLK          = 56,
            FSPIQ            = 57,
            FSPID            = 58,
            FSPIHD           = 59,
            FSPIWP           = 60,
            FSPICS0          = 61,
            PARL_RX_CLK      = 62,
            PARL_TX_CLK      = 63,
            RMT_SIG_0        = 64,
            RMT_SIG_1        = 65,
            TWAI0_TX         = 66,
            TWAI0_BUS_OFF_ON = 67,
            TWAI0_CLKOUT     = 68,
            TWAI0_STANDBY    = 69,
            TWAI1_TX         = 70,
            TWAI1_BUS_OFF_ON = 71,
            TWAI1_CLKOUT     = 72,
            TWAI1_STANDBY    = 73,
            GPIO_SD0         = 76,
            GPIO_SD1         = 77,
            GPIO_SD2         = 78,
            GPIO_SD3         = 79,
            PWM0_0A          = 80,
            PWM0_0B          = 81,
            PWM0_1A          = 82,
            PWM0_1B          = 83,
            PWM0_2A          = 84,
            PWM0_2B          = 85,
            PARL_TX_CS       = 86,
            SIG_IN_FUNC97    = 97,
            SIG_IN_FUNC98    = 98,
            SIG_IN_FUNC99    = 99,
            SIG_IN_FUNC100   = 100,
            FSPICS1          = 101,
            FSPICS2          = 102,
            FSPICS3          = 103,
            FSPICS4          = 104,
            FSPICS5          = 105,
            GPIO             = 256,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO {
            crate::peripherals::IO_MUX::regs().gpio(gpio_num as usize)
        }
    };
}
