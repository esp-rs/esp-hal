// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32s3"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32s3"
    };
    ("arch") => {
        "xtensa"
    };
    ("cores") => {
        2
    };
    ("cores", str) => {
        stringify!(2)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_en.pdf"
    };
    ("soc.cpu_has_csr_pc") => {
        false
    };
    ("soc.cpu_has_prv_mode") => {
        false
    };
    ("soc.rc_fast_clk_default") => {
        17500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(17500000)
    };
    ("soc.rc_slow_clock") => {
        136000
    };
    ("soc.rc_slow_clock", str) => {
        stringify!(136000)
    };
    ("soc.xtal_frequency") => {
        40
    };
    ("soc.xtal_frequency", str) => {
        stringify!(40)
    };
    ("aes.dma") => {
        true
    };
    ("aes.has_split_text_registers") => {
        true
    };
    ("aes.endianness_configurable") => {
        false
    };
    ("assist_debug.has_sp_monitor") => {
        false
    };
    ("assist_debug.has_region_monitor") => {
        true
    };
    ("gpio.has_bank_1") => {
        true
    };
    ("gpio.gpio_function") => {
        1
    };
    ("gpio.gpio_function", str) => {
        stringify!(1)
    };
    ("gpio.constant_0_input") => {
        60
    };
    ("gpio.constant_0_input", str) => {
        stringify!(60)
    };
    ("gpio.constant_1_input") => {
        56
    };
    ("gpio.constant_1_input", str) => {
        stringify!(56)
    };
    ("gpio.remap_iomux_pin_registers") => {
        false
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        255
    };
    ("gpio.input_signal_max", str) => {
        stringify!(255)
    };
    ("gpio.output_signal_max") => {
        256
    };
    ("gpio.output_signal_max", str) => {
        stringify!(256)
    };
    ("i2c_master.has_fsm_timeouts") => {
        true
    };
    ("i2c_master.has_hw_bus_clear") => {
        false
    };
    ("i2c_master.has_bus_timeout_enable") => {
        true
    };
    ("i2c_master.separate_filter_config_registers") => {
        false
    };
    ("i2c_master.can_estimate_nack_reason") => {
        true
    };
    ("i2c_master.has_conf_update") => {
        true
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        false
    };
    ("i2c_master.has_arbitration_en") => {
        true
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        true
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        true
    };
    ("i2c_master.max_bus_timeout") => {
        31
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(31)
    };
    ("i2c_master.ll_intr_mask") => {
        262143
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(262143)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("interrupts.status_registers") => {
        4
    };
    ("interrupts.status_registers", str) => {
        stringify!(4)
    };
    ("rmt.ram_start") => {
        1610704896
    };
    ("rmt.ram_start", str) => {
        stringify!(1610704896)
    };
    ("rmt.channel_ram_size") => {
        48
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(48)
    };
    ("rmt.has_tx_immediate_stop") => {
        true
    };
    ("rmt.has_tx_loop_count") => {
        true
    };
    ("rmt.has_tx_loop_auto_stop") => {
        true
    };
    ("rmt.has_tx_carrier_data_only") => {
        true
    };
    ("rmt.has_tx_sync") => {
        true
    };
    ("rmt.has_rx_wrap") => {
        true
    };
    ("rmt.has_rx_demodulation") => {
        true
    };
    ("rmt.has_dma") => {
        true
    };
    ("rmt.has_per_channel_clock") => {
        false
    };
    ("rng.apb_cycle_wait_num") => {
        16
    };
    ("rng.apb_cycle_wait_num", str) => {
        stringify!(16)
    };
    ("rsa.size_increment") => {
        32
    };
    ("rsa.size_increment", str) => {
        stringify!(32)
    };
    ("rsa.memory_size_bytes") => {
        512
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(512)
    };
    ("sha.dma") => {
        true
    };
    ("spi_master.has_octal") => {
        true
    };
    ("timergroup.timg_has_timer1") => {
        true
    };
    ("timergroup.timg_has_divcnt_rst") => {
        false
    };
    ("timergroup.default_clock_source") => {
        0
    };
    ("timergroup.default_clock_source", str) => {
        stringify!(0)
    };
    ("uart.ram_size") => {
        128
    };
    ("uart.ram_size", str) => {
        stringify!(128)
    };
    ("uart.peripheral_controls_mem_clk") => {
        false
    };
    ("wifi.has_wifi6") => {
        false
    };
    ("bt.controller") => {
        "btdm"
    };
    ("phy.combo_module") => {
        true
    };
    ("phy.backed_up_digital_register_count") => {
        21
    };
    ("phy.backed_up_digital_register_count", str) => {
        stringify!(21)
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_soc_xtal_options {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((40)); _for_each_inner!((all(40)));
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, ignore
/// ```
macro_rules! define_clock_tree_types {
    () => {
        #[doc = r" Represents the device's clock tree."]
        pub struct ClockTree {}
        impl ClockTree {
            #[doc = r" Locks the clock tree for exclusive access."]
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {});
        #[doc = r" Clock tree configuration."]
        #[doc = r""]
        #[doc = r" The fields of this struct are optional, with the following caveats:"]
        #[doc = r" - If `XTL_CLK` is not specified, the crystal frequency will be"]
        #[doc = r"   automatically detected if possible."]
        #[doc = r" - The CPU and its upstream clock nodes will be set to a default configuration."]
        #[doc = r" - Other unspecified clock sources will not be useable by peripherals."]
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct ClockConfig {}
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {});
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount += 1;
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount -= 1;
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            #[doc = "AES peripheral clock signal"]
            Aes,
            #[doc = "APB_SAR_ADC peripheral clock signal"]
            ApbSarAdc,
            #[doc = "DMA peripheral clock signal"]
            Dma,
            #[doc = "DS peripheral clock signal"]
            Ds,
            #[doc = "HMAC peripheral clock signal"]
            Hmac,
            #[doc = "I2C_EXT0 peripheral clock signal"]
            I2cExt0,
            #[doc = "I2C_EXT1 peripheral clock signal"]
            I2cExt1,
            #[doc = "I2S0 peripheral clock signal"]
            I2s0,
            #[doc = "I2S1 peripheral clock signal"]
            I2s1,
            #[doc = "LCD_CAM peripheral clock signal"]
            LcdCam,
            #[doc = "LEDC peripheral clock signal"]
            Ledc,
            #[doc = "MCPWM0 peripheral clock signal"]
            Mcpwm0,
            #[doc = "MCPWM1 peripheral clock signal"]
            Mcpwm1,
            #[doc = "PCNT peripheral clock signal"]
            Pcnt,
            #[doc = "PERI_BACKUP peripheral clock signal"]
            PeriBackup,
            #[doc = "RMT peripheral clock signal"]
            Rmt,
            #[doc = "RSA peripheral clock signal"]
            Rsa,
            #[doc = "SDIO_HOST peripheral clock signal"]
            SdioHost,
            #[doc = "SHA peripheral clock signal"]
            Sha,
            #[doc = "SPI2 peripheral clock signal"]
            Spi2,
            #[doc = "SPI3 peripheral clock signal"]
            Spi3,
            #[doc = "SYSTIMER peripheral clock signal"]
            Systimer,
            #[doc = "TIMG0 peripheral clock signal"]
            Timg0,
            #[doc = "TIMG1 peripheral clock signal"]
            Timg1,
            #[doc = "TWAI0 peripheral clock signal"]
            Twai0,
            #[doc = "UART0 peripheral clock signal"]
            Uart0,
            #[doc = "UART1 peripheral clock signal"]
            Uart1,
            #[doc = "UART2 peripheral clock signal"]
            Uart2,
            #[doc = "UART_MEM peripheral clock signal"]
            UartMem,
            #[doc = "UHCI0 peripheral clock signal"]
            Uhci0,
            #[doc = "USB peripheral clock signal"]
            Usb,
            #[doc = "USB_DEVICE peripheral clock signal"]
            UsbDevice,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] = &[
                Self::Systimer,
                Self::Timg0,
                Self::Uart0,
                Self::UartMem,
                Self::UsbDevice,
            ];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::ApbSarAdc,
                Self::Dma,
                Self::Ds,
                Self::Hmac,
                Self::I2cExt0,
                Self::I2cExt1,
                Self::I2s0,
                Self::I2s1,
                Self::LcdCam,
                Self::Ledc,
                Self::Mcpwm0,
                Self::Mcpwm1,
                Self::Pcnt,
                Self::PeriBackup,
                Self::Rmt,
                Self::Rsa,
                Self::SdioHost,
                Self::Sha,
                Self::Spi2,
                Self::Spi3,
                Self::Systimer,
                Self::Timg0,
                Self::Timg1,
                Self::Twai0,
                Self::Uart0,
                Self::Uart1,
                Self::Uart2,
                Self::UartMem,
                Self::Uhci0,
                Self::Usb,
                Self::UsbDevice,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_aes_clk_en().bit(enable));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.apb_saradc_clk_en().bit(enable));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.dma_clk_en().bit(enable));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_ds_clk_en().bit(enable));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_hmac_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2c_ext0_clk_en().bit(enable));
                }
                Peripheral::I2cExt1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2c_ext1_clk_en().bit(enable));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2s0_clk_en().bit(enable));
                }
                Peripheral::I2s1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2s1_clk_en().bit(enable));
                }
                Peripheral::LcdCam => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.lcd_cam_clk_en().bit(enable));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.ledc_clk_en().bit(enable));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.pwm0_clk_en().bit(enable));
                }
                Peripheral::Mcpwm1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.pwm1_clk_en().bit(enable));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.pcnt_clk_en().bit(enable));
                }
                Peripheral::PeriBackup => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.peri_backup_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_rsa_clk_en().bit(enable));
                }
                Peripheral::SdioHost => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.sdio_host_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_sha_clk_en().bit(enable));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi2_clk_en().bit(enable));
                }
                Peripheral::Spi3 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi3_clk_en().bit(enable));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.systimer_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.timergroup_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.timergroup1_clk_en().bit(enable));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.twai_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart_clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart1_clk_en().bit(enable));
                }
                Peripheral::Uart2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.uart2_clk_en().bit(enable));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart_mem_clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uhci0_clk_en().bit(enable));
                }
                Peripheral::Usb => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.usb_clk_en().bit(enable));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.usb_device_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_aes_rst().bit(reset));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.apb_saradc_rst().bit(reset));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.dma_rst().bit(reset));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_ds_rst().bit(reset));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_hmac_rst().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2c_ext0_rst().bit(reset));
                }
                Peripheral::I2cExt1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2c_ext1_rst().bit(reset));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2s0_rst().bit(reset));
                }
                Peripheral::I2s1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2s1_rst().bit(reset));
                }
                Peripheral::LcdCam => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.lcd_cam_rst().bit(reset));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.ledc_rst().bit(reset));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.pwm0_rst().bit(reset));
                }
                Peripheral::Mcpwm1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.pwm1_rst().bit(reset));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.pcnt_rst().bit(reset));
                }
                Peripheral::PeriBackup => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.peri_backup_rst().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.rmt_rst().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_rsa_rst().bit(reset));
                }
                Peripheral::SdioHost => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.sdio_host_rst().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_sha_rst().bit(reset));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi2_rst().bit(reset));
                }
                Peripheral::Spi3 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi3_rst().bit(reset));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.systimer_rst().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.timergroup_rst().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.timergroup1_rst().bit(reset));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.twai_rst().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart_rst().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart1_rst().bit(reset));
                }
                Peripheral::Uart2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.uart2_rst().bit(reset));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart_mem_rst().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uhci0_rst().bit(reset));
                }
                Peripheral::Usb => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.usb_rst().bit(reset));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.usb_device_rst().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x3FC88000..0x3FD00000
    };
    (size as str, "DRAM") => {
        "491520"
    };
    ("DRAM2_UNINIT") => {
        0x3FCDB700..0x3FCED710
    };
    (size as str, "DRAM2_UNINIT") => {
        "73744"
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_aes_key_length {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((128)); _for_each_inner!((256)); _for_each_inner!((128, 0, 4));
        _for_each_inner!((256, 2, 6)); _for_each_inner!((bits(128), (256)));
        _for_each_inner!((modes(128, 0, 4), (256, 2, 6)));
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0)); _for_each_inner!((1)); _for_each_inner!((2));
        _for_each_inner!((3)); _for_each_inner!((4)); _for_each_inner!((5));
        _for_each_inner!((6)); _for_each_inner!((7)); _for_each_inner!((0, 0));
        _for_each_inner!((1, 1)); _for_each_inner!((2, 2)); _for_each_inner!((3, 3));
        _for_each_inner!((4, 0)); _for_each_inner!((5, 1)); _for_each_inner!((6, 2));
        _for_each_inner!((7, 3)); _for_each_inner!((all(0), (1), (2), (3), (4), (5), (6),
        (7))); _for_each_inner!((tx(0, 0), (1, 1), (2, 2), (3, 3)));
        _for_each_inner!((rx(4, 0), (5, 1), (6, 2), (7, 3)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Apb, 1)); _for_each_inner!((RcFast, 2));
        _for_each_inner!((Xtal, 3)); _for_each_inner!((Apb)); _for_each_inner!((all(Apb,
        1), (RcFast, 2), (Xtal, 3))); _for_each_inner!((default(Apb)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((1568)); _for_each_inner!((1600)); _for_each_inner!((1632));
        _for_each_inner!((1664)); _for_each_inner!((1696)); _for_each_inner!((1728));
        _for_each_inner!((1760)); _for_each_inner!((1792)); _for_each_inner!((1824));
        _for_each_inner!((1856)); _for_each_inner!((1888)); _for_each_inner!((1920));
        _for_each_inner!((1952)); _for_each_inner!((1984)); _for_each_inner!((2016));
        _for_each_inner!((2048)); _for_each_inner!((2080)); _for_each_inner!((2112));
        _for_each_inner!((2144)); _for_each_inner!((2176)); _for_each_inner!((2208));
        _for_each_inner!((2240)); _for_each_inner!((2272)); _for_each_inner!((2304));
        _for_each_inner!((2336)); _for_each_inner!((2368)); _for_each_inner!((2400));
        _for_each_inner!((2432)); _for_each_inner!((2464)); _for_each_inner!((2496));
        _for_each_inner!((2528)); _for_each_inner!((2560)); _for_each_inner!((2592));
        _for_each_inner!((2624)); _for_each_inner!((2656)); _for_each_inner!((2688));
        _for_each_inner!((2720)); _for_each_inner!((2752)); _for_each_inner!((2784));
        _for_each_inner!((2816)); _for_each_inner!((2848)); _for_each_inner!((2880));
        _for_each_inner!((2912)); _for_each_inner!((2944)); _for_each_inner!((2976));
        _for_each_inner!((3008)); _for_each_inner!((3040)); _for_each_inner!((3072));
        _for_each_inner!((3104)); _for_each_inner!((3136)); _for_each_inner!((3168));
        _for_each_inner!((3200)); _for_each_inner!((3232)); _for_each_inner!((3264));
        _for_each_inner!((3296)); _for_each_inner!((3328)); _for_each_inner!((3360));
        _for_each_inner!((3392)); _for_each_inner!((3424)); _for_each_inner!((3456));
        _for_each_inner!((3488)); _for_each_inner!((3520)); _for_each_inner!((3552));
        _for_each_inner!((3584)); _for_each_inner!((3616)); _for_each_inner!((3648));
        _for_each_inner!((3680)); _for_each_inner!((3712)); _for_each_inner!((3744));
        _for_each_inner!((3776)); _for_each_inner!((3808)); _for_each_inner!((3840));
        _for_each_inner!((3872)); _for_each_inner!((3904)); _for_each_inner!((3936));
        _for_each_inner!((3968)); _for_each_inner!((4000)); _for_each_inner!((4032));
        _for_each_inner!((4064)); _for_each_inner!((4096)); _for_each_inner!((all(32),
        (64), (96), (128), (160), (192), (224), (256), (288), (320), (352), (384), (416),
        (448), (480), (512), (544), (576), (608), (640), (672), (704), (736), (768),
        (800), (832), (864), (896), (928), (960), (992), (1024), (1056), (1088), (1120),
        (1152), (1184), (1216), (1248), (1280), (1312), (1344), (1376), (1408), (1440),
        (1472), (1504), (1536), (1568), (1600), (1632), (1664), (1696), (1728), (1760),
        (1792), (1824), (1856), (1888), (1920), (1952), (1984), (2016), (2048), (2080),
        (2112), (2144), (2176), (2208), (2240), (2272), (2304), (2336), (2368), (2400),
        (2432), (2464), (2496), (2528), (2560), (2592), (2624), (2656), (2688), (2720),
        (2752), (2784), (2816), (2848), (2880), (2912), (2944), (2976), (3008), (3040),
        (3072), (3104), (3136), (3168), (3200), (3232), (3264), (3296), (3328), (3360),
        (3392), (3424), (3456), (3488), (3520), (3552), (3584), (3616), (3648), (3680),
        (3712), (3744), (3776), (3808), (3840), (3872), (3904), (3936), (3968), (4000),
        (4032), (4064), (4096)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((1568)); _for_each_inner!((1600)); _for_each_inner!((1632));
        _for_each_inner!((1664)); _for_each_inner!((1696)); _for_each_inner!((1728));
        _for_each_inner!((1760)); _for_each_inner!((1792)); _for_each_inner!((1824));
        _for_each_inner!((1856)); _for_each_inner!((1888)); _for_each_inner!((1920));
        _for_each_inner!((1952)); _for_each_inner!((1984)); _for_each_inner!((2016));
        _for_each_inner!((2048)); _for_each_inner!((all(32), (64), (96), (128), (160),
        (192), (224), (256), (288), (320), (352), (384), (416), (448), (480), (512),
        (544), (576), (608), (640), (672), (704), (736), (768), (800), (832), (864),
        (896), (928), (960), (992), (1024), (1056), (1088), (1120), (1152), (1184),
        (1216), (1248), (1280), (1312), (1344), (1376), (1408), (1440), (1472), (1504),
        (1536), (1568), (1600), (1632), (1664), (1696), (1728), (1760), (1792), (1824),
        (1856), (1888), (1920), (1952), (1984), (2016), (2048)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Sha1, "SHA-1"(sizes : 64, 20, 8) (insecure_against :
        "collision", "length extension"), 0)); _for_each_inner!((Sha224, "SHA-224"(sizes
        : 64, 28, 8) (insecure_against : "length extension"), 1));
        _for_each_inner!((Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against :
        "length extension"), 2)); _for_each_inner!((Sha384, "SHA-384"(sizes : 128, 48,
        16) (insecure_against :), 3)); _for_each_inner!((Sha512, "SHA-512"(sizes : 128,
        64, 16) (insecure_against : "length extension"), 4));
        _for_each_inner!((Sha512_224, "SHA-512/224"(sizes : 128, 28, 16)
        (insecure_against :), 5)); _for_each_inner!((Sha512_256, "SHA-512/256"(sizes :
        128, 32, 16) (insecure_against :), 6)); _for_each_inner!((algos(Sha1,
        "SHA-1"(sizes : 64, 20, 8) (insecure_against : "collision", "length extension"),
        0), (Sha224, "SHA-224"(sizes : 64, 28, 8) (insecure_against :
        "length extension"), 1), (Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against
        : "length extension"), 2), (Sha384, "SHA-384"(sizes : 128, 48, 16)
        (insecure_against :), 3), (Sha512, "SHA-512"(sizes : 128, 64, 16)
        (insecure_against : "length extension"), 4), (Sha512_224, "SHA-512/224"(sizes :
        128, 28, 16) (insecure_against :), 5), (Sha512_256, "SHA-512/256"(sizes : 128,
        32, 16) (insecure_against :), 6)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA));
        _for_each_inner!((I2C1, I2cExt1, I2CEXT1_SCL, I2CEXT1_SDA));
        _for_each_inner!((all(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA), (I2C1, I2cExt1,
        I2CEXT1_SCL, I2CEXT1_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident, $rts:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner!((UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner!((UART2, Uart2, U2RXD, U2TXD, U2CTS, U2RTS));
        _for_each_inner!((all(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (UART1, Uart1,
        U1RXD, U1TXD, U1CTS, U1RTS), (UART2, Uart2, U2RXD, U2TXD, U2CTS, U2RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, [$($cs:ident),*] [$($sio:ident),*
/// $($is_qspi:iteral)?])`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6,
        FSPIIO7], true)); _for_each_inner!((SPI3, Spi3, SPI3_CLK[SPI3_CS0, SPI3_CS1,
        SPI3_CS2] [SPI3_D, SPI3_Q, SPI3_WP, SPI3_HD], true)); _for_each_inner!((all(SPI2,
        Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID,
        FSPIQ, FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true), (SPI3, Spi3,
        SPI3_CLK[SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q, SPI3_WP, SPI3_HD],
        true)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0));
        _for_each_inner!((SPI3, Spi3, SPI3_CLK, SPI3_D, SPI3_Q, SPI3_CS0));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0), (SPI3, Spi3,
        SPI3_CLK, SPI3_D, SPI3_Q, SPI3_CS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((@ peri_type GPIO0 <= virtual())); _for_each_inner!((@ peri_type
        GPIO1 <= virtual())); _for_each_inner!((@ peri_type GPIO2 <= virtual()));
        _for_each_inner!((@ peri_type GPIO3 <= virtual())); _for_each_inner!((@ peri_type
        GPIO4 <= virtual())); _for_each_inner!((@ peri_type GPIO5 <= virtual()));
        _for_each_inner!((@ peri_type GPIO6 <= virtual())); _for_each_inner!((@ peri_type
        GPIO7 <= virtual())); _for_each_inner!((@ peri_type GPIO8 <= virtual()));
        _for_each_inner!((@ peri_type GPIO9 <= virtual())); _for_each_inner!((@ peri_type
        GPIO10 <= virtual())); _for_each_inner!((@ peri_type GPIO11 <= virtual()));
        _for_each_inner!((@ peri_type GPIO12 <= virtual())); _for_each_inner!((@
        peri_type GPIO13 <= virtual())); _for_each_inner!((@ peri_type GPIO14 <=
        virtual())); _for_each_inner!((@ peri_type GPIO15 <= virtual()));
        _for_each_inner!((@ peri_type GPIO16 <= virtual())); _for_each_inner!((@
        peri_type GPIO17 <= virtual())); _for_each_inner!((@ peri_type GPIO18 <=
        virtual())); _for_each_inner!((@ peri_type GPIO19 <= virtual()));
        _for_each_inner!((@ peri_type GPIO20 <= virtual())); _for_each_inner!((@
        peri_type GPIO21 <= virtual())); _for_each_inner!((@ peri_type GPIO33 <=
        virtual())); _for_each_inner!((@ peri_type GPIO34 <= virtual()));
        _for_each_inner!((@ peri_type GPIO35 <= virtual())); _for_each_inner!((@
        peri_type GPIO36 <= virtual())); _for_each_inner!((@ peri_type GPIO37 <=
        virtual())); _for_each_inner!((@ peri_type GPIO38 <= virtual()));
        _for_each_inner!((@ peri_type GPIO39 <= virtual())); _for_each_inner!((@
        peri_type GPIO40 <= virtual())); _for_each_inner!((@ peri_type GPIO41 <=
        virtual())); _for_each_inner!((@ peri_type GPIO42 <= virtual()));
        _for_each_inner!((@ peri_type GPIO43 <= virtual())); _for_each_inner!((@
        peri_type GPIO44 <= virtual())); _for_each_inner!((@ peri_type GPIO45 <=
        virtual())); _for_each_inner!((@ peri_type GPIO46 <= virtual()));
        _for_each_inner!((@ peri_type GPIO47 <= virtual())); _for_each_inner!((@
        peri_type GPIO48 <= virtual())); _for_each_inner!((@ peri_type AES <= AES(AES : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type APB_CTRL <= APB_CTRL() (unstable)));
        _for_each_inner!((@ peri_type APB_SARADC <= APB_SARADC() (unstable)));
        _for_each_inner!((@ peri_type ASSIST_DEBUG <= ASSIST_DEBUG() (unstable)));
        _for_each_inner!((@ peri_type DMA <= DMA() (unstable))); _for_each_inner!((@
        peri_type DS <= DS() (unstable))); _for_each_inner!((@ peri_type EFUSE <= EFUSE()
        (unstable))); _for_each_inner!((@ peri_type EXTMEM <= EXTMEM() (unstable)));
        _for_each_inner!((@ peri_type GPIO <= GPIO() (unstable))); _for_each_inner!((@
        peri_type GPIO_SD <= GPIO_SD() (unstable))); _for_each_inner!((@ peri_type HMAC
        <= HMAC() (unstable))); _for_each_inner!((@ peri_type I2C0 <= I2C0(I2C_EXT0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((@ peri_type I2C1 <= I2C1(I2C_EXT1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        I2S0 <= I2S0(I2S0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type I2S1 <=
        I2S1(I2S1 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }) (unstable))); _for_each_inner!((@ peri_type INTERRUPT_CORE0 <=
        INTERRUPT_CORE0() (unstable))); _for_each_inner!((@ peri_type INTERRUPT_CORE1 <=
        INTERRUPT_CORE1() (unstable))); _for_each_inner!((@ peri_type IO_MUX <= IO_MUX()
        (unstable))); _for_each_inner!((@ peri_type LCD_CAM <= LCD_CAM() (unstable)));
        _for_each_inner!((@ peri_type LEDC <= LEDC() (unstable))); _for_each_inner!((@
        peri_type LPWR <= RTC_CNTL() (unstable))); _for_each_inner!((@ peri_type MCPWM0
        <= MCPWM0() (unstable))); _for_each_inner!((@ peri_type MCPWM1 <= MCPWM1()
        (unstable))); _for_each_inner!((@ peri_type PCNT <= PCNT() (unstable)));
        _for_each_inner!((@ peri_type PERI_BACKUP <= PERI_BACKUP() (unstable)));
        _for_each_inner!((@ peri_type RMT <= RMT() (unstable))); _for_each_inner!((@
        peri_type RNG <= RNG() (unstable))); _for_each_inner!((@ peri_type RSA <= RSA(RSA
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type RTC_CNTL <= RTC_CNTL() (unstable)));
        _for_each_inner!((@ peri_type RTC_I2C <= RTC_I2C() (unstable)));
        _for_each_inner!((@ peri_type RTC_IO <= RTC_IO() (unstable)));
        _for_each_inner!((@ peri_type SDHOST <= SDHOST() (unstable)));
        _for_each_inner!((@ peri_type SENS <= SENS() (unstable))); _for_each_inner!((@
        peri_type SENSITIVE <= SENSITIVE() (unstable))); _for_each_inner!((@ peri_type
        SHA <= SHA(SHA : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type SPI0 <=
        SPI0() (unstable))); _for_each_inner!((@ peri_type SPI1 <= SPI1() (unstable)));
        _for_each_inner!((@ peri_type SPI2 <= SPI2(SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        SPI3 <= SPI3(SPI3 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner!((@ peri_type SYSTEM <= SYSTEM()
        (unstable))); _for_each_inner!((@ peri_type SYSTIMER <= SYSTIMER() (unstable)));
        _for_each_inner!((@ peri_type TIMG0 <= TIMG0() (unstable))); _for_each_inner!((@
        peri_type TIMG1 <= TIMG1() (unstable))); _for_each_inner!((@ peri_type TWAI0 <=
        TWAI0() (unstable))); _for_each_inner!((@ peri_type UART0 <= UART0(UART0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((@ peri_type UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        UART2 <= UART2(UART2 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner!((@ peri_type UHCI0 <= UHCI0()
        (unstable))); _for_each_inner!((@ peri_type USB0 <= USB0() (unstable)));
        _for_each_inner!((@ peri_type USB_DEVICE <= USB_DEVICE(USB_DEVICE : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type USB_WRAP <= USB_WRAP() (unstable)));
        _for_each_inner!((@ peri_type WCL <= WCL() (unstable))); _for_each_inner!((@
        peri_type XTS_AES <= XTS_AES() (unstable))); _for_each_inner!((@ peri_type
        DMA_CH0 <= virtual() (unstable))); _for_each_inner!((@ peri_type DMA_CH1 <=
        virtual() (unstable))); _for_each_inner!((@ peri_type DMA_CH2 <= virtual()
        (unstable))); _for_each_inner!((@ peri_type DMA_CH3 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type DMA_CH4 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type ADC1 <= virtual() (unstable))); _for_each_inner!((@
        peri_type ADC2 <= virtual() (unstable))); _for_each_inner!((@ peri_type BT <=
        virtual() (unstable))); _for_each_inner!((@ peri_type CPU_CTRL <= virtual()
        (unstable))); _for_each_inner!((@ peri_type FLASH <= virtual() (unstable)));
        _for_each_inner!((@ peri_type PSRAM <= virtual() (unstable)));
        _for_each_inner!((@ peri_type SW_INTERRUPT <= virtual() (unstable)));
        _for_each_inner!((@ peri_type ULP_RISCV_CORE <= virtual() (unstable)));
        _for_each_inner!((@ peri_type WIFI <= virtual() (unstable)));
        _for_each_inner!((GPIO0)); _for_each_inner!((GPIO1)); _for_each_inner!((GPIO2));
        _for_each_inner!((GPIO3)); _for_each_inner!((GPIO4)); _for_each_inner!((GPIO5));
        _for_each_inner!((GPIO6)); _for_each_inner!((GPIO7)); _for_each_inner!((GPIO8));
        _for_each_inner!((GPIO9)); _for_each_inner!((GPIO10));
        _for_each_inner!((GPIO11)); _for_each_inner!((GPIO12));
        _for_each_inner!((GPIO13)); _for_each_inner!((GPIO14));
        _for_each_inner!((GPIO15)); _for_each_inner!((GPIO16));
        _for_each_inner!((GPIO17)); _for_each_inner!((GPIO18));
        _for_each_inner!((GPIO19)); _for_each_inner!((GPIO20));
        _for_each_inner!((GPIO21)); _for_each_inner!((GPIO33));
        _for_each_inner!((GPIO34)); _for_each_inner!((GPIO35));
        _for_each_inner!((GPIO36)); _for_each_inner!((GPIO37));
        _for_each_inner!((GPIO38)); _for_each_inner!((GPIO39));
        _for_each_inner!((GPIO40)); _for_each_inner!((GPIO41));
        _for_each_inner!((GPIO42)); _for_each_inner!((GPIO43));
        _for_each_inner!((GPIO44)); _for_each_inner!((GPIO45));
        _for_each_inner!((GPIO46)); _for_each_inner!((GPIO47));
        _for_each_inner!((GPIO48)); _for_each_inner!((AES(unstable)));
        _for_each_inner!((APB_CTRL(unstable))); _for_each_inner!((APB_SARADC(unstable)));
        _for_each_inner!((ASSIST_DEBUG(unstable))); _for_each_inner!((DMA(unstable)));
        _for_each_inner!((DS(unstable))); _for_each_inner!((EFUSE(unstable)));
        _for_each_inner!((EXTMEM(unstable))); _for_each_inner!((GPIO(unstable)));
        _for_each_inner!((GPIO_SD(unstable))); _for_each_inner!((HMAC(unstable)));
        _for_each_inner!((I2C0)); _for_each_inner!((I2C1));
        _for_each_inner!((I2S0(unstable))); _for_each_inner!((I2S1(unstable)));
        _for_each_inner!((INTERRUPT_CORE0(unstable)));
        _for_each_inner!((INTERRUPT_CORE1(unstable)));
        _for_each_inner!((IO_MUX(unstable))); _for_each_inner!((LCD_CAM(unstable)));
        _for_each_inner!((LEDC(unstable))); _for_each_inner!((LPWR(unstable)));
        _for_each_inner!((MCPWM0(unstable))); _for_each_inner!((MCPWM1(unstable)));
        _for_each_inner!((PCNT(unstable))); _for_each_inner!((PERI_BACKUP(unstable)));
        _for_each_inner!((RMT(unstable))); _for_each_inner!((RNG(unstable)));
        _for_each_inner!((RSA(unstable))); _for_each_inner!((RTC_CNTL(unstable)));
        _for_each_inner!((RTC_I2C(unstable))); _for_each_inner!((RTC_IO(unstable)));
        _for_each_inner!((SDHOST(unstable))); _for_each_inner!((SENS(unstable)));
        _for_each_inner!((SENSITIVE(unstable))); _for_each_inner!((SHA(unstable)));
        _for_each_inner!((SPI0(unstable))); _for_each_inner!((SPI1(unstable)));
        _for_each_inner!((SPI2)); _for_each_inner!((SPI3));
        _for_each_inner!((SYSTEM(unstable))); _for_each_inner!((SYSTIMER(unstable)));
        _for_each_inner!((TIMG0(unstable))); _for_each_inner!((TIMG1(unstable)));
        _for_each_inner!((TWAI0(unstable))); _for_each_inner!((UART0));
        _for_each_inner!((UART1)); _for_each_inner!((UART2));
        _for_each_inner!((UHCI0(unstable))); _for_each_inner!((USB0(unstable)));
        _for_each_inner!((USB_DEVICE(unstable))); _for_each_inner!((USB_WRAP(unstable)));
        _for_each_inner!((WCL(unstable))); _for_each_inner!((XTS_AES(unstable)));
        _for_each_inner!((DMA_CH0(unstable))); _for_each_inner!((DMA_CH1(unstable)));
        _for_each_inner!((DMA_CH2(unstable))); _for_each_inner!((DMA_CH3(unstable)));
        _for_each_inner!((DMA_CH4(unstable))); _for_each_inner!((ADC1(unstable)));
        _for_each_inner!((ADC2(unstable))); _for_each_inner!((BT(unstable)));
        _for_each_inner!((CPU_CTRL(unstable))); _for_each_inner!((FLASH(unstable)));
        _for_each_inner!((PSRAM(unstable))); _for_each_inner!((SW_INTERRUPT(unstable)));
        _for_each_inner!((ULP_RISCV_CORE(unstable))); _for_each_inner!((WIFI(unstable)));
        _for_each_inner!((all(@ peri_type GPIO0 <= virtual()), (@ peri_type GPIO1 <=
        virtual()), (@ peri_type GPIO2 <= virtual()), (@ peri_type GPIO3 <= virtual()),
        (@ peri_type GPIO4 <= virtual()), (@ peri_type GPIO5 <= virtual()), (@ peri_type
        GPIO6 <= virtual()), (@ peri_type GPIO7 <= virtual()), (@ peri_type GPIO8 <=
        virtual()), (@ peri_type GPIO9 <= virtual()), (@ peri_type GPIO10 <= virtual()),
        (@ peri_type GPIO11 <= virtual()), (@ peri_type GPIO12 <= virtual()), (@
        peri_type GPIO13 <= virtual()), (@ peri_type GPIO14 <= virtual()), (@ peri_type
        GPIO15 <= virtual()), (@ peri_type GPIO16 <= virtual()), (@ peri_type GPIO17 <=
        virtual()), (@ peri_type GPIO18 <= virtual()), (@ peri_type GPIO19 <= virtual()),
        (@ peri_type GPIO20 <= virtual()), (@ peri_type GPIO21 <= virtual()), (@
        peri_type GPIO33 <= virtual()), (@ peri_type GPIO34 <= virtual()), (@ peri_type
        GPIO35 <= virtual()), (@ peri_type GPIO36 <= virtual()), (@ peri_type GPIO37 <=
        virtual()), (@ peri_type GPIO38 <= virtual()), (@ peri_type GPIO39 <= virtual()),
        (@ peri_type GPIO40 <= virtual()), (@ peri_type GPIO41 <= virtual()), (@
        peri_type GPIO42 <= virtual()), (@ peri_type GPIO43 <= virtual()), (@ peri_type
        GPIO44 <= virtual()), (@ peri_type GPIO45 <= virtual()), (@ peri_type GPIO46 <=
        virtual()), (@ peri_type GPIO47 <= virtual()), (@ peri_type GPIO48 <= virtual()),
        (@ peri_type AES <= AES(AES : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type APB_CTRL <= APB_CTRL()
        (unstable)), (@ peri_type APB_SARADC <= APB_SARADC() (unstable)), (@ peri_type
        ASSIST_DEBUG <= ASSIST_DEBUG() (unstable)), (@ peri_type DMA <= DMA()
        (unstable)), (@ peri_type DS <= DS() (unstable)), (@ peri_type EFUSE <= EFUSE()
        (unstable)), (@ peri_type EXTMEM <= EXTMEM() (unstable)), (@ peri_type GPIO <=
        GPIO() (unstable)), (@ peri_type GPIO_SD <= GPIO_SD() (unstable)), (@ peri_type
        HMAC <= HMAC() (unstable)), (@ peri_type I2C0 <= I2C0(I2C_EXT0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type I2C1 <= I2C1(I2C_EXT1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type I2S0 <= I2S0(I2S0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type I2S1 <= I2S1(I2S1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type
        INTERRUPT_CORE0 <= INTERRUPT_CORE0() (unstable)), (@ peri_type INTERRUPT_CORE1 <=
        INTERRUPT_CORE1() (unstable)), (@ peri_type IO_MUX <= IO_MUX() (unstable)), (@
        peri_type LCD_CAM <= LCD_CAM() (unstable)), (@ peri_type LEDC <= LEDC()
        (unstable)), (@ peri_type LPWR <= RTC_CNTL() (unstable)), (@ peri_type MCPWM0 <=
        MCPWM0() (unstable)), (@ peri_type MCPWM1 <= MCPWM1() (unstable)), (@ peri_type
        PCNT <= PCNT() (unstable)), (@ peri_type PERI_BACKUP <= PERI_BACKUP()
        (unstable)), (@ peri_type RMT <= RMT() (unstable)), (@ peri_type RNG <= RNG()
        (unstable)), (@ peri_type RSA <= RSA(RSA : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type
        RTC_CNTL <= RTC_CNTL() (unstable)), (@ peri_type RTC_I2C <= RTC_I2C()
        (unstable)), (@ peri_type RTC_IO <= RTC_IO() (unstable)), (@ peri_type SDHOST <=
        SDHOST() (unstable)), (@ peri_type SENS <= SENS() (unstable)), (@ peri_type
        SENSITIVE <= SENSITIVE() (unstable)), (@ peri_type SHA <= SHA(SHA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type SPI0 <= SPI0() (unstable)), (@ peri_type SPI1 <= SPI1()
        (unstable)), (@ peri_type SPI2 <= SPI2(SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type SPI3 <= SPI3(SPI3
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type SYSTEM <= SYSTEM() (unstable)), (@ peri_type SYSTIMER <= SYSTIMER()
        (unstable)), (@ peri_type TIMG0 <= TIMG0() (unstable)), (@ peri_type TIMG1 <=
        TIMG1() (unstable)), (@ peri_type TWAI0 <= TWAI0() (unstable)), (@ peri_type
        UART0 <= UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type UART1 <= UART1(UART1 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type UART2 <= UART2(UART2 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type UHCI0 <= UHCI0() (unstable)), (@
        peri_type USB0 <= USB0() (unstable)), (@ peri_type USB_DEVICE <=
        USB_DEVICE(USB_DEVICE : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type USB_WRAP <= USB_WRAP()
        (unstable)), (@ peri_type WCL <= WCL() (unstable)), (@ peri_type XTS_AES <=
        XTS_AES() (unstable)), (@ peri_type DMA_CH0 <= virtual() (unstable)), (@
        peri_type DMA_CH1 <= virtual() (unstable)), (@ peri_type DMA_CH2 <= virtual()
        (unstable)), (@ peri_type DMA_CH3 <= virtual() (unstable)), (@ peri_type DMA_CH4
        <= virtual() (unstable)), (@ peri_type ADC1 <= virtual() (unstable)), (@
        peri_type ADC2 <= virtual() (unstable)), (@ peri_type BT <= virtual()
        (unstable)), (@ peri_type CPU_CTRL <= virtual() (unstable)), (@ peri_type FLASH
        <= virtual() (unstable)), (@ peri_type PSRAM <= virtual() (unstable)), (@
        peri_type SW_INTERRUPT <= virtual() (unstable)), (@ peri_type ULP_RISCV_CORE <=
        virtual() (unstable)), (@ peri_type WIFI <= virtual() (unstable))));
        _for_each_inner!((singletons(GPIO0), (GPIO1), (GPIO2), (GPIO3), (GPIO4), (GPIO5),
        (GPIO6), (GPIO7), (GPIO8), (GPIO9), (GPIO10), (GPIO11), (GPIO12), (GPIO13),
        (GPIO14), (GPIO15), (GPIO16), (GPIO17), (GPIO18), (GPIO19), (GPIO20), (GPIO21),
        (GPIO33), (GPIO34), (GPIO35), (GPIO36), (GPIO37), (GPIO38), (GPIO39), (GPIO40),
        (GPIO41), (GPIO42), (GPIO43), (GPIO44), (GPIO45), (GPIO46), (GPIO47), (GPIO48),
        (AES(unstable)), (APB_CTRL(unstable)), (APB_SARADC(unstable)),
        (ASSIST_DEBUG(unstable)), (DMA(unstable)), (DS(unstable)), (EFUSE(unstable)),
        (EXTMEM(unstable)), (GPIO(unstable)), (GPIO_SD(unstable)), (HMAC(unstable)),
        (I2C0), (I2C1), (I2S0(unstable)), (I2S1(unstable)), (INTERRUPT_CORE0(unstable)),
        (INTERRUPT_CORE1(unstable)), (IO_MUX(unstable)), (LCD_CAM(unstable)),
        (LEDC(unstable)), (LPWR(unstable)), (MCPWM0(unstable)), (MCPWM1(unstable)),
        (PCNT(unstable)), (PERI_BACKUP(unstable)), (RMT(unstable)), (RNG(unstable)),
        (RSA(unstable)), (RTC_CNTL(unstable)), (RTC_I2C(unstable)), (RTC_IO(unstable)),
        (SDHOST(unstable)), (SENS(unstable)), (SENSITIVE(unstable)), (SHA(unstable)),
        (SPI0(unstable)), (SPI1(unstable)), (SPI2), (SPI3), (SYSTEM(unstable)),
        (SYSTIMER(unstable)), (TIMG0(unstable)), (TIMG1(unstable)), (TWAI0(unstable)),
        (UART0), (UART1), (UART2), (UHCI0(unstable)), (USB0(unstable)),
        (USB_DEVICE(unstable)), (USB_WRAP(unstable)), (WCL(unstable)),
        (XTS_AES(unstable)), (DMA_CH0(unstable)), (DMA_CH1(unstable)),
        (DMA_CH2(unstable)), (DMA_CH3(unstable)), (DMA_CH4(unstable)), (ADC1(unstable)),
        (ADC2(unstable)), (BT(unstable)), (CPU_CTRL(unstable)), (FLASH(unstable)),
        (PSRAM(unstable)), (SW_INTERRUPT(unstable)), (ULP_RISCV_CORE(unstable)),
        (WIFI(unstable))));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, GPIO0() () ([Input] [Output]))); _for_each_inner!((1,
        GPIO1() () ([Input] [Output]))); _for_each_inner!((2, GPIO2() () ([Input]
        [Output]))); _for_each_inner!((3, GPIO3() () ([Input] [Output])));
        _for_each_inner!((4, GPIO4() () ([Input] [Output]))); _for_each_inner!((5,
        GPIO5() () ([Input] [Output]))); _for_each_inner!((6, GPIO6() () ([Input]
        [Output]))); _for_each_inner!((7, GPIO7() () ([Input] [Output])));
        _for_each_inner!((8, GPIO8() (_3 => SUBSPICS1) ([Input] [Output])));
        _for_each_inner!((9, GPIO9(_3 => SUBSPIHD _4 => FSPIHD) (_3 => SUBSPIHD _4 =>
        FSPIHD) ([Input] [Output]))); _for_each_inner!((10, GPIO10(_2 => FSPIIO4 _4 =>
        FSPICS0) (_2 => FSPIIO4 _3 => SUBSPICS0 _4 => FSPICS0) ([Input] [Output])));
        _for_each_inner!((11, GPIO11(_2 => FSPIIO5 _3 => SUBSPID _4 => FSPID) (_2 =>
        FSPIIO5 _3 => SUBSPID _4 => FSPID) ([Input] [Output]))); _for_each_inner!((12,
        GPIO12(_2 => FSPIIO6 _4 => FSPICLK) (_2 => FSPIIO6 _3 => SUBSPICLK _4 => FSPICLK)
        ([Input] [Output]))); _for_each_inner!((13, GPIO13(_2 => FSPIIO7 _3 => SUBSPIQ _4
        => FSPIQ) (_2 => FSPIIO7 _3 => SUBSPIQ _4 => FSPIQ) ([Input] [Output])));
        _for_each_inner!((14, GPIO14(_3 => SUBSPIWP _4 => FSPIWP) (_2 => FSPIDQS _3 =>
        SUBSPIWP _4 => FSPIWP) ([Input] [Output]))); _for_each_inner!((15, GPIO15() (_2
        => U0RTS) ([Input] [Output]))); _for_each_inner!((16, GPIO16(_2 => U0CTS) ()
        ([Input] [Output]))); _for_each_inner!((17, GPIO17() (_2 => U1TXD) ([Input]
        [Output]))); _for_each_inner!((18, GPIO18(_2 => U1RXD) (_3 => CLK_OUT3) ([Input]
        [Output]))); _for_each_inner!((19, GPIO19() (_2 => U1RTS _3 => CLK_OUT2) ([Input]
        [Output]))); _for_each_inner!((20, GPIO20(_2 => U1CTS) (_3 => CLK_OUT1) ([Input]
        [Output]))); _for_each_inner!((21, GPIO21() () ([Input] [Output])));
        _for_each_inner!((33, GPIO33(_2 => FSPIHD _3 => SUBSPIHD _4 => SPIIO4) (_2 =>
        FSPIHD _3 => SUBSPIHD _4 => SPIIO4) ([Input] [Output]))); _for_each_inner!((34,
        GPIO34(_2 => FSPICS0 _4 => SPIIO5) (_2 => FSPICS0 _3 => SUBSPICS0 _4 => SPIIO5)
        ([Input] [Output]))); _for_each_inner!((35, GPIO35(_2 => FSPID _3 => SUBSPID _4
        => SPIIO6) (_2 => FSPID _3 => SUBSPID _4 => SPIIO6) ([Input] [Output])));
        _for_each_inner!((36, GPIO36(_2 => FSPICLK _4 => SPIIO7) (_2 => FSPICLK _3 =>
        SUBSPICLK _4 => SPIIO7) ([Input] [Output]))); _for_each_inner!((37, GPIO37(_2 =>
        FSPIQ _3 => SUBSPIQ _4 => SPIDQS) (_2 => FSPIQ _3 => SUBSPIQ _4 => SPIDQS)
        ([Input] [Output]))); _for_each_inner!((38, GPIO38(_2 => FSPIWP _3 => SUBSPIWP)
        (_2 => FSPIWP _3 => SUBSPIWP) ([Input] [Output]))); _for_each_inner!((39,
        GPIO39() (_2 => CLK_OUT3 _3 => SUBSPICS1) ([Input] [Output])));
        _for_each_inner!((40, GPIO40() (_2 => CLK_OUT2) ([Input] [Output])));
        _for_each_inner!((41, GPIO41() (_2 => CLK_OUT1) ([Input] [Output])));
        _for_each_inner!((42, GPIO42() () ([Input] [Output]))); _for_each_inner!((43,
        GPIO43() (_0 => U0TXD _2 => CLK_OUT1) ([Input] [Output]))); _for_each_inner!((44,
        GPIO44(_0 => U0RXD) (_2 => CLK_OUT2) ([Input] [Output]))); _for_each_inner!((45,
        GPIO45() () ([Input] [Output]))); _for_each_inner!((46, GPIO46() () ([Input]
        [Output]))); _for_each_inner!((47, GPIO47() (_0 => SPICLK_P_DIFF _2 =>
        SUBSPICLK_P_DIFF) ([Input] [Output]))); _for_each_inner!((48, GPIO48() (_0 =>
        SPICLK_N_DIFF _2 => SUBSPICLK_N_DIFF) ([Input] [Output])));
        _for_each_inner!((all(0, GPIO0() () ([Input] [Output])), (1, GPIO1() () ([Input]
        [Output])), (2, GPIO2() () ([Input] [Output])), (3, GPIO3() () ([Input]
        [Output])), (4, GPIO4() () ([Input] [Output])), (5, GPIO5() () ([Input]
        [Output])), (6, GPIO6() () ([Input] [Output])), (7, GPIO7() () ([Input]
        [Output])), (8, GPIO8() (_3 => SUBSPICS1) ([Input] [Output])), (9, GPIO9(_3 =>
        SUBSPIHD _4 => FSPIHD) (_3 => SUBSPIHD _4 => FSPIHD) ([Input] [Output])), (10,
        GPIO10(_2 => FSPIIO4 _4 => FSPICS0) (_2 => FSPIIO4 _3 => SUBSPICS0 _4 => FSPICS0)
        ([Input] [Output])), (11, GPIO11(_2 => FSPIIO5 _3 => SUBSPID _4 => FSPID) (_2 =>
        FSPIIO5 _3 => SUBSPID _4 => FSPID) ([Input] [Output])), (12, GPIO12(_2 => FSPIIO6
        _4 => FSPICLK) (_2 => FSPIIO6 _3 => SUBSPICLK _4 => FSPICLK) ([Input] [Output])),
        (13, GPIO13(_2 => FSPIIO7 _3 => SUBSPIQ _4 => FSPIQ) (_2 => FSPIIO7 _3 => SUBSPIQ
        _4 => FSPIQ) ([Input] [Output])), (14, GPIO14(_3 => SUBSPIWP _4 => FSPIWP) (_2 =>
        FSPIDQS _3 => SUBSPIWP _4 => FSPIWP) ([Input] [Output])), (15, GPIO15() (_2 =>
        U0RTS) ([Input] [Output])), (16, GPIO16(_2 => U0CTS) () ([Input] [Output])), (17,
        GPIO17() (_2 => U1TXD) ([Input] [Output])), (18, GPIO18(_2 => U1RXD) (_3 =>
        CLK_OUT3) ([Input] [Output])), (19, GPIO19() (_2 => U1RTS _3 => CLK_OUT2)
        ([Input] [Output])), (20, GPIO20(_2 => U1CTS) (_3 => CLK_OUT1) ([Input]
        [Output])), (21, GPIO21() () ([Input] [Output])), (33, GPIO33(_2 => FSPIHD _3 =>
        SUBSPIHD _4 => SPIIO4) (_2 => FSPIHD _3 => SUBSPIHD _4 => SPIIO4) ([Input]
        [Output])), (34, GPIO34(_2 => FSPICS0 _4 => SPIIO5) (_2 => FSPICS0 _3 =>
        SUBSPICS0 _4 => SPIIO5) ([Input] [Output])), (35, GPIO35(_2 => FSPID _3 =>
        SUBSPID _4 => SPIIO6) (_2 => FSPID _3 => SUBSPID _4 => SPIIO6) ([Input]
        [Output])), (36, GPIO36(_2 => FSPICLK _4 => SPIIO7) (_2 => FSPICLK _3 =>
        SUBSPICLK _4 => SPIIO7) ([Input] [Output])), (37, GPIO37(_2 => FSPIQ _3 =>
        SUBSPIQ _4 => SPIDQS) (_2 => FSPIQ _3 => SUBSPIQ _4 => SPIDQS) ([Input]
        [Output])), (38, GPIO38(_2 => FSPIWP _3 => SUBSPIWP) (_2 => FSPIWP _3 =>
        SUBSPIWP) ([Input] [Output])), (39, GPIO39() (_2 => CLK_OUT3 _3 => SUBSPICS1)
        ([Input] [Output])), (40, GPIO40() (_2 => CLK_OUT2) ([Input] [Output])), (41,
        GPIO41() (_2 => CLK_OUT1) ([Input] [Output])), (42, GPIO42() () ([Input]
        [Output])), (43, GPIO43() (_0 => U0TXD _2 => CLK_OUT1) ([Input] [Output])), (44,
        GPIO44(_0 => U0RXD) (_2 => CLK_OUT2) ([Input] [Output])), (45, GPIO45() ()
        ([Input] [Output])), (46, GPIO46() () ([Input] [Output])), (47, GPIO47() (_0 =>
        SPICLK_P_DIFF _2 => SUBSPICLK_P_DIFF) ([Input] [Output])), (48, GPIO48() (_0 =>
        SPICLK_N_DIFF _2 => SUBSPICLK_N_DIFF) ([Input] [Output]))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((TOUCH1, GPIO1)); _for_each_inner!((ADC1_CH0, GPIO1));
        _for_each_inner!((TOUCH2, GPIO2)); _for_each_inner!((ADC1_CH1, GPIO2));
        _for_each_inner!((TOUCH3, GPIO3)); _for_each_inner!((ADC1_CH2, GPIO3));
        _for_each_inner!((TOUCH4, GPIO4)); _for_each_inner!((ADC1_CH3, GPIO4));
        _for_each_inner!((TOUCH5, GPIO5)); _for_each_inner!((ADC1_CH4, GPIO5));
        _for_each_inner!((TOUCH6, GPIO6)); _for_each_inner!((ADC1_CH5, GPIO6));
        _for_each_inner!((TOUCH7, GPIO7)); _for_each_inner!((ADC1_CH6, GPIO7));
        _for_each_inner!((TOUCH8, GPIO8)); _for_each_inner!((ADC1_CH7, GPIO8));
        _for_each_inner!((TOUCH9, GPIO9)); _for_each_inner!((ADC1_CH8, GPIO9));
        _for_each_inner!((TOUCH10, GPIO10)); _for_each_inner!((ADC1_CH9, GPIO10));
        _for_each_inner!((TOUCH11, GPIO11)); _for_each_inner!((ADC2_CH0, GPIO11));
        _for_each_inner!((TOUCH12, GPIO12)); _for_each_inner!((ADC2_CH1, GPIO12));
        _for_each_inner!((TOUCH13, GPIO13)); _for_each_inner!((ADC2_CH2, GPIO13));
        _for_each_inner!((TOUCH14, GPIO14)); _for_each_inner!((ADC2_CH3, GPIO14));
        _for_each_inner!((XTAL_32K_P, GPIO15)); _for_each_inner!((ADC2_CH4, GPIO15));
        _for_each_inner!((XTAL_32K_N, GPIO16)); _for_each_inner!((ADC2_CH5, GPIO16));
        _for_each_inner!((ADC2_CH6, GPIO17)); _for_each_inner!((ADC2_CH7, GPIO18));
        _for_each_inner!((USB_DM, GPIO19)); _for_each_inner!((ADC2_CH8, GPIO19));
        _for_each_inner!((USB_DP, GPIO20)); _for_each_inner!((ADC2_CH9, GPIO20));
        _for_each_inner!(((TOUCH1, TOUCHn, 1), GPIO1)); _for_each_inner!(((ADC1_CH0,
        ADCn_CHm, 1, 0), GPIO1)); _for_each_inner!(((TOUCH2, TOUCHn, 2), GPIO2));
        _for_each_inner!(((ADC1_CH1, ADCn_CHm, 1, 1), GPIO2)); _for_each_inner!(((TOUCH3,
        TOUCHn, 3), GPIO3)); _for_each_inner!(((ADC1_CH2, ADCn_CHm, 1, 2), GPIO3));
        _for_each_inner!(((TOUCH4, TOUCHn, 4), GPIO4)); _for_each_inner!(((ADC1_CH3,
        ADCn_CHm, 1, 3), GPIO4)); _for_each_inner!(((TOUCH5, TOUCHn, 5), GPIO5));
        _for_each_inner!(((ADC1_CH4, ADCn_CHm, 1, 4), GPIO5)); _for_each_inner!(((TOUCH6,
        TOUCHn, 6), GPIO6)); _for_each_inner!(((ADC1_CH5, ADCn_CHm, 1, 5), GPIO6));
        _for_each_inner!(((TOUCH7, TOUCHn, 7), GPIO7)); _for_each_inner!(((ADC1_CH6,
        ADCn_CHm, 1, 6), GPIO7)); _for_each_inner!(((TOUCH8, TOUCHn, 8), GPIO8));
        _for_each_inner!(((ADC1_CH7, ADCn_CHm, 1, 7), GPIO8)); _for_each_inner!(((TOUCH9,
        TOUCHn, 9), GPIO9)); _for_each_inner!(((ADC1_CH8, ADCn_CHm, 1, 8), GPIO9));
        _for_each_inner!(((TOUCH10, TOUCHn, 10), GPIO10)); _for_each_inner!(((ADC1_CH9,
        ADCn_CHm, 1, 9), GPIO10)); _for_each_inner!(((TOUCH11, TOUCHn, 11), GPIO11));
        _for_each_inner!(((ADC2_CH0, ADCn_CHm, 2, 0), GPIO11));
        _for_each_inner!(((TOUCH12, TOUCHn, 12), GPIO12)); _for_each_inner!(((ADC2_CH1,
        ADCn_CHm, 2, 1), GPIO12)); _for_each_inner!(((TOUCH13, TOUCHn, 13), GPIO13));
        _for_each_inner!(((ADC2_CH2, ADCn_CHm, 2, 2), GPIO13));
        _for_each_inner!(((TOUCH14, TOUCHn, 14), GPIO14)); _for_each_inner!(((ADC2_CH3,
        ADCn_CHm, 2, 3), GPIO14)); _for_each_inner!(((ADC2_CH4, ADCn_CHm, 2, 4),
        GPIO15)); _for_each_inner!(((ADC2_CH5, ADCn_CHm, 2, 5), GPIO16));
        _for_each_inner!(((ADC2_CH6, ADCn_CHm, 2, 6), GPIO17));
        _for_each_inner!(((ADC2_CH7, ADCn_CHm, 2, 7), GPIO18));
        _for_each_inner!(((ADC2_CH8, ADCn_CHm, 2, 8), GPIO19));
        _for_each_inner!(((ADC2_CH9, ADCn_CHm, 2, 9), GPIO20));
        _for_each_inner!((all(TOUCH1, GPIO1), (ADC1_CH0, GPIO1), (TOUCH2, GPIO2),
        (ADC1_CH1, GPIO2), (TOUCH3, GPIO3), (ADC1_CH2, GPIO3), (TOUCH4, GPIO4),
        (ADC1_CH3, GPIO4), (TOUCH5, GPIO5), (ADC1_CH4, GPIO5), (TOUCH6, GPIO6),
        (ADC1_CH5, GPIO6), (TOUCH7, GPIO7), (ADC1_CH6, GPIO7), (TOUCH8, GPIO8),
        (ADC1_CH7, GPIO8), (TOUCH9, GPIO9), (ADC1_CH8, GPIO9), (TOUCH10, GPIO10),
        (ADC1_CH9, GPIO10), (TOUCH11, GPIO11), (ADC2_CH0, GPIO11), (TOUCH12, GPIO12),
        (ADC2_CH1, GPIO12), (TOUCH13, GPIO13), (ADC2_CH2, GPIO13), (TOUCH14, GPIO14),
        (ADC2_CH3, GPIO14), (XTAL_32K_P, GPIO15), (ADC2_CH4, GPIO15), (XTAL_32K_N,
        GPIO16), (ADC2_CH5, GPIO16), (ADC2_CH6, GPIO17), (ADC2_CH7, GPIO18), (USB_DM,
        GPIO19), (ADC2_CH8, GPIO19), (USB_DP, GPIO20), (ADC2_CH9, GPIO20)));
        _for_each_inner!((all_expanded((TOUCH1, TOUCHn, 1), GPIO1), ((ADC1_CH0, ADCn_CHm,
        1, 0), GPIO1), ((TOUCH2, TOUCHn, 2), GPIO2), ((ADC1_CH1, ADCn_CHm, 1, 1), GPIO2),
        ((TOUCH3, TOUCHn, 3), GPIO3), ((ADC1_CH2, ADCn_CHm, 1, 2), GPIO3), ((TOUCH4,
        TOUCHn, 4), GPIO4), ((ADC1_CH3, ADCn_CHm, 1, 3), GPIO4), ((TOUCH5, TOUCHn, 5),
        GPIO5), ((ADC1_CH4, ADCn_CHm, 1, 4), GPIO5), ((TOUCH6, TOUCHn, 6), GPIO6),
        ((ADC1_CH5, ADCn_CHm, 1, 5), GPIO6), ((TOUCH7, TOUCHn, 7), GPIO7), ((ADC1_CH6,
        ADCn_CHm, 1, 6), GPIO7), ((TOUCH8, TOUCHn, 8), GPIO8), ((ADC1_CH7, ADCn_CHm, 1,
        7), GPIO8), ((TOUCH9, TOUCHn, 9), GPIO9), ((ADC1_CH8, ADCn_CHm, 1, 8), GPIO9),
        ((TOUCH10, TOUCHn, 10), GPIO10), ((ADC1_CH9, ADCn_CHm, 1, 9), GPIO10), ((TOUCH11,
        TOUCHn, 11), GPIO11), ((ADC2_CH0, ADCn_CHm, 2, 0), GPIO11), ((TOUCH12, TOUCHn,
        12), GPIO12), ((ADC2_CH1, ADCn_CHm, 2, 1), GPIO12), ((TOUCH13, TOUCHn, 13),
        GPIO13), ((ADC2_CH2, ADCn_CHm, 2, 2), GPIO13), ((TOUCH14, TOUCHn, 14), GPIO14),
        ((ADC2_CH3, ADCn_CHm, 2, 3), GPIO14), ((ADC2_CH4, ADCn_CHm, 2, 4), GPIO15),
        ((ADC2_CH5, ADCn_CHm, 2, 5), GPIO16), ((ADC2_CH6, ADCn_CHm, 2, 6), GPIO17),
        ((ADC2_CH7, ADCn_CHm, 2, 7), GPIO18), ((ADC2_CH8, ADCn_CHm, 2, 8), GPIO19),
        ((ADC2_CH9, ADCn_CHm, 2, 9), GPIO20)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((RTC_GPIO0, GPIO0)); _for_each_inner!((SAR_I2C_SCL_0, GPIO0));
        _for_each_inner!((RTC_GPIO1, GPIO1)); _for_each_inner!((SAR_I2C_SDA_0, GPIO1));
        _for_each_inner!((RTC_GPIO2, GPIO2)); _for_each_inner!((SAR_I2C_SCL_1, GPIO2));
        _for_each_inner!((RTC_GPIO3, GPIO3)); _for_each_inner!((SAR_I2C_SDA_1, GPIO3));
        _for_each_inner!((RTC_GPIO4, GPIO4)); _for_each_inner!((RTC_GPIO5, GPIO5));
        _for_each_inner!((RTC_GPIO6, GPIO6)); _for_each_inner!((RTC_GPIO7, GPIO7));
        _for_each_inner!((RTC_GPIO8, GPIO8)); _for_each_inner!((RTC_GPIO9, GPIO9));
        _for_each_inner!((RTC_GPIO10, GPIO10)); _for_each_inner!((RTC_GPIO11, GPIO11));
        _for_each_inner!((RTC_GPIO12, GPIO12)); _for_each_inner!((RTC_GPIO13, GPIO13));
        _for_each_inner!((RTC_GPIO14, GPIO14)); _for_each_inner!((RTC_GPIO15, GPIO15));
        _for_each_inner!((RTC_GPIO16, GPIO16)); _for_each_inner!((RTC_GPIO17, GPIO17));
        _for_each_inner!((RTC_GPIO18, GPIO18)); _for_each_inner!((RTC_GPIO19, GPIO19));
        _for_each_inner!((RTC_GPIO20, GPIO20)); _for_each_inner!((RTC_GPIO21, GPIO21));
        _for_each_inner!(((RTC_GPIO0, RTC_GPIOn, 0), GPIO0));
        _for_each_inner!(((SAR_I2C_SCL_0, SAR_I2C_SCL_n, 0), GPIO0));
        _for_each_inner!(((RTC_GPIO1, RTC_GPIOn, 1), GPIO1));
        _for_each_inner!(((SAR_I2C_SDA_0, SAR_I2C_SDA_n, 0), GPIO1));
        _for_each_inner!(((RTC_GPIO2, RTC_GPIOn, 2), GPIO2));
        _for_each_inner!(((SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1), GPIO2));
        _for_each_inner!(((RTC_GPIO3, RTC_GPIOn, 3), GPIO3));
        _for_each_inner!(((SAR_I2C_SDA_1, SAR_I2C_SDA_n, 1), GPIO3));
        _for_each_inner!(((RTC_GPIO4, RTC_GPIOn, 4), GPIO4));
        _for_each_inner!(((RTC_GPIO5, RTC_GPIOn, 5), GPIO5));
        _for_each_inner!(((RTC_GPIO6, RTC_GPIOn, 6), GPIO6));
        _for_each_inner!(((RTC_GPIO7, RTC_GPIOn, 7), GPIO7));
        _for_each_inner!(((RTC_GPIO8, RTC_GPIOn, 8), GPIO8));
        _for_each_inner!(((RTC_GPIO9, RTC_GPIOn, 9), GPIO9));
        _for_each_inner!(((RTC_GPIO10, RTC_GPIOn, 10), GPIO10));
        _for_each_inner!(((RTC_GPIO11, RTC_GPIOn, 11), GPIO11));
        _for_each_inner!(((RTC_GPIO12, RTC_GPIOn, 12), GPIO12));
        _for_each_inner!(((RTC_GPIO13, RTC_GPIOn, 13), GPIO13));
        _for_each_inner!(((RTC_GPIO14, RTC_GPIOn, 14), GPIO14));
        _for_each_inner!(((RTC_GPIO15, RTC_GPIOn, 15), GPIO15));
        _for_each_inner!(((RTC_GPIO16, RTC_GPIOn, 16), GPIO16));
        _for_each_inner!(((RTC_GPIO17, RTC_GPIOn, 17), GPIO17));
        _for_each_inner!(((RTC_GPIO18, RTC_GPIOn, 18), GPIO18));
        _for_each_inner!(((RTC_GPIO19, RTC_GPIOn, 19), GPIO19));
        _for_each_inner!(((RTC_GPIO20, RTC_GPIOn, 20), GPIO20));
        _for_each_inner!(((RTC_GPIO21, RTC_GPIOn, 21), GPIO21));
        _for_each_inner!((all(RTC_GPIO0, GPIO0), (SAR_I2C_SCL_0, GPIO0), (RTC_GPIO1,
        GPIO1), (SAR_I2C_SDA_0, GPIO1), (RTC_GPIO2, GPIO2), (SAR_I2C_SCL_1, GPIO2),
        (RTC_GPIO3, GPIO3), (SAR_I2C_SDA_1, GPIO3), (RTC_GPIO4, GPIO4), (RTC_GPIO5,
        GPIO5), (RTC_GPIO6, GPIO6), (RTC_GPIO7, GPIO7), (RTC_GPIO8, GPIO8), (RTC_GPIO9,
        GPIO9), (RTC_GPIO10, GPIO10), (RTC_GPIO11, GPIO11), (RTC_GPIO12, GPIO12),
        (RTC_GPIO13, GPIO13), (RTC_GPIO14, GPIO14), (RTC_GPIO15, GPIO15), (RTC_GPIO16,
        GPIO16), (RTC_GPIO17, GPIO17), (RTC_GPIO18, GPIO18), (RTC_GPIO19, GPIO19),
        (RTC_GPIO20, GPIO20), (RTC_GPIO21, GPIO21)));
        _for_each_inner!((all_expanded((RTC_GPIO0, RTC_GPIOn, 0), GPIO0),
        ((SAR_I2C_SCL_0, SAR_I2C_SCL_n, 0), GPIO0), ((RTC_GPIO1, RTC_GPIOn, 1), GPIO1),
        ((SAR_I2C_SDA_0, SAR_I2C_SDA_n, 0), GPIO1), ((RTC_GPIO2, RTC_GPIOn, 2), GPIO2),
        ((SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1), GPIO2), ((RTC_GPIO3, RTC_GPIOn, 3), GPIO3),
        ((SAR_I2C_SDA_1, SAR_I2C_SDA_n, 1), GPIO3), ((RTC_GPIO4, RTC_GPIOn, 4), GPIO4),
        ((RTC_GPIO5, RTC_GPIOn, 5), GPIO5), ((RTC_GPIO6, RTC_GPIOn, 6), GPIO6),
        ((RTC_GPIO7, RTC_GPIOn, 7), GPIO7), ((RTC_GPIO8, RTC_GPIOn, 8), GPIO8),
        ((RTC_GPIO9, RTC_GPIOn, 9), GPIO9), ((RTC_GPIO10, RTC_GPIOn, 10), GPIO10),
        ((RTC_GPIO11, RTC_GPIOn, 11), GPIO11), ((RTC_GPIO12, RTC_GPIOn, 12), GPIO12),
        ((RTC_GPIO13, RTC_GPIOn, 13), GPIO13), ((RTC_GPIO14, RTC_GPIOn, 14), GPIO14),
        ((RTC_GPIO15, RTC_GPIOn, 15), GPIO15), ((RTC_GPIO16, RTC_GPIOn, 16), GPIO16),
        ((RTC_GPIO17, RTC_GPIOn, 17), GPIO17), ((RTC_GPIO18, RTC_GPIOn, 18), GPIO18),
        ((RTC_GPIO19, RTC_GPIOn, 19), GPIO19), ((RTC_GPIO20, RTC_GPIOn, 20), GPIO20),
        ((RTC_GPIO21, RTC_GPIOn, 21), GPIO21)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            SPIQ                    = 0,
            SPID                    = 1,
            SPIHD                   = 2,
            SPIWP                   = 3,
            SPID4                   = 7,
            SPID5                   = 8,
            SPID6                   = 9,
            SPID7                   = 10,
            SPIDQS                  = 11,
            U0RXD                   = 12,
            U0CTS                   = 13,
            U0DSR                   = 14,
            U1RXD                   = 15,
            U1CTS                   = 16,
            U1DSR                   = 17,
            U2RXD                   = 18,
            U2CTS                   = 19,
            U2DSR                   = 20,
            I2S1_MCLK               = 21,
            I2S0O_BCK               = 22,
            I2S0_MCLK               = 23,
            I2S0O_WS                = 24,
            I2S0I_SD                = 25,
            I2S0I_BCK               = 26,
            I2S0I_WS                = 27,
            I2S1O_BCK               = 28,
            I2S1O_WS                = 29,
            I2S1I_SD                = 30,
            I2S1I_BCK               = 31,
            I2S1I_WS                = 32,
            PCNT0_SIG_CH0           = 33,
            PCNT0_SIG_CH1           = 34,
            PCNT0_CTRL_CH0          = 35,
            PCNT0_CTRL_CH1          = 36,
            PCNT1_SIG_CH0           = 37,
            PCNT1_SIG_CH1           = 38,
            PCNT1_CTRL_CH0          = 39,
            PCNT1_CTRL_CH1          = 40,
            PCNT2_SIG_CH0           = 41,
            PCNT2_SIG_CH1           = 42,
            PCNT2_CTRL_CH0          = 43,
            PCNT2_CTRL_CH1          = 44,
            PCNT3_SIG_CH0           = 45,
            PCNT3_SIG_CH1           = 46,
            PCNT3_CTRL_CH0          = 47,
            PCNT3_CTRL_CH1          = 48,
            I2S0I_SD1               = 51,
            I2S0I_SD2               = 52,
            I2S0I_SD3               = 53,
            USB_EXTPHY_VP           = 55,
            USB_EXTPHY_VM           = 56,
            USB_EXTPHY_RCV          = 57,
            USB_OTG_IDDIG           = 58,
            USB_OTG_AVALID          = 59,
            USB_SRP_BVALID          = 60,
            USB_OTG_VBUSVALID       = 61,
            USB_SRP_SESSEND         = 62,
            SPI3_CLK                = 66,
            SPI3_Q                  = 67,
            SPI3_D                  = 68,
            SPI3_HD                 = 69,
            SPI3_WP                 = 70,
            SPI3_CS0                = 71,
            RMT_SIG_0               = 81,
            RMT_SIG_1               = 82,
            RMT_SIG_2               = 83,
            RMT_SIG_3               = 84,
            I2CEXT0_SCL             = 89,
            I2CEXT0_SDA             = 90,
            I2CEXT1_SCL             = 91,
            I2CEXT1_SDA             = 92,
            FSPICLK                 = 101,
            FSPIQ                   = 102,
            FSPID                   = 103,
            FSPIHD                  = 104,
            FSPIWP                  = 105,
            FSPIIO4                 = 106,
            FSPIIO5                 = 107,
            FSPIIO6                 = 108,
            FSPIIO7                 = 109,
            FSPICS0                 = 110,
            TWAI_RX                 = 116,
            SUBSPIQ                 = 120,
            SUBSPID                 = 121,
            SUBSPIHD                = 122,
            SUBSPIWP                = 123,
            CAM_DATA_0              = 133,
            CAM_DATA_1              = 134,
            CAM_DATA_2              = 135,
            CAM_DATA_3              = 136,
            CAM_DATA_4              = 137,
            CAM_DATA_5              = 138,
            CAM_DATA_6              = 139,
            CAM_DATA_7              = 140,
            CAM_DATA_8              = 141,
            CAM_DATA_9              = 142,
            CAM_DATA_10             = 143,
            CAM_DATA_11             = 144,
            CAM_DATA_12             = 145,
            CAM_DATA_13             = 146,
            CAM_DATA_14             = 147,
            CAM_DATA_15             = 148,
            CAM_PCLK                = 149,
            CAM_H_ENABLE            = 150,
            CAM_H_SYNC              = 151,
            CAM_V_SYNC              = 152,
            SUBSPID4                = 155,
            SUBSPID5                = 156,
            SUBSPID6                = 157,
            SUBSPID7                = 158,
            SUBSPIDQS               = 159,
            PWM0_SYNC0              = 160,
            PWM0_SYNC1              = 161,
            PWM0_SYNC2              = 162,
            PWM0_F0                 = 163,
            PWM0_F1                 = 164,
            PWM0_F2                 = 165,
            PWM0_CAP0               = 166,
            PWM0_CAP1               = 167,
            PWM0_CAP2               = 168,
            PWM1_SYNC0              = 169,
            PWM1_SYNC1              = 170,
            PWM1_SYNC2              = 171,
            PWM1_F0                 = 172,
            PWM1_F1                 = 173,
            PWM1_F2                 = 174,
            PWM1_CAP0               = 175,
            PWM1_CAP1               = 176,
            PWM1_CAP2               = 177,
            SDHOST_CCMD_IN_1        = 178,
            SDHOST_CCMD_IN_2        = 179,
            SDHOST_CDATA_IN_10      = 180,
            SDHOST_CDATA_IN_11      = 181,
            SDHOST_CDATA_IN_12      = 182,
            SDHOST_CDATA_IN_13      = 183,
            SDHOST_CDATA_IN_14      = 184,
            SDHOST_CDATA_IN_15      = 185,
            SDHOST_CDATA_IN_16      = 186,
            SDHOST_CDATA_IN_17      = 187,
            SDHOST_DATA_STROBE_1    = 192,
            SDHOST_DATA_STROBE_2    = 193,
            SDHOST_CARD_DETECT_N_1  = 194,
            SDHOST_CARD_DETECT_N_2  = 195,
            SDHOST_CARD_WRITE_PRT_1 = 196,
            SDHOST_CARD_WRITE_PRT_2 = 197,
            SDHOST_CARD_INT_N_1     = 198,
            SDHOST_CARD_INT_N_2     = 199,
            SDHOST_CDATA_IN_20      = 213,
            SDHOST_CDATA_IN_21      = 214,
            SDHOST_CDATA_IN_22      = 215,
            SDHOST_CDATA_IN_23      = 216,
            SDHOST_CDATA_IN_24      = 217,
            SDHOST_CDATA_IN_25      = 218,
            SDHOST_CDATA_IN_26      = 219,
            SDHOST_CDATA_IN_27      = 220,
            PRO_ALONEGPIO_IN0       = 221,
            PRO_ALONEGPIO_IN1       = 222,
            PRO_ALONEGPIO_IN2       = 223,
            PRO_ALONEGPIO_IN3       = 224,
            PRO_ALONEGPIO_IN4       = 225,
            PRO_ALONEGPIO_IN5       = 226,
            PRO_ALONEGPIO_IN6       = 227,
            PRO_ALONEGPIO_IN7       = 228,
            USB_JTAG_TDO_BRIDGE     = 251,
            CORE1_GPIO_IN3          = 252,
            CORE1_GPIO_IN4          = 253,
            CORE1_GPIO_IN5          = 254,
            CORE1_GPIO_IN6          = 255,
            SPIIO4,
            SPIIO5,
            SPIIO6,
            SPIIO7,
            MTDI,
            MTCK,
            MTMS,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            SPIQ                       = 0,
            SPID                       = 1,
            SPIHD                      = 2,
            SPIWP                      = 3,
            SPICLK                     = 4,
            SPICS0                     = 5,
            SPICS1                     = 6,
            SPID4                      = 7,
            SPID5                      = 8,
            SPID6                      = 9,
            SPID7                      = 10,
            SPIDQS                     = 11,
            U0TXD                      = 12,
            U0RTS                      = 13,
            U0DTR                      = 14,
            U1TXD                      = 15,
            U1RTS                      = 16,
            U1DTR                      = 17,
            U2TXD                      = 18,
            U2RTS                      = 19,
            U2DTR                      = 20,
            I2S1_MCLK                  = 21,
            I2S0O_BCK                  = 22,
            I2S0_MCLK                  = 23,
            I2S0O_WS                   = 24,
            I2S0O_SD                   = 25,
            I2S0I_BCK                  = 26,
            I2S0I_WS                   = 27,
            I2S1O_BCK                  = 28,
            I2S1O_WS                   = 29,
            I2S1O_SD                   = 30,
            I2S1I_BCK                  = 31,
            I2S1I_WS                   = 32,
            USB_EXTPHY_OEN             = 55,
            USB_EXTPHY_VPO             = 57,
            USB_EXTPHY_VMO             = 58,
            SPI3_CLK                   = 66,
            SPI3_Q                     = 67,
            SPI3_D                     = 68,
            SPI3_HD                    = 69,
            SPI3_WP                    = 70,
            SPI3_CS0                   = 71,
            SPI3_CS1                   = 72,
            LEDC_LS_SIG0               = 73,
            LEDC_LS_SIG1               = 74,
            LEDC_LS_SIG2               = 75,
            LEDC_LS_SIG3               = 76,
            LEDC_LS_SIG4               = 77,
            LEDC_LS_SIG5               = 78,
            LEDC_LS_SIG6               = 79,
            LEDC_LS_SIG7               = 80,
            RMT_SIG_0                  = 81,
            RMT_SIG_1                  = 82,
            RMT_SIG_2                  = 83,
            RMT_SIG_3                  = 84,
            I2CEXT0_SCL                = 89,
            I2CEXT0_SDA                = 90,
            I2CEXT1_SCL                = 91,
            I2CEXT1_SDA                = 92,
            GPIO_SD0                   = 93,
            GPIO_SD1                   = 94,
            GPIO_SD2                   = 95,
            GPIO_SD3                   = 96,
            GPIO_SD4                   = 97,
            GPIO_SD5                   = 98,
            GPIO_SD6                   = 99,
            GPIO_SD7                   = 100,
            FSPICLK                    = 101,
            FSPIQ                      = 102,
            FSPID                      = 103,
            FSPIHD                     = 104,
            FSPIWP                     = 105,
            FSPIIO4                    = 106,
            FSPIIO5                    = 107,
            FSPIIO6                    = 108,
            FSPIIO7                    = 109,
            FSPICS0                    = 110,
            FSPICS1                    = 111,
            FSPICS2                    = 112,
            FSPICS3                    = 113,
            FSPICS4                    = 114,
            FSPICS5                    = 115,
            TWAI_TX                    = 116,
            SUBSPICLK                  = 119,
            SUBSPIQ                    = 120,
            SUBSPID                    = 121,
            SUBSPIHD                   = 122,
            SUBSPIWP                   = 123,
            SUBSPICS0                  = 124,
            SUBSPICS1                  = 125,
            FSPIDQS                    = 126,
            SPI3_CS2                   = 127,
            I2S0O_SD1                  = 128,
            LCD_CS                     = 132,
            LCD_DATA_0                 = 133,
            LCD_DATA_1                 = 134,
            LCD_DATA_2                 = 135,
            LCD_DATA_3                 = 136,
            LCD_DATA_4                 = 137,
            LCD_DATA_5                 = 138,
            LCD_DATA_6                 = 139,
            LCD_DATA_7                 = 140,
            LCD_DATA_8                 = 141,
            LCD_DATA_9                 = 142,
            LCD_DATA_10                = 143,
            LCD_DATA_11                = 144,
            LCD_DATA_12                = 145,
            LCD_DATA_13                = 146,
            LCD_DATA_14                = 147,
            LCD_DATA_15                = 148,
            CAM_CLK                    = 149,
            LCD_H_ENABLE               = 150,
            LCD_H_SYNC                 = 151,
            LCD_V_SYNC                 = 152,
            LCD_DC                     = 153,
            LCD_PCLK                   = 154,
            SUBSPID4                   = 155,
            SUBSPID5                   = 156,
            SUBSPID6                   = 157,
            SUBSPID7                   = 158,
            SUBSPIDQS                  = 159,
            PWM0_0A                    = 160,
            PWM0_0B                    = 161,
            PWM0_1A                    = 162,
            PWM0_1B                    = 163,
            PWM0_2A                    = 164,
            PWM0_2B                    = 165,
            PWM1_0A                    = 166,
            PWM1_0B                    = 167,
            PWM1_1A                    = 168,
            PWM1_1B                    = 169,
            PWM1_2A                    = 170,
            PWM1_2B                    = 171,
            SDHOST_CCLK_OUT_1          = 172,
            SDHOST_CCLK_OUT_2          = 173,
            SDHOST_RST_N_1             = 174,
            SDHOST_RST_N_2             = 175,
            SDHOST_CCMD_OD_PULLUP_EN_N = 176,
            SDIO_TOHOST_INT            = 177,
            SDHOST_CCMD_OUT_1          = 178,
            SDHOST_CCMD_OUT_2          = 179,
            SDHOST_CDATA_OUT_10        = 180,
            SDHOST_CDATA_OUT_11        = 181,
            SDHOST_CDATA_OUT_12        = 182,
            SDHOST_CDATA_OUT_13        = 183,
            SDHOST_CDATA_OUT_14        = 184,
            SDHOST_CDATA_OUT_15        = 185,
            SDHOST_CDATA_OUT_16        = 186,
            SDHOST_CDATA_OUT_17        = 187,
            SDHOST_CDATA_OUT_20        = 213,
            SDHOST_CDATA_OUT_21        = 214,
            SDHOST_CDATA_OUT_22        = 215,
            SDHOST_CDATA_OUT_23        = 216,
            SDHOST_CDATA_OUT_24        = 217,
            SDHOST_CDATA_OUT_25        = 218,
            SDHOST_CDATA_OUT_26        = 219,
            SDHOST_CDATA_OUT_27        = 220,
            PRO_ALONEGPIO_OUT0         = 221,
            PRO_ALONEGPIO_OUT1         = 222,
            PRO_ALONEGPIO_OUT2         = 223,
            PRO_ALONEGPIO_OUT3         = 224,
            PRO_ALONEGPIO_OUT4         = 225,
            PRO_ALONEGPIO_OUT5         = 226,
            PRO_ALONEGPIO_OUT6         = 227,
            PRO_ALONEGPIO_OUT7         = 228,
            USB_JTAG_TRST              = 251,
            CORE1_GPIO_OUT3            = 252,
            CORE1_GPIO_OUT4            = 253,
            CORE1_GPIO_OUT5            = 254,
            CORE1_GPIO_OUT6            = 255,
            GPIO                       = 256,
            SPIIO4,
            SPIIO5,
            SPIIO6,
            SPIIO7,
            CLK_OUT1,
            CLK_OUT2,
            CLK_OUT3,
            SPICLK_P_DIFF,
            SPICLK_N_DIFF,
            SUBSPICLK_P_DIFF,
            SUBSPICLK_N_DIFF,
            MTDO,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO {
            crate::peripherals::IO_MUX::regs().gpio(gpio_num as usize)
        }
    };
}
