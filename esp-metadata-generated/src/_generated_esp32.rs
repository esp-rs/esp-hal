// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32"
    };
    ("arch") => {
        "xtensa"
    };
    ("cores") => {
        2
    };
    ("cores", str) => {
        stringify!(2)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf"
    };
    ("soc.cpu_has_csr_pc") => {
        false
    };
    ("soc.cpu_has_prv_mode") => {
        false
    };
    ("soc.ref_tick_hz") => {
        1000000
    };
    ("soc.ref_tick_hz", str) => {
        stringify!(1000000)
    };
    ("soc.rc_fast_clk_default") => {
        8500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(8500000)
    };
    ("soc.rc_slow_clock") => {
        150000
    };
    ("soc.rc_slow_clock", str) => {
        stringify!(150000)
    };
    ("aes.dma") => {
        false
    };
    ("aes.has_split_text_registers") => {
        false
    };
    ("aes.endianness_configurable") => {
        true
    };
    ("gpio.has_bank_1") => {
        true
    };
    ("gpio.gpio_function") => {
        2
    };
    ("gpio.gpio_function", str) => {
        stringify!(2)
    };
    ("gpio.constant_0_input") => {
        48
    };
    ("gpio.constant_0_input", str) => {
        stringify!(48)
    };
    ("gpio.constant_1_input") => {
        56
    };
    ("gpio.constant_1_input", str) => {
        stringify!(56)
    };
    ("gpio.remap_iomux_pin_registers") => {
        true
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        206
    };
    ("gpio.input_signal_max", str) => {
        stringify!(206)
    };
    ("gpio.output_signal_max") => {
        256
    };
    ("gpio.output_signal_max", str) => {
        stringify!(256)
    };
    ("i2c_master.has_fsm_timeouts") => {
        false
    };
    ("i2c_master.has_hw_bus_clear") => {
        false
    };
    ("i2c_master.has_bus_timeout_enable") => {
        false
    };
    ("i2c_master.separate_filter_config_registers") => {
        true
    };
    ("i2c_master.can_estimate_nack_reason") => {
        false
    };
    ("i2c_master.has_conf_update") => {
        false
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        false
    };
    ("i2c_master.has_arbitration_en") => {
        false
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        false
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        false
    };
    ("i2c_master.i2c0_data_register_ahb_address") => {
        1610690588
    };
    ("i2c_master.i2c0_data_register_ahb_address", str) => {
        stringify!(1610690588)
    };
    ("i2c_master.max_bus_timeout") => {
        1048575
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(1048575)
    };
    ("i2c_master.ll_intr_mask") => {
        262143
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(262143)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("interrupts.status_registers") => {
        3
    };
    ("interrupts.status_registers", str) => {
        stringify!(3)
    };
    ("rmt.ram_start") => {
        1073047552
    };
    ("rmt.ram_start", str) => {
        stringify!(1073047552)
    };
    ("rmt.channel_ram_size") => {
        64
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(64)
    };
    ("rmt.has_tx_immediate_stop") => {
        false
    };
    ("rmt.has_tx_loop_count") => {
        false
    };
    ("rmt.has_tx_loop_auto_stop") => {
        false
    };
    ("rmt.has_tx_carrier_data_only") => {
        false
    };
    ("rmt.has_tx_sync") => {
        false
    };
    ("rmt.has_rx_wrap") => {
        false
    };
    ("rmt.has_rx_demodulation") => {
        false
    };
    ("rmt.has_dma") => {
        false
    };
    ("rmt.has_per_channel_clock") => {
        true
    };
    ("rng.apb_cycle_wait_num") => {
        16
    };
    ("rng.apb_cycle_wait_num", str) => {
        stringify!(16)
    };
    ("rsa.size_increment") => {
        512
    };
    ("rsa.size_increment", str) => {
        stringify!(512)
    };
    ("rsa.memory_size_bytes") => {
        512
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(512)
    };
    ("sha.dma") => {
        false
    };
    ("spi_master.has_octal") => {
        false
    };
    ("timergroup.timg_has_timer1") => {
        true
    };
    ("timergroup.timg_has_divcnt_rst") => {
        false
    };
    ("uart.ram_size") => {
        128
    };
    ("uart.ram_size", str) => {
        stringify!(128)
    };
    ("uart.peripheral_controls_mem_clk") => {
        false
    };
    ("wifi.has_wifi6") => {
        false
    };
    ("bt.controller") => {
        "btdm"
    };
    ("phy.combo_module") => {
        true
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, no_run
/// // XTAL_CLK
///
/// fn configure_xtal_clk_impl(_clocks: &mut ClockTree, _config: XtalClkConfig) {
///     todo!()
/// }
///
/// // PLL_CLK
///
/// fn enable_pll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_pll_clk_impl(_clocks: &mut ClockTree, _config: PllClkConfig) {
///     todo!()
/// }
///
/// // APLL_CLK
///
/// fn enable_apll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apll_clk_impl(_clocks: &mut ClockTree, _config: ApllClkConfig) {
///     todo!()
/// }
///
/// // RC_FAST_CLK
///
/// fn enable_rc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F160M_CLK
///
/// fn enable_pll_f160m_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // CPU_PLL_DIV_IN
///
/// fn enable_cpu_pll_div_in_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_pll_div_in_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<CpuPllDivInConfig>,
///     _new_selector: CpuPllDivInConfig,
/// ) {
///     todo!()
/// }
///
/// // CPU_PLL_DIV
///
/// fn enable_cpu_pll_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_pll_div_impl(_clocks: &mut ClockTree, _new_config: CpuPllDivConfig) {
///     todo!()
/// }
///
/// // SYSCON_PRE_DIV_IN
///
/// fn enable_syscon_pre_div_in_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_syscon_pre_div_in_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<SysconPreDivInConfig>,
///     _new_selector: SysconPreDivInConfig,
/// ) {
///     todo!()
/// }
///
/// // SYSCON_PRE_DIV
///
/// fn enable_syscon_pre_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_syscon_pre_div_impl(_clocks: &mut ClockTree, _new_config: SysconPreDivConfig) {
///     todo!()
/// }
///
/// // APB_CLK
///
/// fn enable_apb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apb_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<ApbClkConfig>,
///     _new_selector: ApbClkConfig,
/// ) {
///     todo!()
/// }
///
/// // REF_TICK
///
/// fn enable_ref_tick_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RefTickConfig>,
///     _new_selector: RefTickConfig,
/// ) {
///     todo!()
/// }
///
/// // REF_TICK_XTAL
///
/// fn enable_ref_tick_xtal_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_xtal_impl(_clocks: &mut ClockTree, _new_config: RefTickXtalConfig) {
///     todo!()
/// }
///
/// // REF_TICK_FOSC
///
/// fn enable_ref_tick_fosc_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_fosc_impl(_clocks: &mut ClockTree, _new_config: RefTickFoscConfig) {
///     todo!()
/// }
///
/// // REF_TICK_APLL
///
/// fn enable_ref_tick_apll_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_apll_impl(_clocks: &mut ClockTree, _new_config: RefTickApllConfig) {
///     todo!()
/// }
///
/// // REF_TICK_PLL
///
/// fn enable_ref_tick_pll_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_pll_impl(_clocks: &mut ClockTree, _new_config: RefTickPllConfig) {
///     todo!()
/// }
///
/// // CPU_CLK
///
/// fn configure_cpu_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<CpuClkConfig>,
///     _new_selector: CpuClkConfig,
/// ) {
///     todo!()
/// }
///
/// // APB_CLK_CPU_DIV2
///
/// fn enable_apb_clk_cpu_div2_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // APB_CLK_80M
///
/// fn enable_apb_clk_80m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL32K_CLK
///
/// fn enable_xtal32k_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_SLOW_CLK
///
/// fn enable_rc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_FAST_DIV_CLK
///
/// fn enable_rc_fast_div_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL_DIV_CLK
///
/// fn enable_xtal_div_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RTC_SLOW_CLK
///
/// fn enable_rtc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_rtc_slow_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RtcSlowClkConfig>,
///     _new_selector: RtcSlowClkConfig,
/// ) {
///     todo!()
/// }
///
/// // RTC_FAST_CLK
///
/// fn enable_rtc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_rtc_fast_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RtcFastClkConfig>,
///     _new_selector: RtcFastClkConfig,
/// ) {
///     todo!()
/// }
///
/// // MCPWM0_FUNCTION_CLOCK
///
/// fn enable_mcpwm0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mcpwm0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Mcpwm0FunctionClockConfig>,
///     _new_selector: Mcpwm0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // MCPWM1_FUNCTION_CLOCK
///
/// fn enable_mcpwm1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mcpwm1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Mcpwm0FunctionClockConfig>,
///     _new_selector: Mcpwm0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_CALIBRATION_CLOCK
///
/// fn enable_timg0_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_CALIBRATION_CLOCK
///
/// fn enable_timg1_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
/// ```
macro_rules! define_clock_tree_types {
    () => {
        /// Selects the output frequency of `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum XtalClkConfig {
            /// 26 MHz
            _26,
            /// 40 MHz
            _40,
        }
        impl XtalClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    XtalClkConfig::_26 => 26000000,
                    XtalClkConfig::_40 => 40000000,
                }
            }
        }
        /// Selects the output frequency of `PLL_CLK`. Depends on `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PllClkConfig {
            /// 320 MHz
            _320,
            /// 480 MHz
            _480,
        }
        impl PllClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    PllClkConfig::_320 => 320000000,
                    PllClkConfig::_480 => 480000000,
                }
            }
        }
        /// The target frequency of the `APLL_CLK` clock source. Depends on `PLL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct ApllClkConfig(u32);
        impl ApllClkConfig {
            /// Creates a new clock source configuration.
            ///
            /// # Panics
            ///
            /// Panics if the output frequency value is outside the
            /// valid range (16 MHz - 128 MHz).
            pub const fn new(frequency: u32) -> Self {
                ::core::assert!(
                    frequency >= 16000000u32 && frequency <= 128000000u32,
                    "`APLL_CLK` output frequency value must be between 16000000 and 128000000 \
                     (inclusive)."
                );
                Self(frequency)
            }
        }
        impl ApllClkConfig {
            pub fn value(&self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `CPU_PLL_DIV_IN` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuPllDivInConfig {
            /// Selects `PLL_CLK`.
            Pll,
            /// Selects `APLL_CLK`.
            Apll,
        }
        /// Configures the `CPU_PLL_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = CPU_PLL_DIV_IN / DIVISOR`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuPllDivConfig {
            /// Selects `DIVISOR = 2`.
            _2 = 2,
            /// Selects `DIVISOR = 4`.
            _4 = 4,
        }
        impl CpuPllDivConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    2 => CpuPllDivConfig::_2,
                    4 => CpuPllDivConfig::_4,
                    _ => ::core::panic!("Invalid CPU_PLL_DIV divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    CpuPllDivConfig::_2 => 2,
                    CpuPllDivConfig::_4 => 4,
                }
            }
        }
        /// The list of clock signals that the `SYSCON_PRE_DIV_IN` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SysconPreDivInConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
        }
        /// Configures the `SYSCON_PRE_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = SYSCON_PRE_DIV_IN / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct SysconPreDivConfig(u32);
        impl SysconPreDivConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 1023).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 1023u32,
                    "`SYSCON_PRE_DIV` divisor value must be between 0 and 1023 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `APB_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApbClkConfig {
            /// Selects `APB_CLK_80M`.
            Pll80m,
            /// Selects `APB_CLK_CPU_DIV2`.
            CpuDiv2,
            /// Selects `CPU_CLK`.
            Cpu,
        }
        /// The list of clock signals that the `REF_TICK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RefTickConfig {
            /// Selects `REF_TICK_PLL`.
            Pll,
            /// Selects `REF_TICK_APLL`.
            Apll,
            /// Selects `REF_TICK_XTAL`.
            Xtal,
            /// Selects `REF_TICK_FOSC`.
            Fosc,
        }
        /// Configures the `REF_TICK_XTAL` clock divider.
        ///
        /// The output is calculated as `OUTPUT = APB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct RefTickXtalConfig(u32);
        impl RefTickXtalConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`REF_TICK_XTAL` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `REF_TICK_FOSC` clock divider.
        ///
        /// The output is calculated as `OUTPUT = APB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct RefTickFoscConfig(u32);
        impl RefTickFoscConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`REF_TICK_FOSC` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `REF_TICK_APLL` clock divider.
        ///
        /// The output is calculated as `OUTPUT = APB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct RefTickApllConfig(u32);
        impl RefTickApllConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`REF_TICK_APLL` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `REF_TICK_PLL` clock divider.
        ///
        /// The output is calculated as `OUTPUT = APB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct RefTickPllConfig(u32);
        impl RefTickPllConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`REF_TICK_PLL` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `CPU_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuClkConfig {
            /// Selects `SYSCON_PRE_DIV`.
            Xtal,
            /// Selects `SYSCON_PRE_DIV`.
            RcFast,
            /// Selects `CPU_PLL_DIV`.
            Apll,
            /// Selects `CPU_PLL_DIV`.
            Pll,
        }
        /// The list of clock signals that the `RTC_SLOW_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RtcSlowClkConfig {
            /// Selects `XTAL32K_CLK`.
            Xtal,
            /// Selects `RC_SLOW_CLK`.
            RcSlow,
            /// Selects `RC_FAST_DIV_CLK`.
            RcFast,
        }
        /// The list of clock signals that the `RTC_FAST_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RtcFastClkConfig {
            /// Selects `XTAL_DIV_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            Rc,
        }
        /// The list of clock signals that the `MCPWM0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcpwm0FunctionClockConfig {
            #[default]
            /// Selects `PLL_F160M_CLK`.
            PllF160m,
        }
        /// The list of clock signals that the `TIMG0_CALIBRATION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0CalibrationClockConfig {
            #[default]
            /// Selects `RC_SLOW_CLK`.
            RcSlowClk,
            /// Selects `RC_FAST_DIV_CLK`.
            RcFastDivClk,
            /// Selects `XTAL32K_CLK`.
            Xtal32kClk,
        }
        /// Represents the device's clock tree.
        pub struct ClockTree {
            xtal_clk: Option<XtalClkConfig>,
            pll_clk: Option<PllClkConfig>,
            apll_clk: Option<ApllClkConfig>,
            cpu_pll_div_in: Option<CpuPllDivInConfig>,
            cpu_pll_div: Option<CpuPllDivConfig>,
            syscon_pre_div_in: Option<SysconPreDivInConfig>,
            syscon_pre_div: Option<SysconPreDivConfig>,
            apb_clk: Option<ApbClkConfig>,
            ref_tick: Option<RefTickConfig>,
            ref_tick_xtal: Option<RefTickXtalConfig>,
            ref_tick_fosc: Option<RefTickFoscConfig>,
            ref_tick_apll: Option<RefTickApllConfig>,
            ref_tick_pll: Option<RefTickPllConfig>,
            cpu_clk: Option<CpuClkConfig>,
            rtc_slow_clk: Option<RtcSlowClkConfig>,
            rtc_fast_clk: Option<RtcFastClkConfig>,
            mcpwm0_function_clock: Option<Mcpwm0FunctionClockConfig>,
            mcpwm1_function_clock: Option<Mcpwm0FunctionClockConfig>,
            timg0_calibration_clock: Option<Timg0CalibrationClockConfig>,
            timg1_calibration_clock: Option<Timg0CalibrationClockConfig>,
            pll_clk_refcount: u32,
            rc_fast_clk_refcount: u32,
            pll_f160m_clk_refcount: u32,
            apb_clk_refcount: u32,
            ref_tick_refcount: u32,
            xtal32k_clk_refcount: u32,
            rc_slow_clk_refcount: u32,
            rc_fast_div_clk_refcount: u32,
            rtc_slow_clk_refcount: u32,
            rtc_fast_clk_refcount: u32,
            mcpwm0_function_clock_refcount: u32,
            mcpwm1_function_clock_refcount: u32,
            timg0_calibration_clock_refcount: u32,
            timg1_calibration_clock_refcount: u32,
        }
        impl ClockTree {
            /// Locks the clock tree for exclusive access.
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
            /// Returns the current configuration of the XTAL_CLK clock tree node
            pub fn xtal_clk(&self) -> Option<XtalClkConfig> {
                self.xtal_clk
            }
            /// Returns the current configuration of the PLL_CLK clock tree node
            pub fn pll_clk(&self) -> Option<PllClkConfig> {
                self.pll_clk
            }
            /// Returns the current configuration of the APLL_CLK clock tree node
            pub fn apll_clk(&self) -> Option<ApllClkConfig> {
                self.apll_clk
            }
            /// Returns the current configuration of the CPU_PLL_DIV_IN clock tree node
            pub fn cpu_pll_div_in(&self) -> Option<CpuPllDivInConfig> {
                self.cpu_pll_div_in
            }
            /// Returns the current configuration of the CPU_PLL_DIV clock tree node
            pub fn cpu_pll_div(&self) -> Option<CpuPllDivConfig> {
                self.cpu_pll_div
            }
            /// Returns the current configuration of the SYSCON_PRE_DIV_IN clock tree node
            pub fn syscon_pre_div_in(&self) -> Option<SysconPreDivInConfig> {
                self.syscon_pre_div_in
            }
            /// Returns the current configuration of the SYSCON_PRE_DIV clock tree node
            pub fn syscon_pre_div(&self) -> Option<SysconPreDivConfig> {
                self.syscon_pre_div
            }
            /// Returns the current configuration of the APB_CLK clock tree node
            pub fn apb_clk(&self) -> Option<ApbClkConfig> {
                self.apb_clk
            }
            /// Returns the current configuration of the REF_TICK clock tree node
            pub fn ref_tick(&self) -> Option<RefTickConfig> {
                self.ref_tick
            }
            /// Returns the current configuration of the REF_TICK_XTAL clock tree node
            pub fn ref_tick_xtal(&self) -> Option<RefTickXtalConfig> {
                self.ref_tick_xtal
            }
            /// Returns the current configuration of the REF_TICK_FOSC clock tree node
            pub fn ref_tick_fosc(&self) -> Option<RefTickFoscConfig> {
                self.ref_tick_fosc
            }
            /// Returns the current configuration of the REF_TICK_APLL clock tree node
            pub fn ref_tick_apll(&self) -> Option<RefTickApllConfig> {
                self.ref_tick_apll
            }
            /// Returns the current configuration of the REF_TICK_PLL clock tree node
            pub fn ref_tick_pll(&self) -> Option<RefTickPllConfig> {
                self.ref_tick_pll
            }
            /// Returns the current configuration of the CPU_CLK clock tree node
            pub fn cpu_clk(&self) -> Option<CpuClkConfig> {
                self.cpu_clk
            }
            /// Returns the current configuration of the RTC_SLOW_CLK clock tree node
            pub fn rtc_slow_clk(&self) -> Option<RtcSlowClkConfig> {
                self.rtc_slow_clk
            }
            /// Returns the current configuration of the RTC_FAST_CLK clock tree node
            pub fn rtc_fast_clk(&self) -> Option<RtcFastClkConfig> {
                self.rtc_fast_clk
            }
            /// Returns the current configuration of the MCPWM0_FUNCTION_CLOCK clock tree node
            pub fn mcpwm0_function_clock(&self) -> Option<Mcpwm0FunctionClockConfig> {
                self.mcpwm0_function_clock
            }
            /// Returns the current configuration of the MCPWM1_FUNCTION_CLOCK clock tree node
            pub fn mcpwm1_function_clock(&self) -> Option<Mcpwm0FunctionClockConfig> {
                self.mcpwm1_function_clock
            }
            /// Returns the current configuration of the TIMG0_CALIBRATION_CLOCK clock tree node
            pub fn timg0_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg0_calibration_clock
            }
            /// Returns the current configuration of the TIMG1_CALIBRATION_CLOCK clock tree node
            pub fn timg1_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg1_calibration_clock
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {
                xtal_clk: None,
                pll_clk: None,
                apll_clk: None,
                cpu_pll_div_in: None,
                cpu_pll_div: None,
                syscon_pre_div_in: None,
                syscon_pre_div: None,
                apb_clk: None,
                ref_tick: None,
                ref_tick_xtal: None,
                ref_tick_fosc: None,
                ref_tick_apll: None,
                ref_tick_pll: None,
                cpu_clk: None,
                rtc_slow_clk: None,
                rtc_fast_clk: None,
                mcpwm0_function_clock: None,
                mcpwm1_function_clock: None,
                timg0_calibration_clock: None,
                timg1_calibration_clock: None,
                pll_clk_refcount: 0,
                rc_fast_clk_refcount: 0,
                pll_f160m_clk_refcount: 0,
                apb_clk_refcount: 0,
                ref_tick_refcount: 0,
                xtal32k_clk_refcount: 0,
                rc_slow_clk_refcount: 0,
                rc_fast_div_clk_refcount: 0,
                rtc_slow_clk_refcount: 0,
                rtc_fast_clk_refcount: 0,
                mcpwm0_function_clock_refcount: 0,
                mcpwm1_function_clock_refcount: 0,
                timg0_calibration_clock_refcount: 0,
                timg1_calibration_clock_refcount: 0,
            });
        pub fn configure_xtal_clk(clocks: &mut ClockTree, config: XtalClkConfig) {
            clocks.xtal_clk = Some(config);
            configure_xtal_clk_impl(clocks, config);
        }
        fn request_xtal_clk(_clocks: &mut ClockTree) {}
        fn release_xtal_clk(_clocks: &mut ClockTree) {}
        pub fn xtal_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.xtal_clk).value()
        }
        pub fn configure_pll_clk(clocks: &mut ClockTree, config: PllClkConfig) {
            if let Some(cpu_pll_div) = clocks.cpu_pll_div {
                assert!(!((config.value() == 480000000) && (cpu_pll_div.value() == 4)));
            }
            clocks.pll_clk = Some(config);
            configure_pll_clk_impl(clocks, config);
        }
        pub fn request_pll_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.pll_clk_refcount) {
                request_xtal_clk(clocks);
                enable_pll_clk_impl(clocks, true);
            }
        }
        pub fn release_pll_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.pll_clk_refcount) {
                enable_pll_clk_impl(clocks, false);
                release_xtal_clk(clocks);
            }
        }
        pub fn pll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.pll_clk).value()
        }
        pub fn configure_apll_clk(clocks: &mut ClockTree, config: ApllClkConfig) {
            clocks.apll_clk = Some(config);
            configure_apll_clk_impl(clocks, config);
        }
        pub fn request_apll_clk(clocks: &mut ClockTree) {
            request_pll_clk(clocks);
            enable_apll_clk_impl(clocks, true);
        }
        pub fn release_apll_clk(clocks: &mut ClockTree) {
            enable_apll_clk_impl(clocks, false);
            release_pll_clk(clocks);
        }
        pub fn apll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.apll_clk).value()
        }
        pub fn request_rc_fast_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.rc_fast_clk_refcount) {
                enable_rc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.rc_fast_clk_refcount) {
                enable_rc_fast_clk_impl(clocks, false);
            }
        }
        pub fn rc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            8000000
        }
        pub fn request_pll_f160m_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.pll_f160m_clk_refcount) {
                request_pll_clk(clocks);
                enable_pll_f160m_clk_impl(clocks, true);
            }
        }
        pub fn release_pll_f160m_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.pll_f160m_clk_refcount) {
                enable_pll_f160m_clk_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f160m_clk_frequency(clocks: &mut ClockTree) -> u32 {
            160000000
        }
        pub fn configure_cpu_pll_div_in(clocks: &mut ClockTree, new_selector: CpuPllDivInConfig) {
            let old_selector = clocks.cpu_pll_div_in.replace(new_selector);
            match new_selector {
                CpuPllDivInConfig::Pll => request_pll_clk(clocks),
                CpuPllDivInConfig::Apll => request_apll_clk(clocks),
            }
            configure_cpu_pll_div_in_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    CpuPllDivInConfig::Pll => release_pll_clk(clocks),
                    CpuPllDivInConfig::Apll => release_apll_clk(clocks),
                }
            }
        }
        pub fn request_cpu_pll_div_in(clocks: &mut ClockTree) {
            match unwrap!(clocks.cpu_pll_div_in) {
                CpuPllDivInConfig::Pll => request_pll_clk(clocks),
                CpuPllDivInConfig::Apll => request_apll_clk(clocks),
            }
            enable_cpu_pll_div_in_impl(clocks, true);
        }
        pub fn release_cpu_pll_div_in(clocks: &mut ClockTree) {
            enable_cpu_pll_div_in_impl(clocks, false);
            match unwrap!(clocks.cpu_pll_div_in) {
                CpuPllDivInConfig::Pll => release_pll_clk(clocks),
                CpuPllDivInConfig::Apll => release_apll_clk(clocks),
            }
        }
        pub fn cpu_pll_div_in_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.cpu_pll_div_in) {
                CpuPllDivInConfig::Pll => pll_clk_frequency(clocks),
                CpuPllDivInConfig::Apll => apll_clk_frequency(clocks),
            }
        }
        pub fn configure_cpu_pll_div(clocks: &mut ClockTree, config: CpuPllDivConfig) {
            if let Some(pll_clk) = clocks.pll_clk {
                assert!(!((pll_clk.value() == 480000000) && (config.value() == 4)));
            }
            clocks.cpu_pll_div = Some(config);
            configure_cpu_pll_div_impl(clocks, config);
        }
        pub fn request_cpu_pll_div(clocks: &mut ClockTree) {
            request_cpu_pll_div_in(clocks);
            enable_cpu_pll_div_impl(clocks, true);
        }
        pub fn release_cpu_pll_div(clocks: &mut ClockTree) {
            enable_cpu_pll_div_impl(clocks, false);
            release_cpu_pll_div_in(clocks);
        }
        pub fn cpu_pll_div_frequency(clocks: &mut ClockTree) -> u32 {
            (cpu_pll_div_in_frequency(clocks) / unwrap!(clocks.cpu_pll_div).value())
        }
        pub fn configure_syscon_pre_div_in(
            clocks: &mut ClockTree,
            new_selector: SysconPreDivInConfig,
        ) {
            let old_selector = clocks.syscon_pre_div_in.replace(new_selector);
            match new_selector {
                SysconPreDivInConfig::Xtal => request_xtal_clk(clocks),
                SysconPreDivInConfig::RcFast => request_rc_fast_clk(clocks),
            }
            configure_syscon_pre_div_in_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    SysconPreDivInConfig::Xtal => release_xtal_clk(clocks),
                    SysconPreDivInConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn request_syscon_pre_div_in(clocks: &mut ClockTree) {
            match unwrap!(clocks.syscon_pre_div_in) {
                SysconPreDivInConfig::Xtal => request_xtal_clk(clocks),
                SysconPreDivInConfig::RcFast => request_rc_fast_clk(clocks),
            }
            enable_syscon_pre_div_in_impl(clocks, true);
        }
        pub fn release_syscon_pre_div_in(clocks: &mut ClockTree) {
            enable_syscon_pre_div_in_impl(clocks, false);
            match unwrap!(clocks.syscon_pre_div_in) {
                SysconPreDivInConfig::Xtal => release_xtal_clk(clocks),
                SysconPreDivInConfig::RcFast => release_rc_fast_clk(clocks),
            }
        }
        pub fn syscon_pre_div_in_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.syscon_pre_div_in) {
                SysconPreDivInConfig::Xtal => xtal_clk_frequency(clocks),
                SysconPreDivInConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_syscon_pre_div(clocks: &mut ClockTree, config: SysconPreDivConfig) {
            clocks.syscon_pre_div = Some(config);
            configure_syscon_pre_div_impl(clocks, config);
        }
        pub fn request_syscon_pre_div(clocks: &mut ClockTree) {
            request_syscon_pre_div_in(clocks);
            enable_syscon_pre_div_impl(clocks, true);
        }
        pub fn release_syscon_pre_div(clocks: &mut ClockTree) {
            enable_syscon_pre_div_impl(clocks, false);
            release_syscon_pre_div_in(clocks);
        }
        pub fn syscon_pre_div_frequency(clocks: &mut ClockTree) -> u32 {
            (syscon_pre_div_in_frequency(clocks) / (unwrap!(clocks.syscon_pre_div).value() + 1))
        }
        pub fn configure_apb_clk(clocks: &mut ClockTree, new_selector: ApbClkConfig) {
            let old_selector = clocks.apb_clk.replace(new_selector);
            if clocks.apb_clk_refcount > 0 {
                match new_selector {
                    ApbClkConfig::Pll80m => request_apb_clk_80m(clocks),
                    ApbClkConfig::CpuDiv2 => request_apb_clk_cpu_div2(clocks),
                    ApbClkConfig::Cpu => request_cpu_clk(clocks),
                }
                configure_apb_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        ApbClkConfig::Pll80m => release_apb_clk_80m(clocks),
                        ApbClkConfig::CpuDiv2 => release_apb_clk_cpu_div2(clocks),
                        ApbClkConfig::Cpu => release_cpu_clk(clocks),
                    }
                }
            } else {
                configure_apb_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_apb_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.apb_clk_refcount) {
                match unwrap!(clocks.apb_clk) {
                    ApbClkConfig::Pll80m => request_apb_clk_80m(clocks),
                    ApbClkConfig::CpuDiv2 => request_apb_clk_cpu_div2(clocks),
                    ApbClkConfig::Cpu => request_cpu_clk(clocks),
                }
                enable_apb_clk_impl(clocks, true);
            }
        }
        pub fn release_apb_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.apb_clk_refcount) {
                enable_apb_clk_impl(clocks, false);
                match unwrap!(clocks.apb_clk) {
                    ApbClkConfig::Pll80m => release_apb_clk_80m(clocks),
                    ApbClkConfig::CpuDiv2 => release_apb_clk_cpu_div2(clocks),
                    ApbClkConfig::Cpu => release_cpu_clk(clocks),
                }
            }
        }
        pub fn apb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.apb_clk) {
                ApbClkConfig::Pll80m => apb_clk_80m_frequency(clocks),
                ApbClkConfig::CpuDiv2 => apb_clk_cpu_div2_frequency(clocks),
                ApbClkConfig::Cpu => cpu_clk_frequency(clocks),
            }
        }
        pub fn configure_ref_tick(clocks: &mut ClockTree, new_selector: RefTickConfig) {
            let old_selector = clocks.ref_tick.replace(new_selector);
            if clocks.ref_tick_refcount > 0 {
                match new_selector {
                    RefTickConfig::Pll => request_ref_tick_pll(clocks),
                    RefTickConfig::Apll => request_ref_tick_apll(clocks),
                    RefTickConfig::Xtal => request_ref_tick_xtal(clocks),
                    RefTickConfig::Fosc => request_ref_tick_fosc(clocks),
                }
                configure_ref_tick_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RefTickConfig::Pll => release_ref_tick_pll(clocks),
                        RefTickConfig::Apll => release_ref_tick_apll(clocks),
                        RefTickConfig::Xtal => release_ref_tick_xtal(clocks),
                        RefTickConfig::Fosc => release_ref_tick_fosc(clocks),
                    }
                }
            } else {
                configure_ref_tick_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_ref_tick(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.ref_tick_refcount) {
                match unwrap!(clocks.ref_tick) {
                    RefTickConfig::Pll => request_ref_tick_pll(clocks),
                    RefTickConfig::Apll => request_ref_tick_apll(clocks),
                    RefTickConfig::Xtal => request_ref_tick_xtal(clocks),
                    RefTickConfig::Fosc => request_ref_tick_fosc(clocks),
                }
                enable_ref_tick_impl(clocks, true);
            }
        }
        pub fn release_ref_tick(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.ref_tick_refcount) {
                enable_ref_tick_impl(clocks, false);
                match unwrap!(clocks.ref_tick) {
                    RefTickConfig::Pll => release_ref_tick_pll(clocks),
                    RefTickConfig::Apll => release_ref_tick_apll(clocks),
                    RefTickConfig::Xtal => release_ref_tick_xtal(clocks),
                    RefTickConfig::Fosc => release_ref_tick_fosc(clocks),
                }
            }
        }
        pub fn ref_tick_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.ref_tick) {
                RefTickConfig::Pll => ref_tick_pll_frequency(clocks),
                RefTickConfig::Apll => ref_tick_apll_frequency(clocks),
                RefTickConfig::Xtal => ref_tick_xtal_frequency(clocks),
                RefTickConfig::Fosc => ref_tick_fosc_frequency(clocks),
            }
        }
        pub fn configure_ref_tick_xtal(clocks: &mut ClockTree, config: RefTickXtalConfig) {
            clocks.ref_tick_xtal = Some(config);
            configure_ref_tick_xtal_impl(clocks, config);
        }
        pub fn request_ref_tick_xtal(clocks: &mut ClockTree) {
            request_apb_clk(clocks);
            enable_ref_tick_xtal_impl(clocks, true);
        }
        pub fn release_ref_tick_xtal(clocks: &mut ClockTree) {
            enable_ref_tick_xtal_impl(clocks, false);
            release_apb_clk(clocks);
        }
        pub fn ref_tick_xtal_frequency(clocks: &mut ClockTree) -> u32 {
            (apb_clk_frequency(clocks) / (unwrap!(clocks.ref_tick_xtal).value() + 1))
        }
        pub fn configure_ref_tick_fosc(clocks: &mut ClockTree, config: RefTickFoscConfig) {
            clocks.ref_tick_fosc = Some(config);
            configure_ref_tick_fosc_impl(clocks, config);
        }
        pub fn request_ref_tick_fosc(clocks: &mut ClockTree) {
            request_apb_clk(clocks);
            enable_ref_tick_fosc_impl(clocks, true);
        }
        pub fn release_ref_tick_fosc(clocks: &mut ClockTree) {
            enable_ref_tick_fosc_impl(clocks, false);
            release_apb_clk(clocks);
        }
        pub fn ref_tick_fosc_frequency(clocks: &mut ClockTree) -> u32 {
            (apb_clk_frequency(clocks) / (unwrap!(clocks.ref_tick_fosc).value() + 1))
        }
        pub fn configure_ref_tick_apll(clocks: &mut ClockTree, config: RefTickApllConfig) {
            clocks.ref_tick_apll = Some(config);
            configure_ref_tick_apll_impl(clocks, config);
        }
        pub fn request_ref_tick_apll(clocks: &mut ClockTree) {
            request_apb_clk(clocks);
            enable_ref_tick_apll_impl(clocks, true);
        }
        pub fn release_ref_tick_apll(clocks: &mut ClockTree) {
            enable_ref_tick_apll_impl(clocks, false);
            release_apb_clk(clocks);
        }
        pub fn ref_tick_apll_frequency(clocks: &mut ClockTree) -> u32 {
            (apb_clk_frequency(clocks) / (unwrap!(clocks.ref_tick_apll).value() + 1))
        }
        pub fn configure_ref_tick_pll(clocks: &mut ClockTree, config: RefTickPllConfig) {
            clocks.ref_tick_pll = Some(config);
            configure_ref_tick_pll_impl(clocks, config);
        }
        pub fn request_ref_tick_pll(clocks: &mut ClockTree) {
            request_apb_clk(clocks);
            enable_ref_tick_pll_impl(clocks, true);
        }
        pub fn release_ref_tick_pll(clocks: &mut ClockTree) {
            enable_ref_tick_pll_impl(clocks, false);
            release_apb_clk(clocks);
        }
        pub fn ref_tick_pll_frequency(clocks: &mut ClockTree) -> u32 {
            (apb_clk_frequency(clocks) / (unwrap!(clocks.ref_tick_pll).value() + 1))
        }
        pub fn configure_cpu_clk(clocks: &mut ClockTree, new_selector: CpuClkConfig) {
            let old_selector = clocks.cpu_clk.replace(new_selector);
            match new_selector {
                CpuClkConfig::Xtal => {
                    configure_apb_clk(clocks, ApbClkConfig::Cpu);
                    configure_syscon_pre_div_in(clocks, SysconPreDivInConfig::Xtal);
                    configure_ref_tick(clocks, RefTickConfig::Xtal);
                    let config_value =
                        RefTickXtalConfig::new(((apb_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_xtal(clocks, config_value);
                }
                CpuClkConfig::RcFast => {
                    configure_apb_clk(clocks, ApbClkConfig::Cpu);
                    configure_syscon_pre_div_in(clocks, SysconPreDivInConfig::RcFast);
                    configure_ref_tick(clocks, RefTickConfig::Fosc);
                    let config_value =
                        RefTickFoscConfig::new(((apb_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_fosc(clocks, config_value);
                }
                CpuClkConfig::Apll => {
                    configure_apb_clk(clocks, ApbClkConfig::CpuDiv2);
                    configure_cpu_pll_div_in(clocks, CpuPllDivInConfig::Apll);
                    configure_ref_tick(clocks, RefTickConfig::Apll);
                    let config_value =
                        RefTickApllConfig::new(((apb_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_apll(clocks, config_value);
                }
                CpuClkConfig::Pll => {
                    configure_apb_clk(clocks, ApbClkConfig::Pll80m);
                    configure_cpu_pll_div_in(clocks, CpuPllDivInConfig::Pll);
                    configure_ref_tick(clocks, RefTickConfig::Pll);
                    let config_value =
                        RefTickPllConfig::new(((apb_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_pll(clocks, config_value);
                }
            }
            match new_selector {
                CpuClkConfig::Xtal => request_syscon_pre_div(clocks),
                CpuClkConfig::RcFast => request_syscon_pre_div(clocks),
                CpuClkConfig::Apll => request_cpu_pll_div(clocks),
                CpuClkConfig::Pll => request_cpu_pll_div(clocks),
            }
            configure_cpu_clk_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    CpuClkConfig::Xtal => release_syscon_pre_div(clocks),
                    CpuClkConfig::RcFast => release_syscon_pre_div(clocks),
                    CpuClkConfig::Apll => release_cpu_pll_div(clocks),
                    CpuClkConfig::Pll => release_cpu_pll_div(clocks),
                }
            }
        }
        fn request_cpu_clk(_clocks: &mut ClockTree) {}
        fn release_cpu_clk(_clocks: &mut ClockTree) {}
        pub fn cpu_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.cpu_clk) {
                CpuClkConfig::Xtal => syscon_pre_div_frequency(clocks),
                CpuClkConfig::RcFast => syscon_pre_div_frequency(clocks),
                CpuClkConfig::Apll => cpu_pll_div_frequency(clocks),
                CpuClkConfig::Pll => cpu_pll_div_frequency(clocks),
            }
        }
        pub fn request_apb_clk_cpu_div2(clocks: &mut ClockTree) {
            request_cpu_clk(clocks);
            enable_apb_clk_cpu_div2_impl(clocks, true);
        }
        pub fn release_apb_clk_cpu_div2(clocks: &mut ClockTree) {
            enable_apb_clk_cpu_div2_impl(clocks, false);
            release_cpu_clk(clocks);
        }
        pub fn apb_clk_cpu_div2_frequency(clocks: &mut ClockTree) -> u32 {
            (cpu_clk_frequency(clocks) / 2)
        }
        pub fn request_apb_clk_80m(clocks: &mut ClockTree) {
            request_cpu_clk(clocks);
            enable_apb_clk_80m_impl(clocks, true);
        }
        pub fn release_apb_clk_80m(clocks: &mut ClockTree) {
            enable_apb_clk_80m_impl(clocks, false);
            release_cpu_clk(clocks);
        }
        pub fn apb_clk_80m_frequency(clocks: &mut ClockTree) -> u32 {
            80000000
        }
        pub fn request_xtal32k_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.xtal32k_clk_refcount) {
                enable_xtal32k_clk_impl(clocks, true);
            }
        }
        pub fn release_xtal32k_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.xtal32k_clk_refcount) {
                enable_xtal32k_clk_impl(clocks, false);
            }
        }
        pub fn xtal32k_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_rc_slow_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.rc_slow_clk_refcount) {
                enable_rc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_slow_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.rc_slow_clk_refcount) {
                enable_rc_slow_clk_impl(clocks, false);
            }
        }
        pub fn rc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            150000
        }
        pub fn request_rc_fast_div_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.rc_fast_div_clk_refcount) {
                request_rc_fast_clk(clocks);
                enable_rc_fast_div_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_div_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.rc_fast_div_clk_refcount) {
                enable_rc_fast_div_clk_impl(clocks, false);
                release_rc_fast_clk(clocks);
            }
        }
        pub fn rc_fast_div_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (rc_fast_clk_frequency(clocks) / 256)
        }
        pub fn request_xtal_div_clk(clocks: &mut ClockTree) {
            request_xtal_clk(clocks);
            enable_xtal_div_clk_impl(clocks, true);
        }
        pub fn release_xtal_div_clk(clocks: &mut ClockTree) {
            enable_xtal_div_clk_impl(clocks, false);
            release_xtal_clk(clocks);
        }
        pub fn xtal_div_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (xtal_clk_frequency(clocks) / 4)
        }
        pub fn configure_rtc_slow_clk(clocks: &mut ClockTree, new_selector: RtcSlowClkConfig) {
            let old_selector = clocks.rtc_slow_clk.replace(new_selector);
            if clocks.rtc_slow_clk_refcount > 0 {
                match new_selector {
                    RtcSlowClkConfig::Xtal => request_xtal32k_clk(clocks),
                    RtcSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    RtcSlowClkConfig::RcFast => request_rc_fast_div_clk(clocks),
                }
                configure_rtc_slow_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RtcSlowClkConfig::Xtal => release_xtal32k_clk(clocks),
                        RtcSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                        RtcSlowClkConfig::RcFast => release_rc_fast_div_clk(clocks),
                    }
                }
            } else {
                configure_rtc_slow_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_rtc_slow_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.rtc_slow_clk_refcount) {
                match unwrap!(clocks.rtc_slow_clk) {
                    RtcSlowClkConfig::Xtal => request_xtal32k_clk(clocks),
                    RtcSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    RtcSlowClkConfig::RcFast => request_rc_fast_div_clk(clocks),
                }
                enable_rtc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_rtc_slow_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.rtc_slow_clk_refcount) {
                enable_rtc_slow_clk_impl(clocks, false);
                match unwrap!(clocks.rtc_slow_clk) {
                    RtcSlowClkConfig::Xtal => release_xtal32k_clk(clocks),
                    RtcSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                    RtcSlowClkConfig::RcFast => release_rc_fast_div_clk(clocks),
                }
            }
        }
        pub fn rtc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.rtc_slow_clk) {
                RtcSlowClkConfig::Xtal => xtal32k_clk_frequency(clocks),
                RtcSlowClkConfig::RcSlow => rc_slow_clk_frequency(clocks),
                RtcSlowClkConfig::RcFast => rc_fast_div_clk_frequency(clocks),
            }
        }
        pub fn configure_rtc_fast_clk(clocks: &mut ClockTree, new_selector: RtcFastClkConfig) {
            let old_selector = clocks.rtc_fast_clk.replace(new_selector);
            if clocks.rtc_fast_clk_refcount > 0 {
                match new_selector {
                    RtcFastClkConfig::Xtal => request_xtal_div_clk(clocks),
                    RtcFastClkConfig::Rc => request_rc_fast_clk(clocks),
                }
                configure_rtc_fast_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RtcFastClkConfig::Xtal => release_xtal_div_clk(clocks),
                        RtcFastClkConfig::Rc => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_rtc_fast_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_rtc_fast_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.rtc_fast_clk_refcount) {
                match unwrap!(clocks.rtc_fast_clk) {
                    RtcFastClkConfig::Xtal => request_xtal_div_clk(clocks),
                    RtcFastClkConfig::Rc => request_rc_fast_clk(clocks),
                }
                enable_rtc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rtc_fast_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.rtc_fast_clk_refcount) {
                enable_rtc_fast_clk_impl(clocks, false);
                match unwrap!(clocks.rtc_fast_clk) {
                    RtcFastClkConfig::Xtal => release_xtal_div_clk(clocks),
                    RtcFastClkConfig::Rc => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn rtc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.rtc_fast_clk) {
                RtcFastClkConfig::Xtal => xtal_div_clk_frequency(clocks),
                RtcFastClkConfig::Rc => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_mcpwm0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Mcpwm0FunctionClockConfig,
        ) {
            let old_selector = clocks.mcpwm0_function_clock.replace(new_selector);
            if clocks.mcpwm0_function_clock_refcount > 0 {
                request_pll_f160m_clk(clocks);
                configure_mcpwm0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    release_pll_f160m_clk(clocks);
                }
            } else {
                configure_mcpwm0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_mcpwm0_function_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.mcpwm0_function_clock_refcount) {
                request_pll_f160m_clk(clocks);
                enable_mcpwm0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_mcpwm0_function_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.mcpwm0_function_clock_refcount) {
                enable_mcpwm0_function_clock_impl(clocks, false);
                release_pll_f160m_clk(clocks);
            }
        }
        pub fn mcpwm0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            pll_f160m_clk_frequency(clocks)
        }
        pub fn configure_mcpwm1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Mcpwm0FunctionClockConfig,
        ) {
            let old_selector = clocks.mcpwm1_function_clock.replace(new_selector);
            if clocks.mcpwm1_function_clock_refcount > 0 {
                request_pll_f160m_clk(clocks);
                configure_mcpwm1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    release_pll_f160m_clk(clocks);
                }
            } else {
                configure_mcpwm1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_mcpwm1_function_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.mcpwm1_function_clock_refcount) {
                request_pll_f160m_clk(clocks);
                enable_mcpwm1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_mcpwm1_function_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.mcpwm1_function_clock_refcount) {
                enable_mcpwm1_function_clock_impl(clocks, false);
                release_pll_f160m_clk(clocks);
            }
        }
        pub fn mcpwm1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            pll_f160m_clk_frequency(clocks)
        }
        pub fn configure_timg0_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg0_calibration_clock.replace(new_selector);
            if clocks.timg0_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::RcSlowClk => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::RcSlowClk => release_rc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFastDivClk => {
                            release_rc_fast_div_clk(clocks)
                        }
                        Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_calibration_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::RcSlowClk => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg0_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_calibration_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                enable_timg0_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::RcSlowClk => release_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => release_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg0_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_calibration_clock) {
                Timg0CalibrationClockConfig::RcSlowClk => rc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFastDivClk => rc_fast_div_clk_frequency(clocks),
                Timg0CalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg1_calibration_clock.replace(new_selector);
            if clocks.timg1_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::RcSlowClk => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::RcSlowClk => release_rc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFastDivClk => {
                            release_rc_fast_div_clk(clocks)
                        }
                        Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_calibration_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::RcSlowClk => request_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg1_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_calibration_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                enable_timg1_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::RcSlowClk => release_rc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => release_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg1_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_calibration_clock) {
                Timg0CalibrationClockConfig::RcSlowClk => rc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFastDivClk => rc_fast_div_clk_frequency(clocks),
                Timg0CalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        /// Clock tree configuration.
        ///
        /// The fields of this struct are optional, with the following caveats:
        /// - If `XTAL_CLK` is not specified, the crystal frequency will be automatically detected
        ///   if possible.
        /// - The CPU and its upstream clock nodes will be set to a default configuration.
        /// - Other unspecified clock sources will not be useable by peripherals.
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[instability::unstable]
        pub struct ClockConfig {
            /// `XTAL_CLK` configuration.
            pub xtal_clk: Option<XtalClkConfig>,
            /// `PLL_CLK` configuration.
            pub pll_clk: Option<PllClkConfig>,
            /// `APLL_CLK` configuration.
            pub apll_clk: Option<ApllClkConfig>,
            /// `CPU_PLL_DIV` configuration.
            pub cpu_pll_div: Option<CpuPllDivConfig>,
            /// `SYSCON_PRE_DIV` configuration.
            pub syscon_pre_div: Option<SysconPreDivConfig>,
            /// `CPU_CLK` configuration.
            pub cpu_clk: Option<CpuClkConfig>,
            /// `RTC_SLOW_CLK` configuration.
            pub rtc_slow_clk: Option<RtcSlowClkConfig>,
            /// `RTC_FAST_CLK` configuration.
            pub rtc_fast_clk: Option<RtcFastClkConfig>,
        }
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {
                    if let Some(config) = self.xtal_clk {
                        configure_xtal_clk(clocks, config);
                    }
                    if let Some(config) = self.pll_clk {
                        configure_pll_clk(clocks, config);
                    }
                    if let Some(config) = self.apll_clk {
                        configure_apll_clk(clocks, config);
                    }
                    if let Some(config) = self.cpu_pll_div {
                        configure_cpu_pll_div(clocks, config);
                    }
                    if let Some(config) = self.syscon_pre_div {
                        configure_syscon_pre_div(clocks, config);
                    }
                    if let Some(config) = self.cpu_clk {
                        configure_cpu_clk(clocks, config);
                    }
                    if let Some(config) = self.rtc_slow_clk {
                        configure_rtc_slow_clk(clocks, config);
                    }
                    if let Some(config) = self.rtc_fast_clk {
                        configure_rtc_fast_clk(clocks, config);
                    }
                });
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount = unwrap!(refcount.checked_add(1), "Reference count overflow");
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount = refcount.saturating_sub(1);
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            /// AES peripheral clock signal
            Aes,
            /// I2C_EXT0 peripheral clock signal
            I2cExt0,
            /// I2C_EXT1 peripheral clock signal
            I2cExt1,
            /// I2S0 peripheral clock signal
            I2s0,
            /// I2S1 peripheral clock signal
            I2s1,
            /// LEDC peripheral clock signal
            Ledc,
            /// MCPWM0 peripheral clock signal
            Mcpwm0,
            /// MCPWM1 peripheral clock signal
            Mcpwm1,
            /// PCNT peripheral clock signal
            Pcnt,
            /// RMT peripheral clock signal
            Rmt,
            /// RSA peripheral clock signal
            Rsa,
            /// SHA peripheral clock signal
            Sha,
            /// SPI2 peripheral clock signal
            Spi2,
            /// SPI3 peripheral clock signal
            Spi3,
            /// SPI_DMA peripheral clock signal
            SpiDma,
            /// TIMG0 peripheral clock signal
            Timg0,
            /// TIMG1 peripheral clock signal
            Timg1,
            /// TWAI0 peripheral clock signal
            Twai0,
            /// UART0 peripheral clock signal
            Uart0,
            /// UART1 peripheral clock signal
            Uart1,
            /// UART2 peripheral clock signal
            Uart2,
            /// UART_MEM peripheral clock signal
            UartMem,
            /// UHCI0 peripheral clock signal
            Uhci0,
            /// UHCI1 peripheral clock signal
            Uhci1,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] = &[Self::Timg0, Self::Uart0, Self::UartMem];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::I2cExt0,
                Self::I2cExt1,
                Self::I2s0,
                Self::I2s1,
                Self::Ledc,
                Self::Mcpwm0,
                Self::Mcpwm1,
                Self::Pcnt,
                Self::Rmt,
                Self::Rsa,
                Self::Sha,
                Self::Spi2,
                Self::Spi3,
                Self::SpiDma,
                Self::Timg0,
                Self::Timg1,
                Self::Twai0,
                Self::Uart0,
                Self::Uart1,
                Self::Uart2,
                Self::UartMem,
                Self::Uhci0,
                Self::Uhci1,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .peri_clk_en()
                        .modify(|_, w| w.crypto_aes_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.i2c_ext0_clk_en().bit(enable));
                }
                Peripheral::I2cExt1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.i2c_ext1_clk_en().bit(enable));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.i2s0_clk_en().bit(enable));
                }
                Peripheral::I2s1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.i2s1_clk_en().bit(enable));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.ledc_clk_en().bit(enable));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.pwm0_clk_en().bit(enable));
                }
                Peripheral::Mcpwm1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.pwm1_clk_en().bit(enable));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.pcnt_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .peri_clk_en()
                        .modify(|_, w| w.crypto_rsa_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .peri_clk_en()
                        .modify(|_, w| w.crypto_sha_clk_en().bit(enable));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.spi2_clk_en().bit(enable));
                }
                Peripheral::Spi3 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.spi3_clk_en().bit(enable));
                }
                Peripheral::SpiDma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.spi_dma_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.timergroup_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.timergroup1_clk_en().bit(enable));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.twai_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.uart_clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.uart1_clk_en().bit(enable));
                }
                Peripheral::Uart2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.uart2_clk_en().bit(enable));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.uart_mem_clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.uhci0_clk_en().bit(enable));
                }
                Peripheral::Uhci1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en()
                        .modify(|_, w| w.uhci1_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .peri_rst_en()
                        .modify(|_, w| w.crypto_aes_rst().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.i2c_ext0_rst().bit(reset));
                }
                Peripheral::I2cExt1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.i2c_ext1_rst().bit(reset));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.i2s0_rst().bit(reset));
                }
                Peripheral::I2s1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.i2s1_rst().bit(reset));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.ledc_rst().bit(reset));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.pwm0_rst().bit(reset));
                }
                Peripheral::Mcpwm1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.pwm1_rst().bit(reset));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.pcnt_rst().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.rmt_rst().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .peri_rst_en()
                        .modify(|_, w| w.crypto_rsa_rst().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .peri_rst_en()
                        .modify(|_, w| w.crypto_sha_rst().bit(reset));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.spi2_rst().bit(reset));
                }
                Peripheral::Spi3 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.spi3_rst().bit(reset));
                }
                Peripheral::SpiDma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.spi_dma_rst().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.timergroup_rst().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.timergroup1_rst().bit(reset));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.twai_rst().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.uart_rst().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.uart1_rst().bit(reset));
                }
                Peripheral::Uart2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.uart2_rst().bit(reset));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.uart_mem_rst().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.uhci0_rst().bit(reset));
                }
                Peripheral::Uhci1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en()
                        .modify(|_, w| w.uhci1_rst().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x3FFAE000..0x40000000
    };
    (size as str, "DRAM") => {
        "335872"
    };
    ("DRAM2_UNINIT") => {
        0x3FFE7E30..0x40000000
    };
    (size as str, "DRAM2_UNINIT") => {
        "98768"
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_aes_key_length {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((128)); _for_each_inner!((192)); _for_each_inner!((256));
        _for_each_inner!((128, 0, 4)); _for_each_inner!((192, 1, 5));
        _for_each_inner!((256, 2, 6)); _for_each_inner!((bits(128), (192), (256)));
        _for_each_inner!((modes(128, 0, 4), (192, 1, 5), (256, 2, 6)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sw_interrupt {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, FROM_CPU_INTR0, software_interrupt0)); _for_each_inner!((1,
        FROM_CPU_INTR1, software_interrupt1)); _for_each_inner!((2, FROM_CPU_INTR2,
        software_interrupt2)); _for_each_inner!((3, FROM_CPU_INTR3,
        software_interrupt3)); _for_each_inner!((all(0, FROM_CPU_INTR0,
        software_interrupt0), (1, FROM_CPU_INTR1, software_interrupt1), (2,
        FROM_CPU_INTR2, software_interrupt2), (3, FROM_CPU_INTR3, software_interrupt3)));
    };
}
#[macro_export]
macro_rules! sw_interrupt_delay {
    () => {
        unsafe {}
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0)); _for_each_inner!((1)); _for_each_inner!((2));
        _for_each_inner!((3)); _for_each_inner!((4)); _for_each_inner!((5));
        _for_each_inner!((6)); _for_each_inner!((7)); _for_each_inner!((0, 0));
        _for_each_inner!((1, 1)); _for_each_inner!((2, 2)); _for_each_inner!((3, 3));
        _for_each_inner!((4, 4)); _for_each_inner!((5, 5)); _for_each_inner!((6, 6));
        _for_each_inner!((7, 7)); _for_each_inner!((0, 0)); _for_each_inner!((1, 1));
        _for_each_inner!((2, 2)); _for_each_inner!((3, 3)); _for_each_inner!((4, 4));
        _for_each_inner!((5, 5)); _for_each_inner!((6, 6)); _for_each_inner!((7, 7));
        _for_each_inner!((all(0), (1), (2), (3), (4), (5), (6), (7)));
        _for_each_inner!((tx(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7,
        7))); _for_each_inner!((rx(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6),
        (7, 7)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((RefTick, 0)); _for_each_inner!((Apb, 1));
        _for_each_inner!((Apb)); _for_each_inner!((all(RefTick, 0), (Apb, 1)));
        _for_each_inner!((default(Apb))); _for_each_inner!((is_boolean));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((512)); _for_each_inner!((1024)); _for_each_inner!((1536));
        _for_each_inner!((2048)); _for_each_inner!((2560)); _for_each_inner!((3072));
        _for_each_inner!((3584)); _for_each_inner!((4096)); _for_each_inner!((all(512),
        (1024), (1536), (2048), (2560), (3072), (3584), (4096)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((512)); _for_each_inner!((1024)); _for_each_inner!((1536));
        _for_each_inner!((2048)); _for_each_inner!((all(512), (1024), (1536), (2048)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Sha1, "SHA-1"(sizes : 64, 20, 8) (insecure_against :
        "collision", "length extension"), 0)); _for_each_inner!((Sha256, "SHA-256"(sizes
        : 64, 32, 8) (insecure_against : "length extension"), 0));
        _for_each_inner!((Sha384, "SHA-384"(sizes : 128, 48, 16) (insecure_against :),
        0)); _for_each_inner!((Sha512, "SHA-512"(sizes : 128, 64, 16) (insecure_against :
        "length extension"), 0)); _for_each_inner!((algos(Sha1, "SHA-1"(sizes : 64, 20,
        8) (insecure_against : "collision", "length extension"), 0), (Sha256,
        "SHA-256"(sizes : 64, 32, 8) (insecure_against : "length extension"), 0),
        (Sha384, "SHA-384"(sizes : 128, 48, 16) (insecure_against :), 0), (Sha512,
        "SHA-512"(sizes : 128, 64, 16) (insecure_against : "length extension"), 0)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA));
        _for_each_inner!((I2C1, I2cExt1, I2CEXT1_SCL, I2CEXT1_SDA));
        _for_each_inner!((all(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA), (I2C1, I2cExt1,
        I2CEXT1_SCL, I2CEXT1_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident, $rts:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner!((UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner!((UART2, Uart2, U2RXD, U2TXD, U2CTS, U2RTS));
        _for_each_inner!((all(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (UART1, Uart1,
        U1RXD, U1TXD, U1CTS, U1RTS), (UART2, Uart2, U2RXD, U2TXD, U2CTS, U2RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, [$($cs:ident),*] [$($sio:ident),*
/// $($is_qspi:iteral)?])`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, HSPICLK[HSPICS0, HSPICS1, HSPICS2] [HSPID, HSPIQ,
        HSPIWP, HSPIHD], true)); _for_each_inner!((SPI3, Spi3, VSPICLK[VSPICS0, VSPICS1,
        VSPICS2] [VSPID, VSPIQ, VSPIWP, VSPIHD], true)); _for_each_inner!((all(SPI2,
        Spi2, HSPICLK[HSPICS0, HSPICS1, HSPICS2] [HSPID, HSPIQ, HSPIWP, HSPIHD], true),
        (SPI3, Spi3, VSPICLK[VSPICS0, VSPICS1, VSPICS2] [VSPID, VSPIQ, VSPIWP, VSPIHD],
        true)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, HSPICLK, HSPID, HSPIQ, HSPICS0));
        _for_each_inner!((SPI3, Spi3, VSPICLK, VSPID, VSPIQ, VSPICS0));
        _for_each_inner!((all(SPI2, Spi2, HSPICLK, HSPID, HSPIQ, HSPICS0), (SPI3, Spi3,
        VSPICLK, VSPID, VSPIQ, VSPICS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((@ peri_type GPIO0 <= virtual())); _for_each_inner!((@ peri_type
        GPIO1 <= virtual())); _for_each_inner!((@ peri_type GPIO2 <= virtual()));
        _for_each_inner!((@ peri_type GPIO3 <= virtual())); _for_each_inner!((@ peri_type
        GPIO4 <= virtual())); _for_each_inner!((@ peri_type GPIO5 <= virtual()));
        _for_each_inner!((@ peri_type GPIO6 <= virtual())); _for_each_inner!((@ peri_type
        GPIO7 <= virtual())); _for_each_inner!((@ peri_type GPIO8 <= virtual()));
        _for_each_inner!((@ peri_type GPIO9 <= virtual())); _for_each_inner!((@ peri_type
        GPIO10 <= virtual())); _for_each_inner!((@ peri_type GPIO11 <= virtual()));
        _for_each_inner!((@ peri_type GPIO12 <= virtual())); _for_each_inner!((@
        peri_type GPIO13 <= virtual())); _for_each_inner!((@ peri_type GPIO14 <=
        virtual())); _for_each_inner!((@ peri_type GPIO15 <= virtual()));
        _for_each_inner!((@ peri_type GPIO16 <= virtual())); _for_each_inner!((@
        peri_type GPIO17 <= virtual())); _for_each_inner!((@ peri_type GPIO18 <=
        virtual())); _for_each_inner!((@ peri_type GPIO19 <= virtual()));
        _for_each_inner!((@ peri_type GPIO20 <= virtual())); _for_each_inner!((@
        peri_type GPIO21 <= virtual())); _for_each_inner!((@ peri_type GPIO22 <=
        virtual())); _for_each_inner!((@ peri_type GPIO23 <= virtual()));
        _for_each_inner!((@ peri_type GPIO25 <= virtual())); _for_each_inner!((@
        peri_type GPIO26 <= virtual())); _for_each_inner!((@ peri_type GPIO27 <=
        virtual())); _for_each_inner!((@ peri_type GPIO32 <= virtual()));
        _for_each_inner!((@ peri_type GPIO33 <= virtual())); _for_each_inner!((@
        peri_type GPIO34 <= virtual())); _for_each_inner!((@ peri_type GPIO35 <=
        virtual())); _for_each_inner!((@ peri_type GPIO36 <= virtual()));
        _for_each_inner!((@ peri_type GPIO37 <= virtual())); _for_each_inner!((@
        peri_type GPIO38 <= virtual())); _for_each_inner!((@ peri_type GPIO39 <=
        virtual())); _for_each_inner!((@ peri_type AES <= AES() (unstable)));
        _for_each_inner!((@ peri_type APB_CTRL <= APB_CTRL() (unstable)));
        _for_each_inner!((@ peri_type BB <= BB() (unstable))); _for_each_inner!((@
        peri_type DPORT <= DPORT() (unstable))); _for_each_inner!((@ peri_type SYSTEM <=
        DPORT() (unstable))); _for_each_inner!((@ peri_type EFUSE <= EFUSE()
        (unstable))); _for_each_inner!((@ peri_type EMAC_DMA <= EMAC_DMA() (unstable)));
        _for_each_inner!((@ peri_type EMAC_EXT <= EMAC_EXT() (unstable)));
        _for_each_inner!((@ peri_type EMAC_MAC <= EMAC_MAC() (unstable)));
        _for_each_inner!((@ peri_type FLASH_ENCRYPTION <= FLASH_ENCRYPTION()
        (unstable))); _for_each_inner!((@ peri_type FRC_TIMER <= FRC_TIMER()
        (unstable))); _for_each_inner!((@ peri_type GPIO <= GPIO() (unstable)));
        _for_each_inner!((@ peri_type GPIO_SD <= GPIO_SD() (unstable)));
        _for_each_inner!((@ peri_type HINF <= HINF() (unstable))); _for_each_inner!((@
        peri_type I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner!((@ peri_type I2C1 <= I2C1(I2C_EXT1
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((@ peri_type I2S0 <= I2S0(I2S0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type I2S1 <= I2S1(I2S1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type IO_MUX <= IO_MUX() (unstable)));
        _for_each_inner!((@ peri_type LEDC <= LEDC() (unstable))); _for_each_inner!((@
        peri_type MCPWM0 <= MCPWM0() (unstable))); _for_each_inner!((@ peri_type MCPWM1
        <= MCPWM1() (unstable))); _for_each_inner!((@ peri_type NRX <= NRX()
        (unstable))); _for_each_inner!((@ peri_type PCNT <= PCNT() (unstable)));
        _for_each_inner!((@ peri_type RMT <= RMT() (unstable))); _for_each_inner!((@
        peri_type RNG <= RNG() (unstable))); _for_each_inner!((@ peri_type RSA <= RSA(RSA
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type LPWR <= RTC_CNTL() (unstable)));
        _for_each_inner!((@ peri_type RTC_I2C <= RTC_I2C() (unstable)));
        _for_each_inner!((@ peri_type RTC_IO <= RTC_IO() (unstable)));
        _for_each_inner!((@ peri_type SDHOST <= SDHOST() (unstable)));
        _for_each_inner!((@ peri_type SENS <= SENS() (unstable))); _for_each_inner!((@
        peri_type SHA <= SHA() (unstable))); _for_each_inner!((@ peri_type SLC <= SLC()
        (unstable))); _for_each_inner!((@ peri_type SLCHOST <= SLCHOST() (unstable)));
        _for_each_inner!((@ peri_type SPI0 <= SPI0() (unstable))); _for_each_inner!((@
        peri_type SPI1 <= SPI1() (unstable))); _for_each_inner!((@ peri_type SPI2 <=
        SPI2(SPI2_DMA : { bind_dma_interrupt, enable_dma_interrupt, disable_dma_interrupt
        }, SPI2 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }))); _for_each_inner!((@ peri_type SPI3 <= SPI3(SPI3_DMA : { bind_dma_interrupt,
        enable_dma_interrupt, disable_dma_interrupt }, SPI3 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        TIMG0 <= TIMG0() (unstable))); _for_each_inner!((@ peri_type TIMG1 <= TIMG1()
        (unstable))); _for_each_inner!((@ peri_type TWAI0 <= TWAI0() (unstable)));
        _for_each_inner!((@ peri_type UART0 <= UART0(UART0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        UART1 <= UART1(UART1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner!((@ peri_type UART2 <= UART2(UART2 :
        { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((@ peri_type UHCI0 <= UHCI0() (unstable))); _for_each_inner!((@
        peri_type UHCI1 <= UHCI1() (unstable))); _for_each_inner!((@ peri_type WIFI <=
        WIFI() (unstable))); _for_each_inner!((@ peri_type DMA_SPI2 <= SPI2()
        (unstable))); _for_each_inner!((@ peri_type DMA_SPI3 <= SPI3() (unstable)));
        _for_each_inner!((@ peri_type DMA_I2S0 <= I2S0() (unstable)));
        _for_each_inner!((@ peri_type DMA_I2S1 <= I2S1() (unstable)));
        _for_each_inner!((@ peri_type ADC1 <= virtual() (unstable))); _for_each_inner!((@
        peri_type ADC2 <= virtual() (unstable))); _for_each_inner!((@ peri_type BT <=
        virtual() (unstable))); _for_each_inner!((@ peri_type CPU_CTRL <= virtual()
        (unstable))); _for_each_inner!((@ peri_type DAC1 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type DAC2 <= virtual() (unstable))); _for_each_inner!((@
        peri_type FLASH <= virtual() (unstable))); _for_each_inner!((@ peri_type PSRAM <=
        virtual() (unstable))); _for_each_inner!((@ peri_type SW_INTERRUPT <= virtual()
        (unstable))); _for_each_inner!((@ peri_type TOUCH <= virtual() (unstable)));
        _for_each_inner!((GPIO0)); _for_each_inner!((GPIO1)); _for_each_inner!((GPIO2));
        _for_each_inner!((GPIO3)); _for_each_inner!((GPIO4)); _for_each_inner!((GPIO5));
        _for_each_inner!((GPIO12)); _for_each_inner!((GPIO13));
        _for_each_inner!((GPIO14)); _for_each_inner!((GPIO15));
        _for_each_inner!((GPIO16)); _for_each_inner!((GPIO17));
        _for_each_inner!((GPIO18)); _for_each_inner!((GPIO19));
        _for_each_inner!((GPIO21)); _for_each_inner!((GPIO22));
        _for_each_inner!((GPIO23)); _for_each_inner!((GPIO25));
        _for_each_inner!((GPIO26)); _for_each_inner!((GPIO27));
        _for_each_inner!((GPIO32)); _for_each_inner!((GPIO33));
        _for_each_inner!((GPIO34)); _for_each_inner!((GPIO35));
        _for_each_inner!((GPIO36)); _for_each_inner!((GPIO37));
        _for_each_inner!((GPIO38)); _for_each_inner!((GPIO39));
        _for_each_inner!((AES(unstable))); _for_each_inner!((APB_CTRL(unstable)));
        _for_each_inner!((BB(unstable))); _for_each_inner!((DPORT(unstable)));
        _for_each_inner!((SYSTEM(unstable))); _for_each_inner!((EFUSE(unstable)));
        _for_each_inner!((EMAC_DMA(unstable))); _for_each_inner!((EMAC_EXT(unstable)));
        _for_each_inner!((EMAC_MAC(unstable)));
        _for_each_inner!((FLASH_ENCRYPTION(unstable)));
        _for_each_inner!((FRC_TIMER(unstable))); _for_each_inner!((GPIO(unstable)));
        _for_each_inner!((GPIO_SD(unstable))); _for_each_inner!((HINF(unstable)));
        _for_each_inner!((I2C0)); _for_each_inner!((I2C1));
        _for_each_inner!((I2S0(unstable))); _for_each_inner!((I2S1(unstable)));
        _for_each_inner!((IO_MUX(unstable))); _for_each_inner!((LEDC(unstable)));
        _for_each_inner!((MCPWM0(unstable))); _for_each_inner!((MCPWM1(unstable)));
        _for_each_inner!((NRX(unstable))); _for_each_inner!((PCNT(unstable)));
        _for_each_inner!((RMT(unstable))); _for_each_inner!((RNG(unstable)));
        _for_each_inner!((RSA(unstable))); _for_each_inner!((LPWR(unstable)));
        _for_each_inner!((RTC_I2C(unstable))); _for_each_inner!((RTC_IO(unstable)));
        _for_each_inner!((SDHOST(unstable))); _for_each_inner!((SENS(unstable)));
        _for_each_inner!((SHA(unstable))); _for_each_inner!((SLC(unstable)));
        _for_each_inner!((SLCHOST(unstable))); _for_each_inner!((SPI0(unstable)));
        _for_each_inner!((SPI1(unstable))); _for_each_inner!((SPI2));
        _for_each_inner!((SPI3)); _for_each_inner!((TIMG0(unstable)));
        _for_each_inner!((TIMG1(unstable))); _for_each_inner!((TWAI0(unstable)));
        _for_each_inner!((UART0)); _for_each_inner!((UART1)); _for_each_inner!((UART2));
        _for_each_inner!((UHCI0(unstable))); _for_each_inner!((UHCI1(unstable)));
        _for_each_inner!((WIFI(unstable))); _for_each_inner!((DMA_SPI2(unstable)));
        _for_each_inner!((DMA_SPI3(unstable))); _for_each_inner!((DMA_I2S0(unstable)));
        _for_each_inner!((DMA_I2S1(unstable))); _for_each_inner!((ADC1(unstable)));
        _for_each_inner!((ADC2(unstable))); _for_each_inner!((BT(unstable)));
        _for_each_inner!((CPU_CTRL(unstable))); _for_each_inner!((DAC1(unstable)));
        _for_each_inner!((DAC2(unstable))); _for_each_inner!((FLASH(unstable)));
        _for_each_inner!((PSRAM(unstable))); _for_each_inner!((SW_INTERRUPT(unstable)));
        _for_each_inner!((TOUCH(unstable))); _for_each_inner!((all(@ peri_type GPIO0 <=
        virtual()), (@ peri_type GPIO1 <= virtual()), (@ peri_type GPIO2 <= virtual()),
        (@ peri_type GPIO3 <= virtual()), (@ peri_type GPIO4 <= virtual()), (@ peri_type
        GPIO5 <= virtual()), (@ peri_type GPIO6 <= virtual()), (@ peri_type GPIO7 <=
        virtual()), (@ peri_type GPIO8 <= virtual()), (@ peri_type GPIO9 <= virtual()),
        (@ peri_type GPIO10 <= virtual()), (@ peri_type GPIO11 <= virtual()), (@
        peri_type GPIO12 <= virtual()), (@ peri_type GPIO13 <= virtual()), (@ peri_type
        GPIO14 <= virtual()), (@ peri_type GPIO15 <= virtual()), (@ peri_type GPIO16 <=
        virtual()), (@ peri_type GPIO17 <= virtual()), (@ peri_type GPIO18 <= virtual()),
        (@ peri_type GPIO19 <= virtual()), (@ peri_type GPIO20 <= virtual()), (@
        peri_type GPIO21 <= virtual()), (@ peri_type GPIO22 <= virtual()), (@ peri_type
        GPIO23 <= virtual()), (@ peri_type GPIO25 <= virtual()), (@ peri_type GPIO26 <=
        virtual()), (@ peri_type GPIO27 <= virtual()), (@ peri_type GPIO32 <= virtual()),
        (@ peri_type GPIO33 <= virtual()), (@ peri_type GPIO34 <= virtual()), (@
        peri_type GPIO35 <= virtual()), (@ peri_type GPIO36 <= virtual()), (@ peri_type
        GPIO37 <= virtual()), (@ peri_type GPIO38 <= virtual()), (@ peri_type GPIO39 <=
        virtual()), (@ peri_type AES <= AES() (unstable)), (@ peri_type APB_CTRL <=
        APB_CTRL() (unstable)), (@ peri_type BB <= BB() (unstable)), (@ peri_type DPORT
        <= DPORT() (unstable)), (@ peri_type SYSTEM <= DPORT() (unstable)), (@ peri_type
        EFUSE <= EFUSE() (unstable)), (@ peri_type EMAC_DMA <= EMAC_DMA() (unstable)), (@
        peri_type EMAC_EXT <= EMAC_EXT() (unstable)), (@ peri_type EMAC_MAC <= EMAC_MAC()
        (unstable)), (@ peri_type FLASH_ENCRYPTION <= FLASH_ENCRYPTION() (unstable)), (@
        peri_type FRC_TIMER <= FRC_TIMER() (unstable)), (@ peri_type GPIO <= GPIO()
        (unstable)), (@ peri_type GPIO_SD <= GPIO_SD() (unstable)), (@ peri_type HINF <=
        HINF() (unstable)), (@ peri_type I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type I2C1 <=
        I2C1(I2C_EXT1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type I2S0 <= I2S0(I2S0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type I2S1 <= I2S1(I2S1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type IO_MUX
        <= IO_MUX() (unstable)), (@ peri_type LEDC <= LEDC() (unstable)), (@ peri_type
        MCPWM0 <= MCPWM0() (unstable)), (@ peri_type MCPWM1 <= MCPWM1() (unstable)), (@
        peri_type NRX <= NRX() (unstable)), (@ peri_type PCNT <= PCNT() (unstable)), (@
        peri_type RMT <= RMT() (unstable)), (@ peri_type RNG <= RNG() (unstable)), (@
        peri_type RSA <= RSA(RSA : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type LPWR <= RTC_CNTL()
        (unstable)), (@ peri_type RTC_I2C <= RTC_I2C() (unstable)), (@ peri_type RTC_IO
        <= RTC_IO() (unstable)), (@ peri_type SDHOST <= SDHOST() (unstable)), (@
        peri_type SENS <= SENS() (unstable)), (@ peri_type SHA <= SHA() (unstable)), (@
        peri_type SLC <= SLC() (unstable)), (@ peri_type SLCHOST <= SLCHOST()
        (unstable)), (@ peri_type SPI0 <= SPI0() (unstable)), (@ peri_type SPI1 <= SPI1()
        (unstable)), (@ peri_type SPI2 <= SPI2(SPI2_DMA : { bind_dma_interrupt,
        enable_dma_interrupt, disable_dma_interrupt }, SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type SPI3 <=
        SPI3(SPI3_DMA : { bind_dma_interrupt, enable_dma_interrupt, disable_dma_interrupt
        }, SPI3 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        })), (@ peri_type TIMG0 <= TIMG0() (unstable)), (@ peri_type TIMG1 <= TIMG1()
        (unstable)), (@ peri_type TWAI0 <= TWAI0() (unstable)), (@ peri_type UART0 <=
        UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type UART1 <= UART1(UART1 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type UART2 <= UART2(UART2 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type UHCI0 <= UHCI0() (unstable)), (@
        peri_type UHCI1 <= UHCI1() (unstable)), (@ peri_type WIFI <= WIFI() (unstable)),
        (@ peri_type DMA_SPI2 <= SPI2() (unstable)), (@ peri_type DMA_SPI3 <= SPI3()
        (unstable)), (@ peri_type DMA_I2S0 <= I2S0() (unstable)), (@ peri_type DMA_I2S1
        <= I2S1() (unstable)), (@ peri_type ADC1 <= virtual() (unstable)), (@ peri_type
        ADC2 <= virtual() (unstable)), (@ peri_type BT <= virtual() (unstable)), (@
        peri_type CPU_CTRL <= virtual() (unstable)), (@ peri_type DAC1 <= virtual()
        (unstable)), (@ peri_type DAC2 <= virtual() (unstable)), (@ peri_type FLASH <=
        virtual() (unstable)), (@ peri_type PSRAM <= virtual() (unstable)), (@ peri_type
        SW_INTERRUPT <= virtual() (unstable)), (@ peri_type TOUCH <= virtual()
        (unstable)))); _for_each_inner!((singletons(GPIO0), (GPIO1), (GPIO2), (GPIO3),
        (GPIO4), (GPIO5), (GPIO12), (GPIO13), (GPIO14), (GPIO15), (GPIO16), (GPIO17),
        (GPIO18), (GPIO19), (GPIO21), (GPIO22), (GPIO23), (GPIO25), (GPIO26), (GPIO27),
        (GPIO32), (GPIO33), (GPIO34), (GPIO35), (GPIO36), (GPIO37), (GPIO38), (GPIO39),
        (AES(unstable)), (APB_CTRL(unstable)), (BB(unstable)), (DPORT(unstable)),
        (SYSTEM(unstable)), (EFUSE(unstable)), (EMAC_DMA(unstable)),
        (EMAC_EXT(unstable)), (EMAC_MAC(unstable)), (FLASH_ENCRYPTION(unstable)),
        (FRC_TIMER(unstable)), (GPIO(unstable)), (GPIO_SD(unstable)), (HINF(unstable)),
        (I2C0), (I2C1), (I2S0(unstable)), (I2S1(unstable)), (IO_MUX(unstable)),
        (LEDC(unstable)), (MCPWM0(unstable)), (MCPWM1(unstable)), (NRX(unstable)),
        (PCNT(unstable)), (RMT(unstable)), (RNG(unstable)), (RSA(unstable)),
        (LPWR(unstable)), (RTC_I2C(unstable)), (RTC_IO(unstable)), (SDHOST(unstable)),
        (SENS(unstable)), (SHA(unstable)), (SLC(unstable)), (SLCHOST(unstable)),
        (SPI0(unstable)), (SPI1(unstable)), (SPI2), (SPI3), (TIMG0(unstable)),
        (TIMG1(unstable)), (TWAI0(unstable)), (UART0), (UART1), (UART2),
        (UHCI0(unstable)), (UHCI1(unstable)), (WIFI(unstable)), (DMA_SPI2(unstable)),
        (DMA_SPI3(unstable)), (DMA_I2S0(unstable)), (DMA_I2S1(unstable)),
        (ADC1(unstable)), (ADC2(unstable)), (BT(unstable)), (CPU_CTRL(unstable)),
        (DAC1(unstable)), (DAC2(unstable)), (FLASH(unstable)), (PSRAM(unstable)),
        (SW_INTERRUPT(unstable)), (TOUCH(unstable))));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, GPIO0(_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK)
        ([Input] [Output]))); _for_each_inner!((1, GPIO1(_5 => EMAC_RXD2) (_0 => U0TXD _1
        => CLK_OUT3) ([Input] [Output]))); _for_each_inner!((2, GPIO2(_1 => HSPIWP _3 =>
        HS2_DATA0 _4 => SD_DATA0) (_1 => HSPIWP _3 => HS2_DATA0 _4 => SD_DATA0) ([Input]
        [Output]))); _for_each_inner!((3, GPIO3(_0 => U0RXD) (_1 => CLK_OUT2) ([Input]
        [Output]))); _for_each_inner!((4, GPIO4(_1 => HSPIHD _3 => HS2_DATA1 _4 =>
        SD_DATA1 _5 => EMAC_TX_ER) (_1 => HSPIHD _3 => HS2_DATA1 _4 => SD_DATA1 _5 =>
        EMAC_TX_ER) ([Input] [Output]))); _for_each_inner!((5, GPIO5(_1 => VSPICS0 _3 =>
        HS1_DATA6 _5 => EMAC_RX_CLK) (_1 => VSPICS0 _3 => HS1_DATA6) ([Input]
        [Output]))); _for_each_inner!((6, GPIO6(_1 => SPICLK _4 => U1CTS) (_0 => SD_CLK
        _1 => SPICLK _3 => HS1_CLK) ([Input] [Output]))); _for_each_inner!((7, GPIO7(_0
        => SD_DATA0 _1 => SPIQ _3 => HS1_DATA0) (_0 => SD_DATA0 _1 => SPIQ _3 =>
        HS1_DATA0 _4 => U2RTS) ([Input] [Output]))); _for_each_inner!((8, GPIO8(_0 =>
        SD_DATA1 _1 => SPID _3 => HS1_DATA1 _4 => U2CTS) (_0 => SD_DATA1 _1 => SPID _3 =>
        HS1_DATA1) ([Input] [Output]))); _for_each_inner!((9, GPIO9(_0 => SD_DATA2 _1 =>
        SPIHD _3 => HS1_DATA2 _4 => U1RXD) (_0 => SD_DATA2 _1 => SPIHD _3 => HS1_DATA2)
        ([Input] [Output]))); _for_each_inner!((10, GPIO10(_0 => SD_DATA3 _1 => SPIWP _3
        => HS1_DATA3) (_0 => SD_DATA3 _1 => SPIWP _3 => HS1_DATA3 _4 => U1TXD) ([Input]
        [Output]))); _for_each_inner!((11, GPIO11(_0 => SD_CMD _1 => SPICS0) (_0 =>
        SD_CMD _1 => SPICS0 _3 => HS1_CMD _4 => U1RTS) ([Input] [Output])));
        _for_each_inner!((12, GPIO12(_0 => MTDI _1 => HSPIQ _3 => HS2_DATA2 _4 =>
        SD_DATA2) (_1 => HSPIQ _3 => HS2_DATA2 _4 => SD_DATA2 _5 => EMAC_TXD3) ([Input]
        [Output]))); _for_each_inner!((13, GPIO13(_0 => MTCK _1 => HSPID _3 => HS2_DATA3
        _4 => SD_DATA3 _5 => EMAC_RX_ER) (_1 => HSPID _3 => HS2_DATA3 _4 => SD_DATA3 _5
        => EMAC_RX_ER) ([Input] [Output]))); _for_each_inner!((14, GPIO14(_0 => MTMS _1
        => HSPICLK) (_1 => HSPICLK _3 => HS2_CLK _4 => SD_CLK _5 => EMAC_TXD2) ([Input]
        [Output]))); _for_each_inner!((15, GPIO15(_1 => HSPICS0 _4 => SD_CMD _5 =>
        EMAC_RXD3) (_0 => MTDO _1 => HSPICS0 _3 => HS2_CMD _4 => SD_CMD) ([Input]
        [Output]))); _for_each_inner!((16, GPIO16(_3 => HS1_DATA4 _4 => U2RXD) (_3 =>
        HS1_DATA4 _5 => EMAC_CLK_OUT) ([Input] [Output]))); _for_each_inner!((17,
        GPIO17(_3 => HS1_DATA5) (_3 => HS1_DATA5 _4 => U2TXD _5 => EMAC_CLK_180) ([Input]
        [Output]))); _for_each_inner!((18, GPIO18(_1 => VSPICLK _3 => HS1_DATA7) (_1 =>
        VSPICLK _3 => HS1_DATA7) ([Input] [Output]))); _for_each_inner!((19, GPIO19(_1 =>
        VSPIQ _3 => U0CTS) (_1 => VSPIQ _5 => EMAC_TXD0) ([Input] [Output])));
        _for_each_inner!((20, GPIO20() () ([Input] [Output]))); _for_each_inner!((21,
        GPIO21(_1 => VSPIHD) (_1 => VSPIHD _5 => EMAC_TX_EN) ([Input] [Output])));
        _for_each_inner!((22, GPIO22(_1 => VSPIWP) (_1 => VSPIWP _3 => U0RTS _5 =>
        EMAC_TXD1) ([Input] [Output]))); _for_each_inner!((23, GPIO23(_1 => VSPID) (_1 =>
        VSPID _3 => HS1_STROBE) ([Input] [Output]))); _for_each_inner!((25, GPIO25(_5 =>
        EMAC_RXD0) () ([Input] [Output]))); _for_each_inner!((26, GPIO26(_5 => EMAC_RXD1)
        () ([Input] [Output]))); _for_each_inner!((27, GPIO27(_5 => EMAC_RX_DV) ()
        ([Input] [Output]))); _for_each_inner!((32, GPIO32() () ([Input] [Output])));
        _for_each_inner!((33, GPIO33() () ([Input] [Output]))); _for_each_inner!((34,
        GPIO34() () ([Input] []))); _for_each_inner!((35, GPIO35() () ([Input] [])));
        _for_each_inner!((36, GPIO36() () ([Input] []))); _for_each_inner!((37, GPIO37()
        () ([Input] []))); _for_each_inner!((38, GPIO38() () ([Input] [])));
        _for_each_inner!((39, GPIO39() () ([Input] []))); _for_each_inner!((all(0,
        GPIO0(_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input] [Output])),
        (1, GPIO1(_5 => EMAC_RXD2) (_0 => U0TXD _1 => CLK_OUT3) ([Input] [Output])), (2,
        GPIO2(_1 => HSPIWP _3 => HS2_DATA0 _4 => SD_DATA0) (_1 => HSPIWP _3 => HS2_DATA0
        _4 => SD_DATA0) ([Input] [Output])), (3, GPIO3(_0 => U0RXD) (_1 => CLK_OUT2)
        ([Input] [Output])), (4, GPIO4(_1 => HSPIHD _3 => HS2_DATA1 _4 => SD_DATA1 _5 =>
        EMAC_TX_ER) (_1 => HSPIHD _3 => HS2_DATA1 _4 => SD_DATA1 _5 => EMAC_TX_ER)
        ([Input] [Output])), (5, GPIO5(_1 => VSPICS0 _3 => HS1_DATA6 _5 => EMAC_RX_CLK)
        (_1 => VSPICS0 _3 => HS1_DATA6) ([Input] [Output])), (6, GPIO6(_1 => SPICLK _4 =>
        U1CTS) (_0 => SD_CLK _1 => SPICLK _3 => HS1_CLK) ([Input] [Output])), (7,
        GPIO7(_0 => SD_DATA0 _1 => SPIQ _3 => HS1_DATA0) (_0 => SD_DATA0 _1 => SPIQ _3 =>
        HS1_DATA0 _4 => U2RTS) ([Input] [Output])), (8, GPIO8(_0 => SD_DATA1 _1 => SPID
        _3 => HS1_DATA1 _4 => U2CTS) (_0 => SD_DATA1 _1 => SPID _3 => HS1_DATA1) ([Input]
        [Output])), (9, GPIO9(_0 => SD_DATA2 _1 => SPIHD _3 => HS1_DATA2 _4 => U1RXD) (_0
        => SD_DATA2 _1 => SPIHD _3 => HS1_DATA2) ([Input] [Output])), (10, GPIO10(_0 =>
        SD_DATA3 _1 => SPIWP _3 => HS1_DATA3) (_0 => SD_DATA3 _1 => SPIWP _3 => HS1_DATA3
        _4 => U1TXD) ([Input] [Output])), (11, GPIO11(_0 => SD_CMD _1 => SPICS0) (_0 =>
        SD_CMD _1 => SPICS0 _3 => HS1_CMD _4 => U1RTS) ([Input] [Output])), (12,
        GPIO12(_0 => MTDI _1 => HSPIQ _3 => HS2_DATA2 _4 => SD_DATA2) (_1 => HSPIQ _3 =>
        HS2_DATA2 _4 => SD_DATA2 _5 => EMAC_TXD3) ([Input] [Output])), (13, GPIO13(_0 =>
        MTCK _1 => HSPID _3 => HS2_DATA3 _4 => SD_DATA3 _5 => EMAC_RX_ER) (_1 => HSPID _3
        => HS2_DATA3 _4 => SD_DATA3 _5 => EMAC_RX_ER) ([Input] [Output])), (14, GPIO14(_0
        => MTMS _1 => HSPICLK) (_1 => HSPICLK _3 => HS2_CLK _4 => SD_CLK _5 => EMAC_TXD2)
        ([Input] [Output])), (15, GPIO15(_1 => HSPICS0 _4 => SD_CMD _5 => EMAC_RXD3) (_0
        => MTDO _1 => HSPICS0 _3 => HS2_CMD _4 => SD_CMD) ([Input] [Output])), (16,
        GPIO16(_3 => HS1_DATA4 _4 => U2RXD) (_3 => HS1_DATA4 _5 => EMAC_CLK_OUT) ([Input]
        [Output])), (17, GPIO17(_3 => HS1_DATA5) (_3 => HS1_DATA5 _4 => U2TXD _5 =>
        EMAC_CLK_180) ([Input] [Output])), (18, GPIO18(_1 => VSPICLK _3 => HS1_DATA7) (_1
        => VSPICLK _3 => HS1_DATA7) ([Input] [Output])), (19, GPIO19(_1 => VSPIQ _3 =>
        U0CTS) (_1 => VSPIQ _5 => EMAC_TXD0) ([Input] [Output])), (20, GPIO20() ()
        ([Input] [Output])), (21, GPIO21(_1 => VSPIHD) (_1 => VSPIHD _5 => EMAC_TX_EN)
        ([Input] [Output])), (22, GPIO22(_1 => VSPIWP) (_1 => VSPIWP _3 => U0RTS _5 =>
        EMAC_TXD1) ([Input] [Output])), (23, GPIO23(_1 => VSPID) (_1 => VSPID _3 =>
        HS1_STROBE) ([Input] [Output])), (25, GPIO25(_5 => EMAC_RXD0) () ([Input]
        [Output])), (26, GPIO26(_5 => EMAC_RXD1) () ([Input] [Output])), (27, GPIO27(_5
        => EMAC_RX_DV) () ([Input] [Output])), (32, GPIO32() () ([Input] [Output])), (33,
        GPIO33() () ([Input] [Output])), (34, GPIO34() () ([Input] [])), (35, GPIO35() ()
        ([Input] [])), (36, GPIO36() () ([Input] [])), (37, GPIO37() () ([Input] [])),
        (38, GPIO38() () ([Input] [])), (39, GPIO39() () ([Input] []))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((ADC2_CH1, GPIO0)); _for_each_inner!((TOUCH1, GPIO0));
        _for_each_inner!((ADC2_CH2, GPIO2)); _for_each_inner!((TOUCH2, GPIO2));
        _for_each_inner!((ADC2_CH0, GPIO4)); _for_each_inner!((TOUCH0, GPIO4));
        _for_each_inner!((ADC2_CH5, GPIO12)); _for_each_inner!((TOUCH5, GPIO12));
        _for_each_inner!((ADC2_CH4, GPIO13)); _for_each_inner!((TOUCH4, GPIO13));
        _for_each_inner!((ADC2_CH6, GPIO14)); _for_each_inner!((TOUCH6, GPIO14));
        _for_each_inner!((ADC2_CH3, GPIO15)); _for_each_inner!((TOUCH3, GPIO15));
        _for_each_inner!((DAC1, GPIO25)); _for_each_inner!((ADC2_CH8, GPIO25));
        _for_each_inner!((DAC2, GPIO26)); _for_each_inner!((ADC2_CH9, GPIO26));
        _for_each_inner!((ADC2_CH7, GPIO27)); _for_each_inner!((TOUCH7, GPIO27));
        _for_each_inner!((XTAL_32K_P, GPIO32)); _for_each_inner!((ADC1_CH4, GPIO32));
        _for_each_inner!((TOUCH9, GPIO32)); _for_each_inner!((XTAL_32K_N, GPIO33));
        _for_each_inner!((ADC1_CH5, GPIO33)); _for_each_inner!((TOUCH8, GPIO33));
        _for_each_inner!((ADC1_CH6, GPIO34)); _for_each_inner!((ADC1_CH7, GPIO35));
        _for_each_inner!((ADC_H, GPIO36)); _for_each_inner!((ADC1_CH0, GPIO36));
        _for_each_inner!((ADC_H, GPIO37)); _for_each_inner!((ADC1_CH1, GPIO37));
        _for_each_inner!((ADC_H, GPIO38)); _for_each_inner!((ADC1_CH2, GPIO38));
        _for_each_inner!((ADC_H, GPIO39)); _for_each_inner!((ADC1_CH3, GPIO39));
        _for_each_inner!(((ADC2_CH1, ADCn_CHm, 2, 1), GPIO0)); _for_each_inner!(((TOUCH1,
        TOUCHn, 1), GPIO0)); _for_each_inner!(((ADC2_CH2, ADCn_CHm, 2, 2), GPIO2));
        _for_each_inner!(((TOUCH2, TOUCHn, 2), GPIO2)); _for_each_inner!(((ADC2_CH0,
        ADCn_CHm, 2, 0), GPIO4)); _for_each_inner!(((TOUCH0, TOUCHn, 0), GPIO4));
        _for_each_inner!(((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12));
        _for_each_inner!(((TOUCH5, TOUCHn, 5), GPIO12)); _for_each_inner!(((ADC2_CH4,
        ADCn_CHm, 2, 4), GPIO13)); _for_each_inner!(((TOUCH4, TOUCHn, 4), GPIO13));
        _for_each_inner!(((ADC2_CH6, ADCn_CHm, 2, 6), GPIO14));
        _for_each_inner!(((TOUCH6, TOUCHn, 6), GPIO14)); _for_each_inner!(((ADC2_CH3,
        ADCn_CHm, 2, 3), GPIO15)); _for_each_inner!(((TOUCH3, TOUCHn, 3), GPIO15));
        _for_each_inner!(((DAC1, DACn, 1), GPIO25)); _for_each_inner!(((ADC2_CH8,
        ADCn_CHm, 2, 8), GPIO25)); _for_each_inner!(((DAC2, DACn, 2), GPIO26));
        _for_each_inner!(((ADC2_CH9, ADCn_CHm, 2, 9), GPIO26));
        _for_each_inner!(((ADC2_CH7, ADCn_CHm, 2, 7), GPIO27));
        _for_each_inner!(((TOUCH7, TOUCHn, 7), GPIO27)); _for_each_inner!(((ADC1_CH4,
        ADCn_CHm, 1, 4), GPIO32)); _for_each_inner!(((TOUCH9, TOUCHn, 9), GPIO32));
        _for_each_inner!(((ADC1_CH5, ADCn_CHm, 1, 5), GPIO33));
        _for_each_inner!(((TOUCH8, TOUCHn, 8), GPIO33)); _for_each_inner!(((ADC1_CH6,
        ADCn_CHm, 1, 6), GPIO34)); _for_each_inner!(((ADC1_CH7, ADCn_CHm, 1, 7),
        GPIO35)); _for_each_inner!(((ADC1_CH0, ADCn_CHm, 1, 0), GPIO36));
        _for_each_inner!(((ADC1_CH1, ADCn_CHm, 1, 1), GPIO37));
        _for_each_inner!(((ADC1_CH2, ADCn_CHm, 1, 2), GPIO38));
        _for_each_inner!(((ADC1_CH3, ADCn_CHm, 1, 3), GPIO39));
        _for_each_inner!((all(ADC2_CH1, GPIO0), (TOUCH1, GPIO0), (ADC2_CH2, GPIO2),
        (TOUCH2, GPIO2), (ADC2_CH0, GPIO4), (TOUCH0, GPIO4), (ADC2_CH5, GPIO12), (TOUCH5,
        GPIO12), (ADC2_CH4, GPIO13), (TOUCH4, GPIO13), (ADC2_CH6, GPIO14), (TOUCH6,
        GPIO14), (ADC2_CH3, GPIO15), (TOUCH3, GPIO15), (DAC1, GPIO25), (ADC2_CH8,
        GPIO25), (DAC2, GPIO26), (ADC2_CH9, GPIO26), (ADC2_CH7, GPIO27), (TOUCH7,
        GPIO27), (XTAL_32K_P, GPIO32), (ADC1_CH4, GPIO32), (TOUCH9, GPIO32), (XTAL_32K_N,
        GPIO33), (ADC1_CH5, GPIO33), (TOUCH8, GPIO33), (ADC1_CH6, GPIO34), (ADC1_CH7,
        GPIO35), (ADC_H, GPIO36), (ADC1_CH0, GPIO36), (ADC_H, GPIO37), (ADC1_CH1,
        GPIO37), (ADC_H, GPIO38), (ADC1_CH2, GPIO38), (ADC_H, GPIO39), (ADC1_CH3,
        GPIO39))); _for_each_inner!((all_expanded((ADC2_CH1, ADCn_CHm, 2, 1), GPIO0),
        ((TOUCH1, TOUCHn, 1), GPIO0), ((ADC2_CH2, ADCn_CHm, 2, 2), GPIO2), ((TOUCH2,
        TOUCHn, 2), GPIO2), ((ADC2_CH0, ADCn_CHm, 2, 0), GPIO4), ((TOUCH0, TOUCHn, 0),
        GPIO4), ((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12), ((TOUCH5, TOUCHn, 5), GPIO12),
        ((ADC2_CH4, ADCn_CHm, 2, 4), GPIO13), ((TOUCH4, TOUCHn, 4), GPIO13), ((ADC2_CH6,
        ADCn_CHm, 2, 6), GPIO14), ((TOUCH6, TOUCHn, 6), GPIO14), ((ADC2_CH3, ADCn_CHm, 2,
        3), GPIO15), ((TOUCH3, TOUCHn, 3), GPIO15), ((DAC1, DACn, 1), GPIO25),
        ((ADC2_CH8, ADCn_CHm, 2, 8), GPIO25), ((DAC2, DACn, 2), GPIO26), ((ADC2_CH9,
        ADCn_CHm, 2, 9), GPIO26), ((ADC2_CH7, ADCn_CHm, 2, 7), GPIO27), ((TOUCH7, TOUCHn,
        7), GPIO27), ((ADC1_CH4, ADCn_CHm, 1, 4), GPIO32), ((TOUCH9, TOUCHn, 9), GPIO32),
        ((ADC1_CH5, ADCn_CHm, 1, 5), GPIO33), ((TOUCH8, TOUCHn, 8), GPIO33), ((ADC1_CH6,
        ADCn_CHm, 1, 6), GPIO34), ((ADC1_CH7, ADCn_CHm, 1, 7), GPIO35), ((ADC1_CH0,
        ADCn_CHm, 1, 0), GPIO36), ((ADC1_CH1, ADCn_CHm, 1, 1), GPIO37), ((ADC1_CH2,
        ADCn_CHm, 1, 2), GPIO38), ((ADC1_CH3, ADCn_CHm, 1, 3), GPIO39)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((RTC_GPIO11, GPIO0)); _for_each_inner!((SAR_I2C_SDA, GPIO0));
        _for_each_inner!((RTC_GPIO12, GPIO2)); _for_each_inner!((SAR_I2C_SCL, GPIO2));
        _for_each_inner!((RTC_GPIO10, GPIO4)); _for_each_inner!((SAR_I2C_SCL, GPIO4));
        _for_each_inner!((RTC_GPIO15, GPIO12)); _for_each_inner!((RTC_GPIO14, GPIO13));
        _for_each_inner!((RTC_GPIO16, GPIO14)); _for_each_inner!((RTC_GPIO13, GPIO15));
        _for_each_inner!((SAR_I2C_SDA, GPIO15)); _for_each_inner!((RTC_GPIO6, GPIO25));
        _for_each_inner!((RTC_GPIO7, GPIO26)); _for_each_inner!((RTC_GPIO17, GPIO27));
        _for_each_inner!((RTC_GPIO9, GPIO32)); _for_each_inner!((RTC_GPIO8, GPIO33));
        _for_each_inner!((RTC_GPIO4, GPIO34)); _for_each_inner!((RTC_GPIO5, GPIO35));
        _for_each_inner!((RTC_GPIO0, GPIO36)); _for_each_inner!((RTC_GPIO1, GPIO37));
        _for_each_inner!((RTC_GPIO2, GPIO38)); _for_each_inner!((RTC_GPIO3, GPIO39));
        _for_each_inner!(((RTC_GPIO11, RTC_GPIOn, 11), GPIO0));
        _for_each_inner!(((RTC_GPIO12, RTC_GPIOn, 12), GPIO2));
        _for_each_inner!(((RTC_GPIO10, RTC_GPIOn, 10), GPIO4));
        _for_each_inner!(((RTC_GPIO15, RTC_GPIOn, 15), GPIO12));
        _for_each_inner!(((RTC_GPIO14, RTC_GPIOn, 14), GPIO13));
        _for_each_inner!(((RTC_GPIO16, RTC_GPIOn, 16), GPIO14));
        _for_each_inner!(((RTC_GPIO13, RTC_GPIOn, 13), GPIO15));
        _for_each_inner!(((RTC_GPIO6, RTC_GPIOn, 6), GPIO25));
        _for_each_inner!(((RTC_GPIO7, RTC_GPIOn, 7), GPIO26));
        _for_each_inner!(((RTC_GPIO17, RTC_GPIOn, 17), GPIO27));
        _for_each_inner!(((RTC_GPIO9, RTC_GPIOn, 9), GPIO32));
        _for_each_inner!(((RTC_GPIO8, RTC_GPIOn, 8), GPIO33));
        _for_each_inner!(((RTC_GPIO4, RTC_GPIOn, 4), GPIO34));
        _for_each_inner!(((RTC_GPIO5, RTC_GPIOn, 5), GPIO35));
        _for_each_inner!(((RTC_GPIO0, RTC_GPIOn, 0), GPIO36));
        _for_each_inner!(((RTC_GPIO1, RTC_GPIOn, 1), GPIO37));
        _for_each_inner!(((RTC_GPIO2, RTC_GPIOn, 2), GPIO38));
        _for_each_inner!(((RTC_GPIO3, RTC_GPIOn, 3), GPIO39));
        _for_each_inner!((all(RTC_GPIO11, GPIO0), (SAR_I2C_SDA, GPIO0), (RTC_GPIO12,
        GPIO2), (SAR_I2C_SCL, GPIO2), (RTC_GPIO10, GPIO4), (SAR_I2C_SCL, GPIO4),
        (RTC_GPIO15, GPIO12), (RTC_GPIO14, GPIO13), (RTC_GPIO16, GPIO14), (RTC_GPIO13,
        GPIO15), (SAR_I2C_SDA, GPIO15), (RTC_GPIO6, GPIO25), (RTC_GPIO7, GPIO26),
        (RTC_GPIO17, GPIO27), (RTC_GPIO9, GPIO32), (RTC_GPIO8, GPIO33), (RTC_GPIO4,
        GPIO34), (RTC_GPIO5, GPIO35), (RTC_GPIO0, GPIO36), (RTC_GPIO1, GPIO37),
        (RTC_GPIO2, GPIO38), (RTC_GPIO3, GPIO39)));
        _for_each_inner!((all_expanded((RTC_GPIO11, RTC_GPIOn, 11), GPIO0), ((RTC_GPIO12,
        RTC_GPIOn, 12), GPIO2), ((RTC_GPIO10, RTC_GPIOn, 10), GPIO4), ((RTC_GPIO15,
        RTC_GPIOn, 15), GPIO12), ((RTC_GPIO14, RTC_GPIOn, 14), GPIO13), ((RTC_GPIO16,
        RTC_GPIOn, 16), GPIO14), ((RTC_GPIO13, RTC_GPIOn, 13), GPIO15), ((RTC_GPIO6,
        RTC_GPIOn, 6), GPIO25), ((RTC_GPIO7, RTC_GPIOn, 7), GPIO26), ((RTC_GPIO17,
        RTC_GPIOn, 17), GPIO27), ((RTC_GPIO9, RTC_GPIOn, 9), GPIO32), ((RTC_GPIO8,
        RTC_GPIOn, 8), GPIO33), ((RTC_GPIO4, RTC_GPIOn, 4), GPIO34), ((RTC_GPIO5,
        RTC_GPIOn, 5), GPIO35), ((RTC_GPIO0, RTC_GPIOn, 0), GPIO36), ((RTC_GPIO1,
        RTC_GPIOn, 1), GPIO37), ((RTC_GPIO2, RTC_GPIOn, 2), GPIO38), ((RTC_GPIO3,
        RTC_GPIOn, 3), GPIO39)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            SPICLK                = 0,
            SPIQ                  = 1,
            SPID                  = 2,
            SPIHD                 = 3,
            SPIWP                 = 4,
            SPICS0                = 5,
            SPICS1                = 6,
            SPICS2                = 7,
            HSPICLK               = 8,
            HSPIQ                 = 9,
            HSPID                 = 10,
            HSPICS0               = 11,
            HSPIHD                = 12,
            HSPIWP                = 13,
            U0RXD                 = 14,
            U0CTS                 = 15,
            U0DSR                 = 16,
            U1RXD                 = 17,
            U1CTS                 = 18,
            I2S0O_BCK             = 23,
            I2S1O_BCK             = 24,
            I2S0O_WS              = 25,
            I2S1O_WS              = 26,
            I2S0I_BCK             = 27,
            I2S0I_WS              = 28,
            I2CEXT0_SCL           = 29,
            I2CEXT0_SDA           = 30,
            PWM0_SYNC0            = 31,
            PWM0_SYNC1            = 32,
            PWM0_SYNC2            = 33,
            PWM0_F0               = 34,
            PWM0_F1               = 35,
            PWM0_F2               = 36,
            PCNT0_SIG_CH0         = 39,
            PCNT0_SIG_CH1         = 40,
            PCNT0_CTRL_CH0        = 41,
            PCNT0_CTRL_CH1        = 42,
            PCNT1_SIG_CH0         = 43,
            PCNT1_SIG_CH1         = 44,
            PCNT1_CTRL_CH0        = 45,
            PCNT1_CTRL_CH1        = 46,
            PCNT2_SIG_CH0         = 47,
            PCNT2_SIG_CH1         = 48,
            PCNT2_CTRL_CH0        = 49,
            PCNT2_CTRL_CH1        = 50,
            PCNT3_SIG_CH0         = 51,
            PCNT3_SIG_CH1         = 52,
            PCNT3_CTRL_CH0        = 53,
            PCNT3_CTRL_CH1        = 54,
            PCNT4_SIG_CH0         = 55,
            PCNT4_SIG_CH1         = 56,
            PCNT4_CTRL_CH0        = 57,
            PCNT4_CTRL_CH1        = 58,
            HSPICS1               = 61,
            HSPICS2               = 62,
            VSPICLK               = 63,
            VSPIQ                 = 64,
            VSPID                 = 65,
            VSPIHD                = 66,
            VSPIWP                = 67,
            VSPICS0               = 68,
            VSPICS1               = 69,
            VSPICS2               = 70,
            PCNT5_SIG_CH0         = 71,
            PCNT5_SIG_CH1         = 72,
            PCNT5_CTRL_CH0        = 73,
            PCNT5_CTRL_CH1        = 74,
            PCNT6_SIG_CH0         = 75,
            PCNT6_SIG_CH1         = 76,
            PCNT6_CTRL_CH0        = 77,
            PCNT6_CTRL_CH1        = 78,
            PCNT7_SIG_CH0         = 79,
            PCNT7_SIG_CH1         = 80,
            PCNT7_CTRL_CH0        = 81,
            PCNT7_CTRL_CH1        = 82,
            RMT_SIG_0             = 83,
            RMT_SIG_1             = 84,
            RMT_SIG_2             = 85,
            RMT_SIG_3             = 86,
            RMT_SIG_4             = 87,
            RMT_SIG_5             = 88,
            RMT_SIG_6             = 89,
            RMT_SIG_7             = 90,
            TWAI_RX               = 94,
            I2CEXT1_SCL           = 95,
            I2CEXT1_SDA           = 96,
            HOST_CARD_DETECT_N_1  = 97,
            HOST_CARD_DETECT_N_2  = 98,
            HOST_CARD_WRITE_PRT_1 = 99,
            HOST_CARD_WRITE_PRT_2 = 100,
            HOST_CARD_INT_N_1     = 101,
            HOST_CARD_INT_N_2     = 102,
            PWM1_SYNC0            = 103,
            PWM1_SYNC1            = 104,
            PWM1_SYNC2            = 105,
            PWM1_F0               = 106,
            PWM1_F1               = 107,
            PWM1_F2               = 108,
            PWM0_CAP0             = 109,
            PWM0_CAP1             = 110,
            PWM0_CAP2             = 111,
            PWM1_CAP0             = 112,
            PWM1_CAP1             = 113,
            PWM1_CAP2             = 114,
            I2S0I_DATA_0          = 140,
            I2S0I_DATA_1          = 141,
            I2S0I_DATA_2          = 142,
            I2S0I_DATA_3          = 143,
            I2S0I_DATA_4          = 144,
            I2S0I_DATA_5          = 145,
            I2S0I_DATA_6          = 146,
            I2S0I_DATA_7          = 147,
            I2S0I_DATA_8          = 148,
            I2S0I_DATA_9          = 149,
            I2S0I_DATA_10         = 150,
            I2S0I_DATA_11         = 151,
            I2S0I_DATA_12         = 152,
            I2S0I_DATA_13         = 153,
            I2S0I_DATA_14         = 154,
            I2S0I_DATA_15         = 155,
            I2S1I_BCK             = 164,
            I2S1I_WS              = 165,
            I2S1I_DATA_0          = 166,
            I2S1I_DATA_1          = 167,
            I2S1I_DATA_2          = 168,
            I2S1I_DATA_3          = 169,
            I2S1I_DATA_4          = 170,
            I2S1I_DATA_5          = 171,
            I2S1I_DATA_6          = 172,
            I2S1I_DATA_7          = 173,
            I2S1I_DATA_8          = 174,
            I2S1I_DATA_9          = 175,
            I2S1I_DATA_10         = 176,
            I2S1I_DATA_11         = 177,
            I2S1I_DATA_12         = 178,
            I2S1I_DATA_13         = 179,
            I2S1I_DATA_14         = 180,
            I2S1I_DATA_15         = 181,
            I2S0I_H_SYNC          = 190,
            I2S0I_V_SYNC          = 191,
            I2S0I_H_ENABLE        = 192,
            I2S1I_H_SYNC          = 193,
            I2S1I_V_SYNC          = 194,
            I2S1I_H_ENABLE        = 195,
            U2RXD                 = 198,
            U2CTS                 = 199,
            EMAC_MDC              = 200,
            EMAC_MDI              = 201,
            EMAC_CRS              = 202,
            EMAC_COL              = 203,
            PCMFSYNC              = 204,
            PCMCLK                = 205,
            PCMDIN                = 206,
            SD_CMD,
            SD_DATA0,
            SD_DATA1,
            SD_DATA2,
            SD_DATA3,
            HS1_DATA0,
            HS1_DATA1,
            HS1_DATA2,
            HS1_DATA3,
            HS1_DATA4,
            HS1_DATA5,
            HS1_DATA6,
            HS1_DATA7,
            HS2_DATA0,
            HS2_DATA1,
            HS2_DATA2,
            HS2_DATA3,
            EMAC_TX_CLK,
            EMAC_RXD2,
            EMAC_TX_ER,
            EMAC_RX_CLK,
            EMAC_RX_ER,
            EMAC_RXD3,
            EMAC_RXD0,
            EMAC_RXD1,
            EMAC_RX_DV,
            MTDI,
            MTCK,
            MTMS,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            SPICLK                   = 0,
            SPIQ                     = 1,
            SPID                     = 2,
            SPIHD                    = 3,
            SPIWP                    = 4,
            SPICS0                   = 5,
            SPICS1                   = 6,
            SPICS2                   = 7,
            HSPICLK                  = 8,
            HSPIQ                    = 9,
            HSPID                    = 10,
            HSPICS0                  = 11,
            HSPIHD                   = 12,
            HSPIWP                   = 13,
            U0TXD                    = 14,
            U0RTS                    = 15,
            U0DTR                    = 16,
            U1TXD                    = 17,
            U1RTS                    = 18,
            I2S0O_BCK                = 23,
            I2S1O_BCK                = 24,
            I2S0O_WS                 = 25,
            I2S1O_WS                 = 26,
            I2S0I_BCK                = 27,
            I2S0I_WS                 = 28,
            I2CEXT0_SCL              = 29,
            I2CEXT0_SDA              = 30,
            SDIO_TOHOSTT             = 31,
            PWM0_0A                  = 32,
            PWM0_0B                  = 33,
            PWM0_1A                  = 34,
            PWM0_1B                  = 35,
            PWM0_2A                  = 36,
            PWM0_2B                  = 37,
            HSPICS1                  = 61,
            HSPICS2                  = 62,
            VSPICLK                  = 63,
            VSPIQ                    = 64,
            VSPID                    = 65,
            VSPIHD                   = 66,
            VSPIWP                   = 67,
            VSPICS0                  = 68,
            VSPICS1                  = 69,
            VSPICS2                  = 70,
            LEDC_HS_SIG0             = 71,
            LEDC_HS_SIG1             = 72,
            LEDC_HS_SIG2             = 73,
            LEDC_HS_SIG3             = 74,
            LEDC_HS_SIG4             = 75,
            LEDC_HS_SIG5             = 76,
            LEDC_HS_SIG6             = 77,
            LEDC_HS_SIG7             = 78,
            LEDC_LS_SIG0             = 79,
            LEDC_LS_SIG1             = 80,
            LEDC_LS_SIG2             = 81,
            LEDC_LS_SIG3             = 82,
            LEDC_LS_SIG4             = 83,
            LEDC_LS_SIG5             = 84,
            LEDC_LS_SIG6             = 85,
            LEDC_LS_SIG7             = 86,
            RMT_SIG_0                = 87,
            RMT_SIG_1                = 88,
            RMT_SIG_2                = 89,
            RMT_SIG_3                = 90,
            RMT_SIG_4                = 91,
            RMT_SIG_5                = 92,
            RMT_SIG_6                = 93,
            RMT_SIG_7                = 94,
            I2CEXT1_SCL              = 95,
            I2CEXT1_SDA              = 96,
            HOST_CCMD_OD_PULLUP_EN_N = 97,
            HOST_RST_N_1             = 98,
            HOST_RST_N_2             = 99,
            GPIO_SD0                 = 100,
            GPIO_SD1                 = 101,
            GPIO_SD2                 = 102,
            GPIO_SD3                 = 103,
            GPIO_SD4                 = 104,
            GPIO_SD5                 = 105,
            GPIO_SD6                 = 106,
            GPIO_SD7                 = 107,
            PWM1_0A                  = 108,
            PWM1_0B                  = 109,
            PWM1_1A                  = 110,
            PWM1_1B                  = 111,
            PWM1_2A                  = 112,
            PWM1_2B                  = 113,
            TWAI_TX                  = 123,
            TWAI_BUS_OFF_ON          = 124,
            TWAI_CLKOUT              = 125,
            I2S0O_DATA_0             = 140,
            I2S0O_DATA_1             = 141,
            I2S0O_DATA_2             = 142,
            I2S0O_DATA_3             = 143,
            I2S0O_DATA_4             = 144,
            I2S0O_DATA_5             = 145,
            I2S0O_DATA_6             = 146,
            I2S0O_DATA_7             = 147,
            I2S0O_DATA_8             = 148,
            I2S0O_DATA_9             = 149,
            I2S0O_DATA_10            = 150,
            I2S0O_DATA_11            = 151,
            I2S0O_DATA_12            = 152,
            I2S0O_DATA_13            = 153,
            I2S0O_DATA_14            = 154,
            I2S0O_DATA_15            = 155,
            I2S0O_DATA_16            = 156,
            I2S0O_DATA_17            = 157,
            I2S0O_DATA_18            = 158,
            I2S0O_DATA_19            = 159,
            I2S0O_DATA_20            = 160,
            I2S0O_DATA_21            = 161,
            I2S0O_DATA_22            = 162,
            I2S0O_DATA_23            = 163,
            I2S1I_BCK                = 164,
            I2S1I_WS                 = 165,
            I2S1O_DATA_0             = 166,
            I2S1O_DATA_1             = 167,
            I2S1O_DATA_2             = 168,
            I2S1O_DATA_3             = 169,
            I2S1O_DATA_4             = 170,
            I2S1O_DATA_5             = 171,
            I2S1O_DATA_6             = 172,
            I2S1O_DATA_7             = 173,
            I2S1O_DATA_8             = 174,
            I2S1O_DATA_9             = 175,
            I2S1O_DATA_10            = 176,
            I2S1O_DATA_11            = 177,
            I2S1O_DATA_12            = 178,
            I2S1O_DATA_13            = 179,
            I2S1O_DATA_14            = 180,
            I2S1O_DATA_15            = 181,
            I2S1O_DATA_16            = 182,
            I2S1O_DATA_17            = 183,
            I2S1O_DATA_18            = 184,
            I2S1O_DATA_19            = 185,
            I2S1O_DATA_20            = 186,
            I2S1O_DATA_21            = 187,
            I2S1O_DATA_22            = 188,
            I2S1O_DATA_23            = 189,
            U2TXD                    = 198,
            U2RTS                    = 199,
            EMAC_MDC                 = 200,
            EMAC_MDO                 = 201,
            EMAC_CRS                 = 202,
            EMAC_COL                 = 203,
            BT_AUDIO0RQ              = 204,
            BT_AUDIO1RQ              = 205,
            BT_AUDIO2RQ              = 206,
            BLE_AUDIO0RQ             = 207,
            BLE_AUDIO1RQ             = 208,
            BLE_AUDIO2RQ             = 209,
            PCMFSYNC                 = 210,
            PCMCLK                   = 211,
            PCMDOUT                  = 212,
            BLE_AUDIO_SYNC0_P        = 213,
            BLE_AUDIO_SYNC1_P        = 214,
            BLE_AUDIO_SYNC2_P        = 215,
            ANT_SEL0                 = 216,
            ANT_SEL1                 = 217,
            ANT_SEL2                 = 218,
            ANT_SEL3                 = 219,
            ANT_SEL4                 = 220,
            ANT_SEL5                 = 221,
            ANT_SEL6                 = 222,
            ANT_SEL7                 = 223,
            SIGNAL_224               = 224,
            SIGNAL_225               = 225,
            SIGNAL_226               = 226,
            SIGNAL_227               = 227,
            SIGNAL_228               = 228,
            GPIO                     = 256,
            CLK_OUT1,
            CLK_OUT2,
            CLK_OUT3,
            SD_CLK,
            SD_CMD,
            SD_DATA0,
            SD_DATA1,
            SD_DATA2,
            SD_DATA3,
            HS1_CLK,
            HS1_CMD,
            HS1_DATA0,
            HS1_DATA1,
            HS1_DATA2,
            HS1_DATA3,
            HS1_DATA4,
            HS1_DATA5,
            HS1_DATA6,
            HS1_DATA7,
            HS1_STROBE,
            HS2_CLK,
            HS2_CMD,
            HS2_DATA0,
            HS2_DATA1,
            HS2_DATA2,
            HS2_DATA3,
            EMAC_TX_CLK,
            EMAC_TX_ER,
            EMAC_TXD3,
            EMAC_RX_ER,
            EMAC_TXD2,
            EMAC_CLK_OUT,
            EMAC_CLK_180,
            EMAC_TXD0,
            EMAC_TX_EN,
            EMAC_TXD1,
            MTDO,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
            let iomux = crate::peripherals::IO_MUX::regs();
            match gpio_num {
                0 => iomux.gpio0(),
                1 => iomux.gpio1(),
                2 => iomux.gpio2(),
                3 => iomux.gpio3(),
                4 => iomux.gpio4(),
                5 => iomux.gpio5(),
                6 => iomux.gpio6(),
                7 => iomux.gpio7(),
                8 => iomux.gpio8(),
                9 => iomux.gpio9(),
                10 => iomux.gpio10(),
                11 => iomux.gpio11(),
                12 => iomux.gpio12(),
                13 => iomux.gpio13(),
                14 => iomux.gpio14(),
                15 => iomux.gpio15(),
                16 => iomux.gpio16(),
                17 => iomux.gpio17(),
                18 => iomux.gpio18(),
                19 => iomux.gpio19(),
                20 => iomux.gpio20(),
                21 => iomux.gpio21(),
                22 => iomux.gpio22(),
                23 => iomux.gpio23(),
                25 => iomux.gpio25(),
                26 => iomux.gpio26(),
                27 => iomux.gpio27(),
                32 => iomux.gpio32(),
                33 => iomux.gpio33(),
                34 => iomux.gpio34(),
                35 => iomux.gpio35(),
                36 => iomux.gpio36(),
                37 => iomux.gpio37(),
                38 => iomux.gpio38(),
                39 => iomux.gpio39(),
                other => panic!("GPIO {} does not exist", other),
            }
        }
    };
}
