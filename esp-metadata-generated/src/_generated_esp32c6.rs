// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32c6"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32c6"
    };
    ("arch") => {
        "riscv"
    };
    ("cores") => {
        1
    };
    ("cores", str) => {
        stringify!(1)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-c6_technical_reference_manual_en.pdf"
    };
    ("soc.cpu_has_csr_pc") => {
        true
    };
    ("soc.cpu_has_prv_mode") => {
        true
    };
    ("soc.rc_fast_clk_default") => {
        17500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(17500000)
    };
    ("soc.rc_slow_clock") => {
        136000
    };
    ("soc.rc_slow_clock", str) => {
        stringify!(136000)
    };
    ("aes.dma") => {
        true
    };
    ("aes.has_split_text_registers") => {
        true
    };
    ("aes.endianness_configurable") => {
        false
    };
    ("assist_debug.has_sp_monitor") => {
        true
    };
    ("assist_debug.has_region_monitor") => {
        true
    };
    ("gpio.has_bank_1") => {
        false
    };
    ("gpio.gpio_function") => {
        1
    };
    ("gpio.gpio_function", str) => {
        stringify!(1)
    };
    ("gpio.constant_0_input") => {
        60
    };
    ("gpio.constant_0_input", str) => {
        stringify!(60)
    };
    ("gpio.constant_1_input") => {
        56
    };
    ("gpio.constant_1_input", str) => {
        stringify!(56)
    };
    ("gpio.remap_iomux_pin_registers") => {
        false
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        124
    };
    ("gpio.input_signal_max", str) => {
        stringify!(124)
    };
    ("gpio.output_signal_max") => {
        128
    };
    ("gpio.output_signal_max", str) => {
        stringify!(128)
    };
    ("dedicated_gpio.needs_initialization") => {
        false
    };
    ("dedicated_gpio.channel_count") => {
        8
    };
    ("dedicated_gpio.channel_count", str) => {
        stringify!(8)
    };
    ("i2c_master.has_fsm_timeouts") => {
        true
    };
    ("i2c_master.has_hw_bus_clear") => {
        true
    };
    ("i2c_master.has_bus_timeout_enable") => {
        true
    };
    ("i2c_master.separate_filter_config_registers") => {
        false
    };
    ("i2c_master.can_estimate_nack_reason") => {
        true
    };
    ("i2c_master.has_conf_update") => {
        true
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        true
    };
    ("i2c_master.has_arbitration_en") => {
        true
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        true
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        true
    };
    ("i2c_master.max_bus_timeout") => {
        31
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(31)
    };
    ("i2c_master.ll_intr_mask") => {
        262143
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(262143)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("lp_i2c_master.fifo_size") => {
        16
    };
    ("lp_i2c_master.fifo_size", str) => {
        stringify!(16)
    };
    ("interrupts.status_registers") => {
        3
    };
    ("interrupts.status_registers", str) => {
        stringify!(3)
    };
    ("rmt.ram_start") => {
        1610638336
    };
    ("rmt.ram_start", str) => {
        stringify!(1610638336)
    };
    ("rmt.channel_ram_size") => {
        48
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(48)
    };
    ("rmt.has_tx_immediate_stop") => {
        true
    };
    ("rmt.has_tx_loop_count") => {
        true
    };
    ("rmt.has_tx_loop_auto_stop") => {
        true
    };
    ("rmt.has_tx_carrier_data_only") => {
        true
    };
    ("rmt.has_tx_sync") => {
        true
    };
    ("rmt.has_rx_wrap") => {
        true
    };
    ("rmt.has_rx_demodulation") => {
        true
    };
    ("rmt.has_dma") => {
        false
    };
    ("rmt.has_per_channel_clock") => {
        false
    };
    ("rng.apb_cycle_wait_num") => {
        16
    };
    ("rng.apb_cycle_wait_num", str) => {
        stringify!(16)
    };
    ("rsa.size_increment") => {
        32
    };
    ("rsa.size_increment", str) => {
        stringify!(32)
    };
    ("rsa.memory_size_bytes") => {
        384
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(384)
    };
    ("sha.dma") => {
        true
    };
    ("spi_master.has_octal") => {
        false
    };
    ("timergroup.timg_has_timer1") => {
        false
    };
    ("timergroup.timg_has_divcnt_rst") => {
        true
    };
    ("uart.ram_size") => {
        128
    };
    ("uart.ram_size", str) => {
        stringify!(128)
    };
    ("uart.peripheral_controls_mem_clk") => {
        true
    };
    ("lp_uart.ram_size") => {
        32
    };
    ("lp_uart.ram_size", str) => {
        stringify!(32)
    };
    ("wifi.has_wifi6") => {
        true
    };
    ("bt.controller") => {
        "npl"
    };
    ("phy.combo_module") => {
        true
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, no_run
/// // XTAL_CLK
///
/// fn configure_xtal_clk_impl(_clocks: &mut ClockTree, _config: XtalClkConfig) {
///     todo!()
/// }
///
/// // PLL_CLK
///
/// fn enable_pll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_FAST_CLK
///
/// fn enable_rc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL32K_CLK
///
/// fn enable_xtal32k_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // OSC_SLOW_CLK
///
/// fn enable_osc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_SLOW_CLK
///
/// fn enable_rc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // HP_ROOT_CLK
///
/// fn enable_hp_root_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_hp_root_clk_impl(_clocks: &mut ClockTree, _new_config: HpRootClkConfig) {
///     todo!()
/// }
///
/// // CPU_CLK
///
/// fn configure_cpu_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<CpuClkConfig>,
///     _new_selector: CpuClkConfig,
/// ) {
///     todo!()
/// }
///
/// // AHB_CLK
///
/// fn configure_ahb_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<AhbClkConfig>,
///     _new_selector: AhbClkConfig,
/// ) {
///     todo!()
/// }
///
/// // MSPI_FAST_CLK
///
/// fn enable_mspi_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mspi_fast_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<MspiFastClkConfig>,
///     _new_selector: MspiFastClkConfig,
/// ) {
///     todo!()
/// }
///
/// // SOC_ROOT_CLK
///
/// fn enable_soc_root_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_soc_root_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<SocRootClkConfig>,
///     _new_selector: SocRootClkConfig,
/// ) {
///     todo!()
/// }
///
/// // CPU_HS_DIV
///
/// fn enable_cpu_hs_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_hs_div_impl(_clocks: &mut ClockTree, _new_config: CpuHsDivConfig) {
///     todo!()
/// }
///
/// // CPU_LS_DIV
///
/// fn enable_cpu_ls_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_ls_div_impl(_clocks: &mut ClockTree, _new_config: CpuLsDivConfig) {
///     todo!()
/// }
///
/// // AHB_HS_DIV
///
/// fn enable_ahb_hs_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ahb_hs_div_impl(_clocks: &mut ClockTree, _new_config: AhbHsDivConfig) {
///     todo!()
/// }
///
/// // AHB_LS_DIV
///
/// fn enable_ahb_ls_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ahb_ls_div_impl(_clocks: &mut ClockTree, _new_config: AhbLsDivConfig) {
///     todo!()
/// }
///
/// // APB_CLK
///
/// fn enable_apb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apb_clk_impl(_clocks: &mut ClockTree, _new_config: ApbClkConfig) {
///     todo!()
/// }
///
/// // MSPI_FAST_HS_CLK
///
/// fn enable_mspi_fast_hs_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mspi_fast_hs_clk_impl(_clocks: &mut ClockTree, _new_config: MspiFastHsClkConfig) {
///     todo!()
/// }
///
/// // MSPI_FAST_LS_CLK
///
/// fn enable_mspi_fast_ls_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mspi_fast_ls_clk_impl(_clocks: &mut ClockTree, _new_config: MspiFastLsClkConfig) {
///     todo!()
/// }
///
/// // PLL_F48M
///
/// fn enable_pll_f48m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F80M
///
/// fn enable_pll_f80m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F160M
///
/// fn enable_pll_f160m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // PLL_F240M
///
/// fn enable_pll_f240m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // LEDC_SCLK
///
/// fn enable_ledc_sclk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ledc_sclk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LedcSclkConfig>,
///     _new_selector: LedcSclkConfig,
/// ) {
///     todo!()
/// }
///
/// // XTAL_D2_CLK
///
/// fn enable_xtal_d2_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // LP_FAST_CLK
///
/// fn enable_lp_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_lp_fast_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LpFastClkConfig>,
///     _new_selector: LpFastClkConfig,
/// ) {
///     todo!()
/// }
///
/// // LP_SLOW_CLK
///
/// fn enable_lp_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_lp_slow_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<LpSlowClkConfig>,
///     _new_selector: LpSlowClkConfig,
/// ) {
///     todo!()
/// }
///
/// // MCPWM0_FUNCTION_CLOCK
///
/// fn enable_mcpwm0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_mcpwm0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Mcpwm0FunctionClockConfig>,
///     _new_selector: Mcpwm0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_FUNCTION_CLOCK
///
/// fn enable_timg0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_CALIBRATION_CLOCK
///
/// fn enable_timg0_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_WDT_CLOCK
///
/// fn enable_timg0_wdt_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_wdt_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0WdtClockConfig>,
///     _new_selector: Timg0WdtClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_FUNCTION_CLOCK
///
/// fn enable_timg1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_CALIBRATION_CLOCK
///
/// fn enable_timg1_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_WDT_CLOCK
///
/// fn enable_timg1_wdt_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_wdt_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0WdtClockConfig>,
///     _new_selector: Timg0WdtClockConfig,
/// ) {
///     todo!()
/// }
/// ```
macro_rules! define_clock_tree_types {
    () => {
        /// Selects the output frequency of `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum XtalClkConfig {
            /// 40 MHz
            _40,
        }
        impl XtalClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    XtalClkConfig::_40 => 40000000,
                }
            }
        }
        /// Configures the `HP_ROOT_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = SOC_ROOT_CLK / DIVISOR`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HpRootClkConfig {
            /// Selects `DIVISOR = 1`.
            _1 = 1,
            /// Selects `DIVISOR = 3`.
            _3 = 3,
        }
        impl HpRootClkConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    1 => HpRootClkConfig::_1,
                    3 => HpRootClkConfig::_3,
                    _ => ::core::panic!("Invalid HP_ROOT_CLK divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    HpRootClkConfig::_1 => 1,
                    HpRootClkConfig::_3 => 3,
                }
            }
        }
        /// The list of clock signals that the `CPU_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuClkConfig {
            /// Selects `CPU_HS_DIV`.
            Hs,
            /// Selects `CPU_LS_DIV`.
            Ls,
        }
        /// The list of clock signals that the `AHB_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum AhbClkConfig {
            /// Selects `AHB_HS_DIV`.
            Hs,
            /// Selects `AHB_LS_DIV`.
            Ls,
        }
        /// The list of clock signals that the `MSPI_FAST_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspiFastClkConfig {
            /// Selects `MSPI_FAST_HS_CLK`.
            Hs,
            /// Selects `MSPI_FAST_LS_CLK`.
            Ls,
        }
        /// The list of clock signals that the `SOC_ROOT_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SocRootClkConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
            /// Selects `PLL_CLK`.
            Pll,
        }
        /// Configures the `CPU_HS_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuHsDivConfig {
            /// Selects `DIVISOR = 0`.
            _0 = 0,
            /// Selects `DIVISOR = 1`.
            _1 = 1,
            /// Selects `DIVISOR = 3`.
            _3 = 3,
        }
        impl CpuHsDivConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    0 => CpuHsDivConfig::_0,
                    1 => CpuHsDivConfig::_1,
                    3 => CpuHsDivConfig::_3,
                    _ => ::core::panic!("Invalid CPU_HS_DIV divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    CpuHsDivConfig::_0 => 0,
                    CpuHsDivConfig::_1 => 1,
                    CpuHsDivConfig::_3 => 3,
                }
            }
        }
        /// Configures the `CPU_LS_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuLsDivConfig {
            /// Selects `DIVISOR = 0`.
            _0  = 0,
            /// Selects `DIVISOR = 1`.
            _1  = 1,
            /// Selects `DIVISOR = 3`.
            _3  = 3,
            /// Selects `DIVISOR = 7`.
            _7  = 7,
            /// Selects `DIVISOR = 15`.
            _15 = 15,
            /// Selects `DIVISOR = 31`.
            _31 = 31,
        }
        impl CpuLsDivConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    0 => CpuLsDivConfig::_0,
                    1 => CpuLsDivConfig::_1,
                    3 => CpuLsDivConfig::_3,
                    7 => CpuLsDivConfig::_7,
                    15 => CpuLsDivConfig::_15,
                    31 => CpuLsDivConfig::_31,
                    _ => ::core::panic!("Invalid CPU_LS_DIV divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    CpuLsDivConfig::_0 => 0,
                    CpuLsDivConfig::_1 => 1,
                    CpuLsDivConfig::_3 => 3,
                    CpuLsDivConfig::_7 => 7,
                    CpuLsDivConfig::_15 => 15,
                    CpuLsDivConfig::_31 => 31,
                }
            }
        }
        /// Configures the `AHB_HS_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum AhbHsDivConfig {
            /// Selects `DIVISOR = 3`.
            _3  = 3,
            /// Selects `DIVISOR = 7`.
            _7  = 7,
            /// Selects `DIVISOR = 15`.
            _15 = 15,
        }
        impl AhbHsDivConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    3 => AhbHsDivConfig::_3,
                    7 => AhbHsDivConfig::_7,
                    15 => AhbHsDivConfig::_15,
                    _ => ::core::panic!("Invalid AHB_HS_DIV divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    AhbHsDivConfig::_3 => 3,
                    AhbHsDivConfig::_7 => 7,
                    AhbHsDivConfig::_15 => 15,
                }
            }
        }
        /// Configures the `AHB_LS_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum AhbLsDivConfig {
            /// Selects `DIVISOR = 0`.
            _0  = 0,
            /// Selects `DIVISOR = 1`.
            _1  = 1,
            /// Selects `DIVISOR = 3`.
            _3  = 3,
            /// Selects `DIVISOR = 7`.
            _7  = 7,
            /// Selects `DIVISOR = 15`.
            _15 = 15,
            /// Selects `DIVISOR = 31`.
            _31 = 31,
        }
        impl AhbLsDivConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    0 => AhbLsDivConfig::_0,
                    1 => AhbLsDivConfig::_1,
                    3 => AhbLsDivConfig::_3,
                    7 => AhbLsDivConfig::_7,
                    15 => AhbLsDivConfig::_15,
                    31 => AhbLsDivConfig::_31,
                    _ => ::core::panic!("Invalid AHB_LS_DIV divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    AhbLsDivConfig::_0 => 0,
                    AhbLsDivConfig::_1 => 1,
                    AhbLsDivConfig::_3 => 3,
                    AhbLsDivConfig::_7 => 7,
                    AhbLsDivConfig::_15 => 15,
                    AhbLsDivConfig::_31 => 31,
                }
            }
        }
        /// Configures the `APB_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = AHB_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApbClkConfig {
            /// Selects `DIVISOR = 0`.
            _0 = 0,
            /// Selects `DIVISOR = 1`.
            _1 = 1,
            /// Selects `DIVISOR = 3`.
            _3 = 3,
        }
        impl ApbClkConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    0 => ApbClkConfig::_0,
                    1 => ApbClkConfig::_1,
                    3 => ApbClkConfig::_3,
                    _ => ::core::panic!("Invalid APB_CLK divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    ApbClkConfig::_0 => 0,
                    ApbClkConfig::_1 => 1,
                    ApbClkConfig::_3 => 3,
                }
            }
        }
        /// Configures the `MSPI_FAST_HS_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspiFastHsClkConfig {
            /// Selects `DIVISOR = 3`.
            _3 = 3,
            /// Selects `DIVISOR = 4`.
            _4 = 4,
            /// Selects `DIVISOR = 5`.
            _5 = 5,
        }
        impl MspiFastHsClkConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    3 => MspiFastHsClkConfig::_3,
                    4 => MspiFastHsClkConfig::_4,
                    5 => MspiFastHsClkConfig::_5,
                    _ => ::core::panic!("Invalid MSPI_FAST_HS_CLK divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    MspiFastHsClkConfig::_3 => 3,
                    MspiFastHsClkConfig::_4 => 4,
                    MspiFastHsClkConfig::_5 => 5,
                }
            }
        }
        /// Configures the `MSPI_FAST_LS_CLK` clock divider.
        ///
        /// The output is calculated as `OUTPUT = HP_ROOT_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspiFastLsClkConfig {
            /// Selects `DIVISOR = 0`.
            _0 = 0,
            /// Selects `DIVISOR = 1`.
            _1 = 1,
            /// Selects `DIVISOR = 2`.
            _2 = 2,
        }
        impl MspiFastLsClkConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    0 => MspiFastLsClkConfig::_0,
                    1 => MspiFastLsClkConfig::_1,
                    2 => MspiFastLsClkConfig::_2,
                    _ => ::core::panic!("Invalid MSPI_FAST_LS_CLK divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    MspiFastLsClkConfig::_0 => 0,
                    MspiFastLsClkConfig::_1 => 1,
                    MspiFastLsClkConfig::_2 => 2,
                }
            }
        }
        /// The list of clock signals that the `LEDC_SCLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LedcSclkConfig {
            /// Selects `PLL_F80M`.
            PllF80m,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            /// Selects `XTAL_CLK`.
            XtalClk,
        }
        /// The list of clock signals that the `LP_FAST_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LpFastClkConfig {
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            /// Selects `XTAL_D2_CLK`.
            XtalD2Clk,
        }
        /// The list of clock signals that the `LP_SLOW_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LpSlowClkConfig {
            /// Selects `XTAL32K_CLK`.
            Xtal32kClk,
            /// Selects `RC_SLOW_CLK`.
            RcSlow,
            /// Selects `OSC_SLOW_CLK`.
            OscSlow,
        }
        /// The list of clock signals that the `MCPWM0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcpwm0FunctionClockConfig {
            #[default]
            /// Selects `PLL_F160M`.
            PllF160m,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            /// Selects `XTAL_CLK`.
            XtalClk,
        }
        /// The list of clock signals that the `TIMG0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0FunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            /// Selects `PLL_F80M`.
            PllF80m,
        }
        /// The list of clock signals that the `TIMG0_CALIBRATION_CLOCK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0CalibrationClockConfig {
            /// Selects `LP_SLOW_CLK`.
            RtcSlowClk,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
            /// Selects `XTAL32K_CLK`.
            Xtal32kClk,
        }
        /// The list of clock signals that the `TIMG0_WDT_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0WdtClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `PLL_F80M`.
            PllF80m,
            /// Selects `RC_FAST_CLK`.
            RcFastClk,
        }
        /// Represents the device's clock tree.
        pub struct ClockTree {
            xtal_clk: Option<XtalClkConfig>,
            hp_root_clk: Option<HpRootClkConfig>,
            cpu_clk: Option<CpuClkConfig>,
            ahb_clk: Option<AhbClkConfig>,
            mspi_fast_clk: Option<MspiFastClkConfig>,
            soc_root_clk: Option<SocRootClkConfig>,
            cpu_hs_div: Option<CpuHsDivConfig>,
            cpu_ls_div: Option<CpuLsDivConfig>,
            ahb_hs_div: Option<AhbHsDivConfig>,
            ahb_ls_div: Option<AhbLsDivConfig>,
            apb_clk: Option<ApbClkConfig>,
            mspi_fast_hs_clk: Option<MspiFastHsClkConfig>,
            mspi_fast_ls_clk: Option<MspiFastLsClkConfig>,
            ledc_sclk: Option<LedcSclkConfig>,
            lp_fast_clk: Option<LpFastClkConfig>,
            lp_slow_clk: Option<LpSlowClkConfig>,
            mcpwm0_function_clock: Option<Mcpwm0FunctionClockConfig>,
            timg0_function_clock: Option<Timg0FunctionClockConfig>,
            timg0_calibration_clock: Option<Timg0CalibrationClockConfig>,
            timg0_wdt_clock: Option<Timg0WdtClockConfig>,
            timg1_function_clock: Option<Timg0FunctionClockConfig>,
            timg1_calibration_clock: Option<Timg0CalibrationClockConfig>,
            timg1_wdt_clock: Option<Timg0WdtClockConfig>,
            pll_clk_refcount: u32,
            rc_fast_clk_refcount: u32,
            xtal32k_clk_refcount: u32,
            hp_root_clk_refcount: u32,
            mspi_fast_clk_refcount: u32,
            apb_clk_refcount: u32,
            pll_f48m_refcount: u32,
            pll_f80m_refcount: u32,
            pll_f240m_refcount: u32,
            ledc_sclk_refcount: u32,
            lp_fast_clk_refcount: u32,
            lp_slow_clk_refcount: u32,
            mcpwm0_function_clock_refcount: u32,
            timg0_function_clock_refcount: u32,
            timg0_calibration_clock_refcount: u32,
            timg0_wdt_clock_refcount: u32,
            timg1_function_clock_refcount: u32,
            timg1_calibration_clock_refcount: u32,
            timg1_wdt_clock_refcount: u32,
        }
        impl ClockTree {
            /// Locks the clock tree for exclusive access.
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
            /// Returns the current configuration of the XTAL_CLK clock tree node
            pub fn xtal_clk(&self) -> Option<XtalClkConfig> {
                self.xtal_clk
            }
            /// Returns the current configuration of the HP_ROOT_CLK clock tree node
            pub fn hp_root_clk(&self) -> Option<HpRootClkConfig> {
                self.hp_root_clk
            }
            /// Returns the current configuration of the CPU_CLK clock tree node
            pub fn cpu_clk(&self) -> Option<CpuClkConfig> {
                self.cpu_clk
            }
            /// Returns the current configuration of the AHB_CLK clock tree node
            pub fn ahb_clk(&self) -> Option<AhbClkConfig> {
                self.ahb_clk
            }
            /// Returns the current configuration of the MSPI_FAST_CLK clock tree node
            pub fn mspi_fast_clk(&self) -> Option<MspiFastClkConfig> {
                self.mspi_fast_clk
            }
            /// Returns the current configuration of the SOC_ROOT_CLK clock tree node
            pub fn soc_root_clk(&self) -> Option<SocRootClkConfig> {
                self.soc_root_clk
            }
            /// Returns the current configuration of the CPU_HS_DIV clock tree node
            pub fn cpu_hs_div(&self) -> Option<CpuHsDivConfig> {
                self.cpu_hs_div
            }
            /// Returns the current configuration of the CPU_LS_DIV clock tree node
            pub fn cpu_ls_div(&self) -> Option<CpuLsDivConfig> {
                self.cpu_ls_div
            }
            /// Returns the current configuration of the AHB_HS_DIV clock tree node
            pub fn ahb_hs_div(&self) -> Option<AhbHsDivConfig> {
                self.ahb_hs_div
            }
            /// Returns the current configuration of the AHB_LS_DIV clock tree node
            pub fn ahb_ls_div(&self) -> Option<AhbLsDivConfig> {
                self.ahb_ls_div
            }
            /// Returns the current configuration of the APB_CLK clock tree node
            pub fn apb_clk(&self) -> Option<ApbClkConfig> {
                self.apb_clk
            }
            /// Returns the current configuration of the MSPI_FAST_HS_CLK clock tree node
            pub fn mspi_fast_hs_clk(&self) -> Option<MspiFastHsClkConfig> {
                self.mspi_fast_hs_clk
            }
            /// Returns the current configuration of the MSPI_FAST_LS_CLK clock tree node
            pub fn mspi_fast_ls_clk(&self) -> Option<MspiFastLsClkConfig> {
                self.mspi_fast_ls_clk
            }
            /// Returns the current configuration of the LEDC_SCLK clock tree node
            pub fn ledc_sclk(&self) -> Option<LedcSclkConfig> {
                self.ledc_sclk
            }
            /// Returns the current configuration of the LP_FAST_CLK clock tree node
            pub fn lp_fast_clk(&self) -> Option<LpFastClkConfig> {
                self.lp_fast_clk
            }
            /// Returns the current configuration of the LP_SLOW_CLK clock tree node
            pub fn lp_slow_clk(&self) -> Option<LpSlowClkConfig> {
                self.lp_slow_clk
            }
            /// Returns the current configuration of the MCPWM0_FUNCTION_CLOCK clock tree node
            pub fn mcpwm0_function_clock(&self) -> Option<Mcpwm0FunctionClockConfig> {
                self.mcpwm0_function_clock
            }
            /// Returns the current configuration of the TIMG0_FUNCTION_CLOCK clock tree node
            pub fn timg0_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg0_function_clock
            }
            /// Returns the current configuration of the TIMG0_CALIBRATION_CLOCK clock tree node
            pub fn timg0_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg0_calibration_clock
            }
            /// Returns the current configuration of the TIMG0_WDT_CLOCK clock tree node
            pub fn timg0_wdt_clock(&self) -> Option<Timg0WdtClockConfig> {
                self.timg0_wdt_clock
            }
            /// Returns the current configuration of the TIMG1_FUNCTION_CLOCK clock tree node
            pub fn timg1_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg1_function_clock
            }
            /// Returns the current configuration of the TIMG1_CALIBRATION_CLOCK clock tree node
            pub fn timg1_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg1_calibration_clock
            }
            /// Returns the current configuration of the TIMG1_WDT_CLOCK clock tree node
            pub fn timg1_wdt_clock(&self) -> Option<Timg0WdtClockConfig> {
                self.timg1_wdt_clock
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {
                xtal_clk: None,
                hp_root_clk: None,
                cpu_clk: None,
                ahb_clk: None,
                mspi_fast_clk: None,
                soc_root_clk: None,
                cpu_hs_div: None,
                cpu_ls_div: None,
                ahb_hs_div: None,
                ahb_ls_div: None,
                apb_clk: None,
                mspi_fast_hs_clk: None,
                mspi_fast_ls_clk: None,
                ledc_sclk: None,
                lp_fast_clk: None,
                lp_slow_clk: None,
                mcpwm0_function_clock: None,
                timg0_function_clock: None,
                timg0_calibration_clock: None,
                timg0_wdt_clock: None,
                timg1_function_clock: None,
                timg1_calibration_clock: None,
                timg1_wdt_clock: None,
                pll_clk_refcount: 0,
                rc_fast_clk_refcount: 0,
                xtal32k_clk_refcount: 0,
                hp_root_clk_refcount: 0,
                mspi_fast_clk_refcount: 0,
                apb_clk_refcount: 0,
                pll_f48m_refcount: 0,
                pll_f80m_refcount: 0,
                pll_f240m_refcount: 0,
                ledc_sclk_refcount: 0,
                lp_fast_clk_refcount: 0,
                lp_slow_clk_refcount: 0,
                mcpwm0_function_clock_refcount: 0,
                timg0_function_clock_refcount: 0,
                timg0_calibration_clock_refcount: 0,
                timg0_wdt_clock_refcount: 0,
                timg1_function_clock_refcount: 0,
                timg1_calibration_clock_refcount: 0,
                timg1_wdt_clock_refcount: 0,
            });
        pub fn configure_xtal_clk(clocks: &mut ClockTree, config: XtalClkConfig) {
            clocks.xtal_clk = Some(config);
            configure_xtal_clk_impl(clocks, config);
        }
        fn request_xtal_clk(_clocks: &mut ClockTree) {}
        fn release_xtal_clk(_clocks: &mut ClockTree) {}
        pub fn xtal_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.xtal_clk).value()
        }
        pub fn request_pll_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.pll_clk_refcount) {
                request_xtal_clk(clocks);
                enable_pll_clk_impl(clocks, true);
            }
        }
        pub fn release_pll_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.pll_clk_refcount) {
                enable_pll_clk_impl(clocks, false);
                release_xtal_clk(clocks);
            }
        }
        pub fn pll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            480000000
        }
        pub fn request_rc_fast_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.rc_fast_clk_refcount) {
                enable_rc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.rc_fast_clk_refcount) {
                enable_rc_fast_clk_impl(clocks, false);
            }
        }
        pub fn rc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            17500000
        }
        pub fn request_xtal32k_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.xtal32k_clk_refcount) {
                enable_xtal32k_clk_impl(clocks, true);
            }
        }
        pub fn release_xtal32k_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.xtal32k_clk_refcount) {
                enable_xtal32k_clk_impl(clocks, false);
            }
        }
        pub fn xtal32k_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_osc_slow_clk(clocks: &mut ClockTree) {
            enable_osc_slow_clk_impl(clocks, true);
        }
        pub fn release_osc_slow_clk(clocks: &mut ClockTree) {
            enable_osc_slow_clk_impl(clocks, false);
        }
        pub fn osc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_rc_slow_clk(clocks: &mut ClockTree) {
            enable_rc_slow_clk_impl(clocks, true);
        }
        pub fn release_rc_slow_clk(clocks: &mut ClockTree) {
            enable_rc_slow_clk_impl(clocks, false);
        }
        pub fn rc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            136000
        }
        pub fn configure_hp_root_clk(clocks: &mut ClockTree, config: HpRootClkConfig) {
            clocks.hp_root_clk = Some(config);
            configure_hp_root_clk_impl(clocks, config);
        }
        pub fn request_hp_root_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.hp_root_clk_refcount) {
                request_soc_root_clk(clocks);
                enable_hp_root_clk_impl(clocks, true);
            }
        }
        pub fn release_hp_root_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.hp_root_clk_refcount) {
                enable_hp_root_clk_impl(clocks, false);
                release_soc_root_clk(clocks);
            }
        }
        pub fn hp_root_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (soc_root_clk_frequency(clocks) / unwrap!(clocks.hp_root_clk).value())
        }
        pub fn configure_cpu_clk(clocks: &mut ClockTree, new_selector: CpuClkConfig) {
            let old_selector = clocks.cpu_clk.replace(new_selector);
            match new_selector {
                CpuClkConfig::Hs => request_cpu_hs_div(clocks),
                CpuClkConfig::Ls => request_cpu_ls_div(clocks),
            }
            configure_cpu_clk_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    CpuClkConfig::Hs => release_cpu_hs_div(clocks),
                    CpuClkConfig::Ls => release_cpu_ls_div(clocks),
                }
            }
        }
        fn request_cpu_clk(_clocks: &mut ClockTree) {}
        fn release_cpu_clk(_clocks: &mut ClockTree) {}
        pub fn cpu_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.cpu_clk) {
                CpuClkConfig::Hs => cpu_hs_div_frequency(clocks),
                CpuClkConfig::Ls => cpu_ls_div_frequency(clocks),
            }
        }
        pub fn configure_ahb_clk(clocks: &mut ClockTree, new_selector: AhbClkConfig) {
            let old_selector = clocks.ahb_clk.replace(new_selector);
            match new_selector {
                AhbClkConfig::Hs => request_ahb_hs_div(clocks),
                AhbClkConfig::Ls => request_ahb_ls_div(clocks),
            }
            configure_ahb_clk_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    AhbClkConfig::Hs => release_ahb_hs_div(clocks),
                    AhbClkConfig::Ls => release_ahb_ls_div(clocks),
                }
            }
        }
        fn request_ahb_clk(_clocks: &mut ClockTree) {}
        fn release_ahb_clk(_clocks: &mut ClockTree) {}
        pub fn ahb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.ahb_clk) {
                AhbClkConfig::Hs => ahb_hs_div_frequency(clocks),
                AhbClkConfig::Ls => ahb_ls_div_frequency(clocks),
            }
        }
        pub fn configure_mspi_fast_clk(clocks: &mut ClockTree, new_selector: MspiFastClkConfig) {
            let old_selector = clocks.mspi_fast_clk.replace(new_selector);
            if clocks.mspi_fast_clk_refcount > 0 {
                match new_selector {
                    MspiFastClkConfig::Hs => request_mspi_fast_hs_clk(clocks),
                    MspiFastClkConfig::Ls => request_mspi_fast_ls_clk(clocks),
                }
                configure_mspi_fast_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        MspiFastClkConfig::Hs => release_mspi_fast_hs_clk(clocks),
                        MspiFastClkConfig::Ls => release_mspi_fast_ls_clk(clocks),
                    }
                }
            } else {
                configure_mspi_fast_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_mspi_fast_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.mspi_fast_clk_refcount) {
                match unwrap!(clocks.mspi_fast_clk) {
                    MspiFastClkConfig::Hs => request_mspi_fast_hs_clk(clocks),
                    MspiFastClkConfig::Ls => request_mspi_fast_ls_clk(clocks),
                }
                enable_mspi_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_mspi_fast_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.mspi_fast_clk_refcount) {
                enable_mspi_fast_clk_impl(clocks, false);
                match unwrap!(clocks.mspi_fast_clk) {
                    MspiFastClkConfig::Hs => release_mspi_fast_hs_clk(clocks),
                    MspiFastClkConfig::Ls => release_mspi_fast_ls_clk(clocks),
                }
            }
        }
        pub fn mspi_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.mspi_fast_clk) {
                MspiFastClkConfig::Hs => mspi_fast_hs_clk_frequency(clocks),
                MspiFastClkConfig::Ls => mspi_fast_ls_clk_frequency(clocks),
            }
        }
        pub fn configure_soc_root_clk(clocks: &mut ClockTree, new_selector: SocRootClkConfig) {
            let old_selector = clocks.soc_root_clk.replace(new_selector);
            match new_selector {
                SocRootClkConfig::Xtal => {
                    let config_value = HpRootClkConfig::new(1);
                    configure_hp_root_clk(clocks, config_value);
                    configure_cpu_clk(clocks, CpuClkConfig::Ls);
                    configure_ahb_clk(clocks, AhbClkConfig::Ls);
                    configure_mspi_fast_clk(clocks, MspiFastClkConfig::Ls);
                }
                SocRootClkConfig::RcFast => {
                    let config_value = HpRootClkConfig::new(1);
                    configure_hp_root_clk(clocks, config_value);
                    configure_cpu_clk(clocks, CpuClkConfig::Ls);
                    configure_ahb_clk(clocks, AhbClkConfig::Ls);
                    configure_mspi_fast_clk(clocks, MspiFastClkConfig::Ls);
                }
                SocRootClkConfig::Pll => {
                    let config_value = HpRootClkConfig::new(3);
                    configure_hp_root_clk(clocks, config_value);
                    configure_cpu_clk(clocks, CpuClkConfig::Hs);
                    configure_ahb_clk(clocks, AhbClkConfig::Hs);
                    configure_mspi_fast_clk(clocks, MspiFastClkConfig::Hs);
                }
            }
            match new_selector {
                SocRootClkConfig::Xtal => request_xtal_clk(clocks),
                SocRootClkConfig::RcFast => request_rc_fast_clk(clocks),
                SocRootClkConfig::Pll => request_pll_clk(clocks),
            }
            configure_soc_root_clk_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    SocRootClkConfig::Xtal => release_xtal_clk(clocks),
                    SocRootClkConfig::RcFast => release_rc_fast_clk(clocks),
                    SocRootClkConfig::Pll => release_pll_clk(clocks),
                }
            }
        }
        pub fn request_soc_root_clk(clocks: &mut ClockTree) {
            match unwrap!(clocks.soc_root_clk) {
                SocRootClkConfig::Xtal => request_xtal_clk(clocks),
                SocRootClkConfig::RcFast => request_rc_fast_clk(clocks),
                SocRootClkConfig::Pll => request_pll_clk(clocks),
            }
            enable_soc_root_clk_impl(clocks, true);
        }
        pub fn release_soc_root_clk(clocks: &mut ClockTree) {
            enable_soc_root_clk_impl(clocks, false);
            match unwrap!(clocks.soc_root_clk) {
                SocRootClkConfig::Xtal => release_xtal_clk(clocks),
                SocRootClkConfig::RcFast => release_rc_fast_clk(clocks),
                SocRootClkConfig::Pll => release_pll_clk(clocks),
            }
        }
        pub fn soc_root_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.soc_root_clk) {
                SocRootClkConfig::Xtal => xtal_clk_frequency(clocks),
                SocRootClkConfig::RcFast => rc_fast_clk_frequency(clocks),
                SocRootClkConfig::Pll => pll_clk_frequency(clocks),
            }
        }
        pub fn configure_cpu_hs_div(clocks: &mut ClockTree, config: CpuHsDivConfig) {
            clocks.cpu_hs_div = Some(config);
            configure_cpu_hs_div_impl(clocks, config);
        }
        pub fn request_cpu_hs_div(clocks: &mut ClockTree) {
            request_hp_root_clk(clocks);
            enable_cpu_hs_div_impl(clocks, true);
        }
        pub fn release_cpu_hs_div(clocks: &mut ClockTree) {
            enable_cpu_hs_div_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn cpu_hs_div_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.cpu_hs_div).value() + 1))
        }
        pub fn configure_cpu_ls_div(clocks: &mut ClockTree, config: CpuLsDivConfig) {
            clocks.cpu_ls_div = Some(config);
            configure_cpu_ls_div_impl(clocks, config);
        }
        pub fn request_cpu_ls_div(clocks: &mut ClockTree) {
            request_hp_root_clk(clocks);
            enable_cpu_ls_div_impl(clocks, true);
        }
        pub fn release_cpu_ls_div(clocks: &mut ClockTree) {
            enable_cpu_ls_div_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn cpu_ls_div_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.cpu_ls_div).value() + 1))
        }
        pub fn configure_ahb_hs_div(clocks: &mut ClockTree, config: AhbHsDivConfig) {
            clocks.ahb_hs_div = Some(config);
            configure_ahb_hs_div_impl(clocks, config);
        }
        pub fn request_ahb_hs_div(clocks: &mut ClockTree) {
            request_hp_root_clk(clocks);
            enable_ahb_hs_div_impl(clocks, true);
        }
        pub fn release_ahb_hs_div(clocks: &mut ClockTree) {
            enable_ahb_hs_div_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn ahb_hs_div_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.ahb_hs_div).value() + 1))
        }
        pub fn configure_ahb_ls_div(clocks: &mut ClockTree, config: AhbLsDivConfig) {
            clocks.ahb_ls_div = Some(config);
            configure_ahb_ls_div_impl(clocks, config);
        }
        pub fn request_ahb_ls_div(clocks: &mut ClockTree) {
            request_hp_root_clk(clocks);
            enable_ahb_ls_div_impl(clocks, true);
        }
        pub fn release_ahb_ls_div(clocks: &mut ClockTree) {
            enable_ahb_ls_div_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn ahb_ls_div_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.ahb_ls_div).value() + 1))
        }
        pub fn configure_apb_clk(clocks: &mut ClockTree, config: ApbClkConfig) {
            clocks.apb_clk = Some(config);
            configure_apb_clk_impl(clocks, config);
        }
        pub fn request_apb_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.apb_clk_refcount) {
                request_ahb_clk(clocks);
                enable_apb_clk_impl(clocks, true);
            }
        }
        pub fn release_apb_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.apb_clk_refcount) {
                enable_apb_clk_impl(clocks, false);
                release_ahb_clk(clocks);
            }
        }
        pub fn apb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (ahb_clk_frequency(clocks) / (unwrap!(clocks.apb_clk).value() + 1))
        }
        pub fn configure_mspi_fast_hs_clk(clocks: &mut ClockTree, config: MspiFastHsClkConfig) {
            clocks.mspi_fast_hs_clk = Some(config);
            configure_mspi_fast_hs_clk_impl(clocks, config);
        }
        pub fn request_mspi_fast_hs_clk(clocks: &mut ClockTree) {
            request_hp_root_clk(clocks);
            enable_mspi_fast_hs_clk_impl(clocks, true);
        }
        pub fn release_mspi_fast_hs_clk(clocks: &mut ClockTree) {
            enable_mspi_fast_hs_clk_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn mspi_fast_hs_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.mspi_fast_hs_clk).value() + 1))
        }
        pub fn configure_mspi_fast_ls_clk(clocks: &mut ClockTree, config: MspiFastLsClkConfig) {
            clocks.mspi_fast_ls_clk = Some(config);
            configure_mspi_fast_ls_clk_impl(clocks, config);
        }
        pub fn request_mspi_fast_ls_clk(clocks: &mut ClockTree) {
            request_hp_root_clk(clocks);
            enable_mspi_fast_ls_clk_impl(clocks, true);
        }
        pub fn release_mspi_fast_ls_clk(clocks: &mut ClockTree) {
            enable_mspi_fast_ls_clk_impl(clocks, false);
            release_hp_root_clk(clocks);
        }
        pub fn mspi_fast_ls_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (hp_root_clk_frequency(clocks) / (unwrap!(clocks.mspi_fast_ls_clk).value() + 1))
        }
        pub fn request_pll_f48m(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.pll_f48m_refcount) {
                request_pll_clk(clocks);
                enable_pll_f48m_impl(clocks, true);
            }
        }
        pub fn release_pll_f48m(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.pll_f48m_refcount) {
                enable_pll_f48m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f48m_frequency(clocks: &mut ClockTree) -> u32 {
            48000000
        }
        pub fn request_pll_f80m(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.pll_f80m_refcount) {
                request_pll_clk(clocks);
                enable_pll_f80m_impl(clocks, true);
            }
        }
        pub fn release_pll_f80m(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.pll_f80m_refcount) {
                enable_pll_f80m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f80m_frequency(clocks: &mut ClockTree) -> u32 {
            80000000
        }
        pub fn request_pll_f160m(clocks: &mut ClockTree) {
            request_pll_clk(clocks);
            enable_pll_f160m_impl(clocks, true);
        }
        pub fn release_pll_f160m(clocks: &mut ClockTree) {
            enable_pll_f160m_impl(clocks, false);
            release_pll_clk(clocks);
        }
        pub fn pll_f160m_frequency(clocks: &mut ClockTree) -> u32 {
            160000000
        }
        pub fn request_pll_f240m(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.pll_f240m_refcount) {
                request_pll_clk(clocks);
                enable_pll_f240m_impl(clocks, true);
            }
        }
        pub fn release_pll_f240m(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.pll_f240m_refcount) {
                enable_pll_f240m_impl(clocks, false);
                release_pll_clk(clocks);
            }
        }
        pub fn pll_f240m_frequency(clocks: &mut ClockTree) -> u32 {
            240000000
        }
        pub fn configure_ledc_sclk(clocks: &mut ClockTree, new_selector: LedcSclkConfig) {
            let old_selector = clocks.ledc_sclk.replace(new_selector);
            if clocks.ledc_sclk_refcount > 0 {
                match new_selector {
                    LedcSclkConfig::PllF80m => request_pll_f80m(clocks),
                    LedcSclkConfig::RcFastClk => request_rc_fast_clk(clocks),
                    LedcSclkConfig::XtalClk => request_xtal_clk(clocks),
                }
                configure_ledc_sclk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LedcSclkConfig::PllF80m => release_pll_f80m(clocks),
                        LedcSclkConfig::RcFastClk => release_rc_fast_clk(clocks),
                        LedcSclkConfig::XtalClk => release_xtal_clk(clocks),
                    }
                }
            } else {
                configure_ledc_sclk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_ledc_sclk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.ledc_sclk_refcount) {
                match unwrap!(clocks.ledc_sclk) {
                    LedcSclkConfig::PllF80m => request_pll_f80m(clocks),
                    LedcSclkConfig::RcFastClk => request_rc_fast_clk(clocks),
                    LedcSclkConfig::XtalClk => request_xtal_clk(clocks),
                }
                enable_ledc_sclk_impl(clocks, true);
            }
        }
        pub fn release_ledc_sclk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.ledc_sclk_refcount) {
                enable_ledc_sclk_impl(clocks, false);
                match unwrap!(clocks.ledc_sclk) {
                    LedcSclkConfig::PllF80m => release_pll_f80m(clocks),
                    LedcSclkConfig::RcFastClk => release_rc_fast_clk(clocks),
                    LedcSclkConfig::XtalClk => release_xtal_clk(clocks),
                }
            }
        }
        pub fn ledc_sclk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.ledc_sclk) {
                LedcSclkConfig::PllF80m => pll_f80m_frequency(clocks),
                LedcSclkConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                LedcSclkConfig::XtalClk => xtal_clk_frequency(clocks),
            }
        }
        pub fn request_xtal_d2_clk(clocks: &mut ClockTree) {
            request_xtal_clk(clocks);
            enable_xtal_d2_clk_impl(clocks, true);
        }
        pub fn release_xtal_d2_clk(clocks: &mut ClockTree) {
            enable_xtal_d2_clk_impl(clocks, false);
            release_xtal_clk(clocks);
        }
        pub fn xtal_d2_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (xtal_clk_frequency(clocks) / 2)
        }
        pub fn configure_lp_fast_clk(clocks: &mut ClockTree, new_selector: LpFastClkConfig) {
            let old_selector = clocks.lp_fast_clk.replace(new_selector);
            if clocks.lp_fast_clk_refcount > 0 {
                match new_selector {
                    LpFastClkConfig::RcFastClk => request_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2Clk => request_xtal_d2_clk(clocks),
                }
                configure_lp_fast_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LpFastClkConfig::RcFastClk => release_rc_fast_clk(clocks),
                        LpFastClkConfig::XtalD2Clk => release_xtal_d2_clk(clocks),
                    }
                }
            } else {
                configure_lp_fast_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_lp_fast_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.lp_fast_clk_refcount) {
                match unwrap!(clocks.lp_fast_clk) {
                    LpFastClkConfig::RcFastClk => request_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2Clk => request_xtal_d2_clk(clocks),
                }
                enable_lp_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_lp_fast_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.lp_fast_clk_refcount) {
                enable_lp_fast_clk_impl(clocks, false);
                match unwrap!(clocks.lp_fast_clk) {
                    LpFastClkConfig::RcFastClk => release_rc_fast_clk(clocks),
                    LpFastClkConfig::XtalD2Clk => release_xtal_d2_clk(clocks),
                }
            }
        }
        pub fn lp_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.lp_fast_clk) {
                LpFastClkConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                LpFastClkConfig::XtalD2Clk => xtal_d2_clk_frequency(clocks),
            }
        }
        pub fn configure_lp_slow_clk(clocks: &mut ClockTree, new_selector: LpSlowClkConfig) {
            let old_selector = clocks.lp_slow_clk.replace(new_selector);
            if clocks.lp_slow_clk_refcount > 0 {
                match new_selector {
                    LpSlowClkConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                    LpSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    LpSlowClkConfig::OscSlow => request_osc_slow_clk(clocks),
                }
                configure_lp_slow_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        LpSlowClkConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                        LpSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                        LpSlowClkConfig::OscSlow => release_osc_slow_clk(clocks),
                    }
                }
            } else {
                configure_lp_slow_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_lp_slow_clk(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.lp_slow_clk_refcount) {
                match unwrap!(clocks.lp_slow_clk) {
                    LpSlowClkConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                    LpSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    LpSlowClkConfig::OscSlow => request_osc_slow_clk(clocks),
                }
                enable_lp_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_lp_slow_clk(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.lp_slow_clk_refcount) {
                enable_lp_slow_clk_impl(clocks, false);
                match unwrap!(clocks.lp_slow_clk) {
                    LpSlowClkConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    LpSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                    LpSlowClkConfig::OscSlow => release_osc_slow_clk(clocks),
                }
            }
        }
        pub fn lp_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.lp_slow_clk) {
                LpSlowClkConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
                LpSlowClkConfig::RcSlow => rc_slow_clk_frequency(clocks),
                LpSlowClkConfig::OscSlow => osc_slow_clk_frequency(clocks),
            }
        }
        pub fn configure_mcpwm0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Mcpwm0FunctionClockConfig,
        ) {
            let old_selector = clocks.mcpwm0_function_clock.replace(new_selector);
            if clocks.mcpwm0_function_clock_refcount > 0 {
                match new_selector {
                    Mcpwm0FunctionClockConfig::PllF160m => request_pll_f160m(clocks),
                    Mcpwm0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Mcpwm0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                }
                configure_mcpwm0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Mcpwm0FunctionClockConfig::PllF160m => release_pll_f160m(clocks),
                        Mcpwm0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Mcpwm0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    }
                }
            } else {
                configure_mcpwm0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_mcpwm0_function_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.mcpwm0_function_clock_refcount) {
                match unwrap!(clocks.mcpwm0_function_clock) {
                    Mcpwm0FunctionClockConfig::PllF160m => request_pll_f160m(clocks),
                    Mcpwm0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Mcpwm0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                }
                enable_mcpwm0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_mcpwm0_function_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.mcpwm0_function_clock_refcount) {
                enable_mcpwm0_function_clock_impl(clocks, false);
                match unwrap!(clocks.mcpwm0_function_clock) {
                    Mcpwm0FunctionClockConfig::PllF160m => release_pll_f160m(clocks),
                    Mcpwm0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Mcpwm0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                }
            }
        }
        pub fn mcpwm0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.mcpwm0_function_clock) {
                Mcpwm0FunctionClockConfig::PllF160m => pll_f160m_frequency(clocks),
                Mcpwm0FunctionClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Mcpwm0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
            }
        }
        pub fn configure_timg0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg0_function_clock.replace(new_selector);
            if clocks.timg0_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_function_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg0_function_clock_refcount) {
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_timg0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_function_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg0_function_clock_refcount) {
                enable_timg0_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn timg0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_function_clock) {
                Timg0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Timg0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_timg0_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg0_calibration_clock.replace(new_selector);
            if clocks.timg0_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::RtcSlowClk => request_lp_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::RtcSlowClk => release_lp_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_calibration_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcSlowClk => request_lp_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg0_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_calibration_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                enable_timg0_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcSlowClk => release_lp_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg0_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_calibration_clock) {
                Timg0CalibrationClockConfig::RtcSlowClk => lp_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Timg0CalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        pub fn configure_timg0_wdt_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0WdtClockConfig,
        ) {
            let old_selector = clocks.timg0_wdt_clock.replace(new_selector);
            if clocks.timg0_wdt_clock_refcount > 0 {
                match new_selector {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                configure_timg0_wdt_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                        Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_timg0_wdt_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg0_wdt_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg0_wdt_clock_refcount) {
                match unwrap!(clocks.timg0_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                enable_timg0_wdt_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_wdt_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg0_wdt_clock_refcount) {
                enable_timg0_wdt_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn timg0_wdt_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_wdt_clock) {
                Timg0WdtClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0WdtClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Timg0WdtClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg1_function_clock.replace(new_selector);
            if clocks.timg1_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                    }
                }
            } else {
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_function_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg1_function_clock_refcount) {
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => request_pll_f80m(clocks),
                }
                enable_timg1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_function_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg1_function_clock_refcount) {
                enable_timg1_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Timg0FunctionClockConfig::PllF80m => release_pll_f80m(clocks),
                }
            }
        }
        pub fn timg1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_function_clock) {
                Timg0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Timg0FunctionClockConfig::PllF80m => pll_f80m_frequency(clocks),
            }
        }
        pub fn configure_timg1_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg1_calibration_clock.replace(new_selector);
            if clocks.timg1_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::RtcSlowClk => request_lp_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::RtcSlowClk => release_lp_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                        Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_calibration_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcSlowClk => request_lp_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg1_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_calibration_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                enable_timg1_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcSlowClk => release_lp_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg1_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_calibration_clock) {
                Timg0CalibrationClockConfig::RtcSlowClk => lp_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
                Timg0CalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_wdt_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0WdtClockConfig,
        ) {
            let old_selector = clocks.timg1_wdt_clock.replace(new_selector);
            if clocks.timg1_wdt_clock_refcount > 0 {
                match new_selector {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                configure_timg1_wdt_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                        Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_timg1_wdt_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn request_timg1_wdt_clock(clocks: &mut ClockTree) {
            if increment_reference_count(&mut clocks.timg1_wdt_clock_refcount) {
                match unwrap!(clocks.timg1_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => request_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => request_rc_fast_clk(clocks),
                }
                enable_timg1_wdt_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_wdt_clock(clocks: &mut ClockTree) {
            if decrement_reference_count(&mut clocks.timg1_wdt_clock_refcount) {
                enable_timg1_wdt_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_wdt_clock) {
                    Timg0WdtClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0WdtClockConfig::PllF80m => release_pll_f80m(clocks),
                    Timg0WdtClockConfig::RcFastClk => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn timg1_wdt_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_wdt_clock) {
                Timg0WdtClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0WdtClockConfig::PllF80m => pll_f80m_frequency(clocks),
                Timg0WdtClockConfig::RcFastClk => rc_fast_clk_frequency(clocks),
            }
        }
        /// Clock tree configuration.
        ///
        /// The fields of this struct are optional, with the following caveats:
        /// - If `XTAL_CLK` is not specified, the crystal frequency will be automatically detected
        ///   if possible.
        /// - The CPU and its upstream clock nodes will be set to a default configuration.
        /// - Other unspecified clock sources will not be useable by peripherals.
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[instability::unstable]
        pub struct ClockConfig {
            /// `XTAL_CLK` configuration.
            pub xtal_clk: Option<XtalClkConfig>,
            /// `SOC_ROOT_CLK` configuration.
            pub soc_root_clk: Option<SocRootClkConfig>,
            /// `CPU_HS_DIV` configuration.
            pub cpu_hs_div: Option<CpuHsDivConfig>,
            /// `CPU_LS_DIV` configuration.
            pub cpu_ls_div: Option<CpuLsDivConfig>,
            /// `AHB_HS_DIV` configuration.
            pub ahb_hs_div: Option<AhbHsDivConfig>,
            /// `AHB_LS_DIV` configuration.
            pub ahb_ls_div: Option<AhbLsDivConfig>,
            /// `APB_CLK` configuration.
            pub apb_clk: Option<ApbClkConfig>,
            /// `MSPI_FAST_HS_CLK` configuration.
            pub mspi_fast_hs_clk: Option<MspiFastHsClkConfig>,
            /// `MSPI_FAST_LS_CLK` configuration.
            pub mspi_fast_ls_clk: Option<MspiFastLsClkConfig>,
            /// `LEDC_SCLK` configuration.
            pub ledc_sclk: Option<LedcSclkConfig>,
            /// `LP_FAST_CLK` configuration.
            pub lp_fast_clk: Option<LpFastClkConfig>,
            /// `LP_SLOW_CLK` configuration.
            pub lp_slow_clk: Option<LpSlowClkConfig>,
        }
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {
                    if let Some(config) = self.xtal_clk {
                        configure_xtal_clk(clocks, config);
                    }
                    if let Some(config) = self.soc_root_clk {
                        configure_soc_root_clk(clocks, config);
                    }
                    if let Some(config) = self.cpu_hs_div {
                        configure_cpu_hs_div(clocks, config);
                    }
                    if let Some(config) = self.cpu_ls_div {
                        configure_cpu_ls_div(clocks, config);
                    }
                    if let Some(config) = self.ahb_hs_div {
                        configure_ahb_hs_div(clocks, config);
                    }
                    if let Some(config) = self.ahb_ls_div {
                        configure_ahb_ls_div(clocks, config);
                    }
                    if let Some(config) = self.apb_clk {
                        configure_apb_clk(clocks, config);
                    }
                    if let Some(config) = self.mspi_fast_hs_clk {
                        configure_mspi_fast_hs_clk(clocks, config);
                    }
                    if let Some(config) = self.mspi_fast_ls_clk {
                        configure_mspi_fast_ls_clk(clocks, config);
                    }
                    if let Some(config) = self.ledc_sclk {
                        configure_ledc_sclk(clocks, config);
                    }
                    if let Some(config) = self.lp_fast_clk {
                        configure_lp_fast_clk(clocks, config);
                    }
                    if let Some(config) = self.lp_slow_clk {
                        configure_lp_slow_clk(clocks, config);
                    }
                });
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount = unwrap!(refcount.checked_add(1), "Reference count overflow");
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount = refcount.saturating_sub(1);
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            /// AES peripheral clock signal
            Aes,
            /// APB_SAR_ADC peripheral clock signal
            ApbSarAdc,
            /// DMA peripheral clock signal
            Dma,
            /// DS peripheral clock signal
            Ds,
            /// ECC peripheral clock signal
            Ecc,
            /// ETM peripheral clock signal
            Etm,
            /// HMAC peripheral clock signal
            Hmac,
            /// I2C_EXT0 peripheral clock signal
            I2cExt0,
            /// I2S0 peripheral clock signal
            I2s0,
            /// LEDC peripheral clock signal
            Ledc,
            /// MCPWM0 peripheral clock signal
            Mcpwm0,
            /// PARL_IO peripheral clock signal
            ParlIo,
            /// PCNT peripheral clock signal
            Pcnt,
            /// RMT peripheral clock signal
            Rmt,
            /// RSA peripheral clock signal
            Rsa,
            /// SDIO_SLAVE peripheral clock signal
            SdioSlave,
            /// SHA peripheral clock signal
            Sha,
            /// SPI2 peripheral clock signal
            Spi2,
            /// SYSTIMER peripheral clock signal
            Systimer,
            /// TIMG0 peripheral clock signal
            Timg0,
            /// TIMG1 peripheral clock signal
            Timg1,
            /// TRACE0 peripheral clock signal
            Trace0,
            /// TSENS peripheral clock signal
            Tsens,
            /// TWAI0 peripheral clock signal
            Twai0,
            /// TWAI1 peripheral clock signal
            Twai1,
            /// UART0 peripheral clock signal
            Uart0,
            /// UART1 peripheral clock signal
            Uart1,
            /// UHCI0 peripheral clock signal
            Uhci0,
            /// USB_DEVICE peripheral clock signal
            UsbDevice,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] = &[
                Self::ApbSarAdc,
                Self::Systimer,
                Self::Timg0,
                Self::Uart0,
                Self::UsbDevice,
            ];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::ApbSarAdc,
                Self::Dma,
                Self::Ds,
                Self::Ecc,
                Self::Etm,
                Self::Hmac,
                Self::I2cExt0,
                Self::I2s0,
                Self::Ledc,
                Self::Mcpwm0,
                Self::ParlIo,
                Self::Pcnt,
                Self::Rmt,
                Self::Rsa,
                Self::SdioSlave,
                Self::Sha,
                Self::Spi2,
                Self::Systimer,
                Self::Timg0,
                Self::Timg1,
                Self::Trace0,
                Self::Tsens,
                Self::Twai0,
                Self::Twai1,
                Self::Uart0,
                Self::Uart1,
                Self::Uhci0,
                Self::UsbDevice,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .aes_conf()
                        .modify(|_, w| w.aes_clk_en().bit(enable));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .saradc_conf()
                        .modify(|_, w| w.saradc_reg_clk_en().bit(enable));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .gdma_conf()
                        .modify(|_, w| w.gdma_clk_en().bit(enable));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .ds_conf()
                        .modify(|_, w| w.ds_clk_en().bit(enable));
                }
                Peripheral::Ecc => {
                    crate::peripherals::SYSTEM::regs()
                        .ecc_conf()
                        .modify(|_, w| w.ecc_clk_en().bit(enable));
                }
                Peripheral::Etm => {
                    crate::peripherals::SYSTEM::regs()
                        .etm_conf()
                        .modify(|_, w| w.etm_clk_en().bit(enable));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .hmac_conf()
                        .modify(|_, w| w.hmac_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2c0_conf()
                        .modify(|_, w| w.i2c0_clk_en().bit(enable));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2s_conf()
                        .modify(|_, w| w.i2s_clk_en().bit(enable));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .ledc_conf()
                        .modify(|_, w| w.ledc_clk_en().bit(enable));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .pwm_conf()
                        .modify(|_, w| w.pwm_clk_en().bit(enable));
                }
                Peripheral::ParlIo => {
                    crate::peripherals::SYSTEM::regs()
                        .parl_io_conf()
                        .modify(|_, w| w.parl_clk_en().bit(enable));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .pcnt_conf()
                        .modify(|_, w| w.pcnt_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .rmt_conf()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .rsa_conf()
                        .modify(|_, w| w.rsa_clk_en().bit(enable));
                }
                Peripheral::SdioSlave => {
                    crate::peripherals::SYSTEM::regs()
                        .sdio_slave_conf()
                        .modify(|_, w| w.sdio_slave_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .sha_conf()
                        .modify(|_, w| w.sha_clk_en().bit(enable));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .spi2_conf()
                        .modify(|_, w| w.spi2_clk_en().bit(enable));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .systimer_conf()
                        .modify(|_, w| w.systimer_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_conf()
                        .modify(|_, w| w.tg0_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_timer_clk_conf()
                        .modify(|_, w| w.tg0_timer_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_conf()
                        .modify(|_, w| w.tg1_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_timer_clk_conf()
                        .modify(|_, w| w.tg1_timer_clk_en().bit(enable));
                }
                Peripheral::Trace0 => {
                    crate::peripherals::SYSTEM::regs()
                        .trace_conf()
                        .modify(|_, w| w.trace_clk_en().bit(enable));
                }
                Peripheral::Tsens => {
                    crate::peripherals::SYSTEM::regs()
                        .tsens_clk_conf()
                        .modify(|_, w| w.tsens_clk_en().bit(enable));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai0_conf()
                        .modify(|_, w| w.twai0_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .twai0_func_clk_conf()
                        .modify(|_, w| w.twai0_func_clk_en().bit(enable));
                }
                Peripheral::Twai1 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai1_conf()
                        .modify(|_, w| w.twai1_clk_en().bit(enable));
                    crate::peripherals::SYSTEM::regs()
                        .twai1_func_clk_conf()
                        .modify(|_, w| w.twai1_func_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(0)
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(1)
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uhci_conf()
                        .modify(|_, w| w.uhci_clk_en().bit(enable));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .usb_device_conf()
                        .modify(|_, w| w.usb_device_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .aes_conf()
                        .modify(|_, w| w.aes_rst_en().bit(reset));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .saradc_conf()
                        .modify(|_, w| w.saradc_reg_rst_en().bit(reset));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .gdma_conf()
                        .modify(|_, w| w.gdma_rst_en().bit(reset));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .ds_conf()
                        .modify(|_, w| w.ds_rst_en().bit(reset));
                }
                Peripheral::Ecc => {
                    crate::peripherals::SYSTEM::regs()
                        .ecc_conf()
                        .modify(|_, w| w.ecc_rst_en().bit(reset));
                }
                Peripheral::Etm => {
                    crate::peripherals::SYSTEM::regs()
                        .etm_conf()
                        .modify(|_, w| w.etm_rst_en().bit(reset));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .hmac_conf()
                        .modify(|_, w| w.hmac_rst_en().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2c0_conf()
                        .modify(|_, w| w.i2c0_rst_en().bit(reset));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .i2s_conf()
                        .modify(|_, w| w.i2s_rst_en().bit(reset));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .ledc_conf()
                        .modify(|_, w| w.ledc_rst_en().bit(reset));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .pwm_conf()
                        .modify(|_, w| w.pwm_rst_en().bit(reset));
                }
                Peripheral::ParlIo => {
                    crate::peripherals::SYSTEM::regs()
                        .parl_io_conf()
                        .modify(|_, w| w.parl_rst_en().bit(reset));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .pcnt_conf()
                        .modify(|_, w| w.pcnt_rst_en().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .rmt_conf()
                        .modify(|_, w| w.rmt_rst_en().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .rsa_conf()
                        .modify(|_, w| w.rsa_rst_en().bit(reset));
                }
                Peripheral::SdioSlave => {
                    crate::peripherals::SYSTEM::regs()
                        .sdio_slave_conf()
                        .modify(|_, w| w.sdio_slave_rst_en().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .sha_conf()
                        .modify(|_, w| w.sha_rst_en().bit(reset));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .spi2_conf()
                        .modify(|_, w| w.spi2_rst_en().bit(reset));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .systimer_conf()
                        .modify(|_, w| w.systimer_rst_en().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup0_conf()
                        .modify(|_, w| w.tg0_rst_en().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .timergroup1_conf()
                        .modify(|_, w| w.tg1_rst_en().bit(reset));
                }
                Peripheral::Trace0 => {
                    crate::peripherals::SYSTEM::regs()
                        .trace_conf()
                        .modify(|_, w| w.trace_rst_en().bit(reset));
                }
                Peripheral::Tsens => {
                    crate::peripherals::SYSTEM::regs()
                        .tsens_clk_conf()
                        .modify(|_, w| w.tsens_rst_en().bit(reset));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai0_conf()
                        .modify(|_, w| w.twai0_rst_en().bit(reset));
                }
                Peripheral::Twai1 => {
                    crate::peripherals::SYSTEM::regs()
                        .twai1_conf()
                        .modify(|_, w| w.twai1_rst_en().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(0)
                        .conf()
                        .modify(|_, w| w.rst_en().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .uart(1)
                        .conf()
                        .modify(|_, w| w.rst_en().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .uhci_conf()
                        .modify(|_, w| w.uhci_rst_en().bit(reset));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .usb_device_conf()
                        .modify(|_, w| w.usb_device_rst_en().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x40800000..0x40880000
    };
    (size as str, "DRAM") => {
        "524288"
    };
    ("DRAM2_UNINIT") => {
        0x4086E610..0x4087E610
    };
    (size as str, "DRAM2_UNINIT") => {
        "65536"
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_aes_key_length {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((128)); _for_each_inner!((256)); _for_each_inner!((128, 0, 4));
        _for_each_inner!((256, 2, 6)); _for_each_inner!((bits(128), (256)));
        _for_each_inner!((modes(128, 0, 4), (256, 2, 6)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_dedicated_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0)); _for_each_inner!((1)); _for_each_inner!((2));
        _for_each_inner!((3)); _for_each_inner!((4)); _for_each_inner!((5));
        _for_each_inner!((6)); _for_each_inner!((7)); _for_each_inner!((0, 0,
        CPU_GPIO_0)); _for_each_inner!((0, 1, CPU_GPIO_1)); _for_each_inner!((0, 2,
        CPU_GPIO_2)); _for_each_inner!((0, 3, CPU_GPIO_3)); _for_each_inner!((0, 4,
        CPU_GPIO_4)); _for_each_inner!((0, 5, CPU_GPIO_5)); _for_each_inner!((0, 6,
        CPU_GPIO_6)); _for_each_inner!((0, 7, CPU_GPIO_7));
        _for_each_inner!((channels(0), (1), (2), (3), (4), (5), (6), (7)));
        _for_each_inner!((signals(0, 0, CPU_GPIO_0), (0, 1, CPU_GPIO_1), (0, 2,
        CPU_GPIO_2), (0, 3, CPU_GPIO_3), (0, 4, CPU_GPIO_4), (0, 5, CPU_GPIO_5), (0, 6,
        CPU_GPIO_6), (0, 7, CPU_GPIO_7)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sw_interrupt {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, FROM_CPU_INTR0, software_interrupt0)); _for_each_inner!((1,
        FROM_CPU_INTR1, software_interrupt1)); _for_each_inner!((2, FROM_CPU_INTR2,
        software_interrupt2)); _for_each_inner!((3, FROM_CPU_INTR3,
        software_interrupt3)); _for_each_inner!((all(0, FROM_CPU_INTR0,
        software_interrupt0), (1, FROM_CPU_INTR1, software_interrupt1), (2,
        FROM_CPU_INTR2, software_interrupt2), (3, FROM_CPU_INTR3, software_interrupt3)));
    };
}
#[macro_export]
macro_rules! sw_interrupt_delay {
    () => {
        unsafe {
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
            ::core::arch::asm!("nop");
        }
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0)); _for_each_inner!((1)); _for_each_inner!((2));
        _for_each_inner!((3)); _for_each_inner!((0, 0)); _for_each_inner!((1, 1));
        _for_each_inner!((2, 0)); _for_each_inner!((3, 1)); _for_each_inner!((all(0),
        (1), (2), (3))); _for_each_inner!((tx(0, 0), (1, 1))); _for_each_inner!((rx(2,
        0), (3, 1)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Pll80MHz, 1)); _for_each_inner!((RcFast, 2));
        _for_each_inner!((Xtal, 3)); _for_each_inner!((Pll80MHz));
        _for_each_inner!((all(Pll80MHz, 1), (RcFast, 2), (Xtal, 3)));
        _for_each_inner!((default(Pll80MHz)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((1568)); _for_each_inner!((1600)); _for_each_inner!((1632));
        _for_each_inner!((1664)); _for_each_inner!((1696)); _for_each_inner!((1728));
        _for_each_inner!((1760)); _for_each_inner!((1792)); _for_each_inner!((1824));
        _for_each_inner!((1856)); _for_each_inner!((1888)); _for_each_inner!((1920));
        _for_each_inner!((1952)); _for_each_inner!((1984)); _for_each_inner!((2016));
        _for_each_inner!((2048)); _for_each_inner!((2080)); _for_each_inner!((2112));
        _for_each_inner!((2144)); _for_each_inner!((2176)); _for_each_inner!((2208));
        _for_each_inner!((2240)); _for_each_inner!((2272)); _for_each_inner!((2304));
        _for_each_inner!((2336)); _for_each_inner!((2368)); _for_each_inner!((2400));
        _for_each_inner!((2432)); _for_each_inner!((2464)); _for_each_inner!((2496));
        _for_each_inner!((2528)); _for_each_inner!((2560)); _for_each_inner!((2592));
        _for_each_inner!((2624)); _for_each_inner!((2656)); _for_each_inner!((2688));
        _for_each_inner!((2720)); _for_each_inner!((2752)); _for_each_inner!((2784));
        _for_each_inner!((2816)); _for_each_inner!((2848)); _for_each_inner!((2880));
        _for_each_inner!((2912)); _for_each_inner!((2944)); _for_each_inner!((2976));
        _for_each_inner!((3008)); _for_each_inner!((3040)); _for_each_inner!((3072));
        _for_each_inner!((all(32), (64), (96), (128), (160), (192), (224), (256), (288),
        (320), (352), (384), (416), (448), (480), (512), (544), (576), (608), (640),
        (672), (704), (736), (768), (800), (832), (864), (896), (928), (960), (992),
        (1024), (1056), (1088), (1120), (1152), (1184), (1216), (1248), (1280), (1312),
        (1344), (1376), (1408), (1440), (1472), (1504), (1536), (1568), (1600), (1632),
        (1664), (1696), (1728), (1760), (1792), (1824), (1856), (1888), (1920), (1952),
        (1984), (2016), (2048), (2080), (2112), (2144), (2176), (2208), (2240), (2272),
        (2304), (2336), (2368), (2400), (2432), (2464), (2496), (2528), (2560), (2592),
        (2624), (2656), (2688), (2720), (2752), (2784), (2816), (2848), (2880), (2912),
        (2944), (2976), (3008), (3040), (3072)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((all(32), (64), (96), (128), (160), (192), (224), (256), (288),
        (320), (352), (384), (416), (448), (480), (512), (544), (576), (608), (640),
        (672), (704), (736), (768), (800), (832), (864), (896), (928), (960), (992),
        (1024), (1056), (1088), (1120), (1152), (1184), (1216), (1248), (1280), (1312),
        (1344), (1376), (1408), (1440), (1472), (1504), (1536)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Sha1, "SHA-1"(sizes : 64, 20, 8) (insecure_against :
        "collision", "length extension"), 0)); _for_each_inner!((Sha224, "SHA-224"(sizes
        : 64, 28, 8) (insecure_against : "length extension"), 1));
        _for_each_inner!((Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against :
        "length extension"), 2)); _for_each_inner!((algos(Sha1, "SHA-1"(sizes : 64, 20,
        8) (insecure_against : "collision", "length extension"), 0), (Sha224,
        "SHA-224"(sizes : 64, 28, 8) (insecure_against : "length extension"), 1),
        (Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against : "length extension"),
        2)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA));
        _for_each_inner!((all(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident, $rts:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner!((UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner!((all(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (UART1, Uart1,
        U1RXD, U1TXD, U1CTS, U1RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, [$($cs:ident),*] [$($sio:ident),*
/// $($is_qspi:iteral)?])`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((@ peri_type GPIO0 <= virtual())); _for_each_inner!((@ peri_type
        GPIO1 <= virtual())); _for_each_inner!((@ peri_type GPIO2 <= virtual()));
        _for_each_inner!((@ peri_type GPIO3 <= virtual())); _for_each_inner!((@ peri_type
        GPIO4 <= virtual())); _for_each_inner!((@ peri_type GPIO5 <= virtual()));
        _for_each_inner!((@ peri_type GPIO6 <= virtual())); _for_each_inner!((@ peri_type
        GPIO7 <= virtual())); _for_each_inner!((@ peri_type GPIO8 <= virtual()));
        _for_each_inner!((@ peri_type GPIO9 <= virtual())); _for_each_inner!((@ peri_type
        GPIO10 <= virtual())); _for_each_inner!((@ peri_type GPIO11 <= virtual()));
        _for_each_inner!((@ peri_type GPIO12 <= virtual())); _for_each_inner!((@
        peri_type GPIO13 <= virtual())); _for_each_inner!((@ peri_type GPIO14 <=
        virtual())); _for_each_inner!((@ peri_type GPIO15 <= virtual()));
        _for_each_inner!((@ peri_type GPIO16 <= virtual())); _for_each_inner!((@
        peri_type GPIO17 <= virtual())); _for_each_inner!((@ peri_type GPIO18 <=
        virtual())); _for_each_inner!((@ peri_type GPIO19 <= virtual()));
        _for_each_inner!((@ peri_type GPIO20 <= virtual())); _for_each_inner!((@
        peri_type GPIO21 <= virtual())); _for_each_inner!((@ peri_type GPIO22 <=
        virtual())); _for_each_inner!((@ peri_type GPIO23 <= virtual()));
        _for_each_inner!((@ peri_type GPIO24 <= virtual())); _for_each_inner!((@
        peri_type GPIO25 <= virtual())); _for_each_inner!((@ peri_type GPIO26 <=
        virtual())); _for_each_inner!((@ peri_type GPIO27 <= virtual()));
        _for_each_inner!((@ peri_type GPIO28 <= virtual())); _for_each_inner!((@
        peri_type GPIO29 <= virtual())); _for_each_inner!((@ peri_type GPIO30 <=
        virtual())); _for_each_inner!((@ peri_type AES <= AES(AES : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type APB_SARADC <= APB_SARADC()
        (unstable))); _for_each_inner!((@ peri_type ASSIST_DEBUG <= ASSIST_DEBUG()
        (unstable))); _for_each_inner!((@ peri_type ATOMIC <= ATOMIC() (unstable)));
        _for_each_inner!((@ peri_type DMA <= DMA() (unstable))); _for_each_inner!((@
        peri_type DS <= DS() (unstable))); _for_each_inner!((@ peri_type ECC <= ECC()
        (unstable))); _for_each_inner!((@ peri_type EFUSE <= EFUSE() (unstable)));
        _for_each_inner!((@ peri_type EXTMEM <= EXTMEM() (unstable)));
        _for_each_inner!((@ peri_type GPIO <= GPIO() (unstable))); _for_each_inner!((@
        peri_type GPIO_SD <= GPIO_SD() (unstable))); _for_each_inner!((@ peri_type HINF
        <= HINF() (unstable))); _for_each_inner!((@ peri_type HMAC <= HMAC()
        (unstable))); _for_each_inner!((@ peri_type HP_APM <= HP_APM() (unstable)));
        _for_each_inner!((@ peri_type HP_SYS <= HP_SYS() (unstable)));
        _for_each_inner!((@ peri_type I2C_ANA_MST <= I2C_ANA_MST() (unstable)));
        _for_each_inner!((@ peri_type I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        I2S0 <= I2S0(I2S0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type IEEE802154
        <= IEEE802154() (unstable))); _for_each_inner!((@ peri_type INTERRUPT_CORE0 <=
        INTERRUPT_CORE0() (unstable))); _for_each_inner!((@ peri_type INTPRI <= INTPRI()
        (unstable))); _for_each_inner!((@ peri_type IO_MUX <= IO_MUX() (unstable)));
        _for_each_inner!((@ peri_type LEDC <= LEDC() (unstable))); _for_each_inner!((@
        peri_type LP_ANA <= LP_ANA() (unstable))); _for_each_inner!((@ peri_type LP_AON
        <= LP_AON() (unstable))); _for_each_inner!((@ peri_type LP_APM <= LP_APM()
        (unstable))); _for_each_inner!((@ peri_type LP_APM0 <= LP_APM0() (unstable)));
        _for_each_inner!((@ peri_type LP_CLKRST <= LP_CLKRST() (unstable)));
        _for_each_inner!((@ peri_type LP_I2C0 <= LP_I2C0() (unstable)));
        _for_each_inner!((@ peri_type LP_I2C_ANA_MST <= LP_I2C_ANA_MST() (unstable)));
        _for_each_inner!((@ peri_type LP_IO <= LP_IO() (unstable))); _for_each_inner!((@
        peri_type LP_PERI <= LP_PERI() (unstable))); _for_each_inner!((@ peri_type LP_TEE
        <= LP_TEE() (unstable))); _for_each_inner!((@ peri_type LP_TIMER <= LP_TIMER()
        (unstable))); _for_each_inner!((@ peri_type LP_UART <= LP_UART() (unstable)));
        _for_each_inner!((@ peri_type LP_WDT <= LP_WDT() (unstable)));
        _for_each_inner!((@ peri_type LPWR <= LP_CLKRST() (unstable)));
        _for_each_inner!((@ peri_type MCPWM0 <= MCPWM0() (unstable)));
        _for_each_inner!((@ peri_type MEM_MONITOR <= MEM_MONITOR() (unstable)));
        _for_each_inner!((@ peri_type MODEM_LPCON <= MODEM_LPCON() (unstable)));
        _for_each_inner!((@ peri_type MODEM_SYSCON <= MODEM_SYSCON() (unstable)));
        _for_each_inner!((@ peri_type OTP_DEBUG <= OTP_DEBUG() (unstable)));
        _for_each_inner!((@ peri_type PARL_IO <= PARL_IO(PARL_IO : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((@ peri_type PAU <= PAU() (unstable))); _for_each_inner!((@
        peri_type PCNT <= PCNT() (unstable))); _for_each_inner!((@ peri_type PCR <= PCR()
        (unstable))); _for_each_inner!((@ peri_type PLIC_MX <= PLIC_MX() (unstable)));
        _for_each_inner!((@ peri_type PMU <= PMU() (unstable))); _for_each_inner!((@
        peri_type RMT <= RMT() (unstable))); _for_each_inner!((@ peri_type RNG <= RNG()
        (unstable))); _for_each_inner!((@ peri_type RSA <= RSA(RSA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type SHA <= SHA(SHA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((@ peri_type SLCHOST <= SLCHOST() (unstable)));
        _for_each_inner!((@ peri_type ETM <= SOC_ETM() (unstable))); _for_each_inner!((@
        peri_type SPI0 <= SPI0() (unstable))); _for_each_inner!((@ peri_type SPI1 <=
        SPI1() (unstable))); _for_each_inner!((@ peri_type SPI2 <= SPI2(SPI2 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((@ peri_type SYSTEM <= PCR() (unstable))); _for_each_inner!((@
        peri_type SYSTIMER <= SYSTIMER() (unstable))); _for_each_inner!((@ peri_type TEE
        <= TEE() (unstable))); _for_each_inner!((@ peri_type TIMG0 <= TIMG0()
        (unstable))); _for_each_inner!((@ peri_type TIMG1 <= TIMG1() (unstable)));
        _for_each_inner!((@ peri_type TRACE0 <= TRACE() (unstable))); _for_each_inner!((@
        peri_type TWAI0 <= TWAI0() (unstable))); _for_each_inner!((@ peri_type TWAI1 <=
        TWAI1() (unstable))); _for_each_inner!((@ peri_type UART0 <= UART0(UART0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((@ peri_type UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((@ peri_type
        UHCI0 <= UHCI0() (unstable))); _for_each_inner!((@ peri_type USB_DEVICE <=
        USB_DEVICE(USB_DEVICE : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((@ peri_type DMA_CH0 <=
        virtual() (unstable))); _for_each_inner!((@ peri_type DMA_CH1 <= virtual()
        (unstable))); _for_each_inner!((@ peri_type DMA_CH2 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type ADC1 <= virtual() (unstable))); _for_each_inner!((@
        peri_type BT <= virtual() (unstable))); _for_each_inner!((@ peri_type FLASH <=
        virtual() (unstable))); _for_each_inner!((@ peri_type GPIO_DEDICATED <= virtual()
        (unstable))); _for_each_inner!((@ peri_type LP_CORE <= virtual() (unstable)));
        _for_each_inner!((@ peri_type SW_INTERRUPT <= virtual() (unstable)));
        _for_each_inner!((@ peri_type TSENS <= virtual() (unstable)));
        _for_each_inner!((@ peri_type WIFI <= virtual() (unstable))); _for_each_inner!((@
        peri_type MEM2MEM1 <= virtual() (unstable))); _for_each_inner!((@ peri_type
        MEM2MEM4 <= virtual() (unstable))); _for_each_inner!((@ peri_type MEM2MEM5 <=
        virtual() (unstable))); _for_each_inner!((@ peri_type MEM2MEM10 <= virtual()
        (unstable))); _for_each_inner!((@ peri_type MEM2MEM11 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type MEM2MEM12 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type MEM2MEM13 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type MEM2MEM14 <= virtual() (unstable)));
        _for_each_inner!((@ peri_type MEM2MEM15 <= virtual() (unstable)));
        _for_each_inner!((GPIO0)); _for_each_inner!((GPIO1)); _for_each_inner!((GPIO2));
        _for_each_inner!((GPIO3)); _for_each_inner!((GPIO4)); _for_each_inner!((GPIO5));
        _for_each_inner!((GPIO6)); _for_each_inner!((GPIO7)); _for_each_inner!((GPIO8));
        _for_each_inner!((GPIO9)); _for_each_inner!((GPIO10));
        _for_each_inner!((GPIO11)); _for_each_inner!((GPIO12));
        _for_each_inner!((GPIO13)); _for_each_inner!((GPIO14));
        _for_each_inner!((GPIO15)); _for_each_inner!((GPIO16));
        _for_each_inner!((GPIO17)); _for_each_inner!((GPIO18));
        _for_each_inner!((GPIO19)); _for_each_inner!((GPIO20));
        _for_each_inner!((GPIO21)); _for_each_inner!((GPIO22));
        _for_each_inner!((GPIO23)); _for_each_inner!((GPIO27));
        _for_each_inner!((AES(unstable))); _for_each_inner!((APB_SARADC(unstable)));
        _for_each_inner!((ASSIST_DEBUG(unstable))); _for_each_inner!((ATOMIC(unstable)));
        _for_each_inner!((DMA(unstable))); _for_each_inner!((DS(unstable)));
        _for_each_inner!((ECC(unstable))); _for_each_inner!((EFUSE(unstable)));
        _for_each_inner!((EXTMEM(unstable))); _for_each_inner!((GPIO(unstable)));
        _for_each_inner!((GPIO_SD(unstable))); _for_each_inner!((HINF(unstable)));
        _for_each_inner!((HMAC(unstable))); _for_each_inner!((HP_APM(unstable)));
        _for_each_inner!((HP_SYS(unstable))); _for_each_inner!((I2C_ANA_MST(unstable)));
        _for_each_inner!((I2C0)); _for_each_inner!((I2S0(unstable)));
        _for_each_inner!((IEEE802154(unstable)));
        _for_each_inner!((INTERRUPT_CORE0(unstable)));
        _for_each_inner!((INTPRI(unstable))); _for_each_inner!((IO_MUX(unstable)));
        _for_each_inner!((LEDC(unstable))); _for_each_inner!((LP_ANA(unstable)));
        _for_each_inner!((LP_AON(unstable))); _for_each_inner!((LP_APM(unstable)));
        _for_each_inner!((LP_APM0(unstable))); _for_each_inner!((LP_CLKRST(unstable)));
        _for_each_inner!((LP_I2C0(unstable)));
        _for_each_inner!((LP_I2C_ANA_MST(unstable)));
        _for_each_inner!((LP_IO(unstable))); _for_each_inner!((LP_PERI(unstable)));
        _for_each_inner!((LP_TEE(unstable))); _for_each_inner!((LP_TIMER(unstable)));
        _for_each_inner!((LP_UART(unstable))); _for_each_inner!((LP_WDT(unstable)));
        _for_each_inner!((LPWR(unstable))); _for_each_inner!((MCPWM0(unstable)));
        _for_each_inner!((MEM_MONITOR(unstable)));
        _for_each_inner!((MODEM_LPCON(unstable)));
        _for_each_inner!((MODEM_SYSCON(unstable)));
        _for_each_inner!((OTP_DEBUG(unstable))); _for_each_inner!((PARL_IO(unstable)));
        _for_each_inner!((PAU(unstable))); _for_each_inner!((PCNT(unstable)));
        _for_each_inner!((PCR(unstable))); _for_each_inner!((PLIC_MX(unstable)));
        _for_each_inner!((PMU(unstable))); _for_each_inner!((RMT(unstable)));
        _for_each_inner!((RNG(unstable))); _for_each_inner!((RSA(unstable)));
        _for_each_inner!((SHA(unstable))); _for_each_inner!((SLCHOST(unstable)));
        _for_each_inner!((ETM(unstable))); _for_each_inner!((SPI0(unstable)));
        _for_each_inner!((SPI1(unstable))); _for_each_inner!((SPI2));
        _for_each_inner!((SYSTEM(unstable))); _for_each_inner!((SYSTIMER(unstable)));
        _for_each_inner!((TEE(unstable))); _for_each_inner!((TIMG0(unstable)));
        _for_each_inner!((TIMG1(unstable))); _for_each_inner!((TRACE0(unstable)));
        _for_each_inner!((TWAI0(unstable))); _for_each_inner!((TWAI1(unstable)));
        _for_each_inner!((UART0)); _for_each_inner!((UART1));
        _for_each_inner!((UHCI0(unstable))); _for_each_inner!((USB_DEVICE(unstable)));
        _for_each_inner!((DMA_CH0(unstable))); _for_each_inner!((DMA_CH1(unstable)));
        _for_each_inner!((DMA_CH2(unstable))); _for_each_inner!((ADC1(unstable)));
        _for_each_inner!((BT(unstable))); _for_each_inner!((FLASH(unstable)));
        _for_each_inner!((GPIO_DEDICATED(unstable)));
        _for_each_inner!((LP_CORE(unstable)));
        _for_each_inner!((SW_INTERRUPT(unstable))); _for_each_inner!((TSENS(unstable)));
        _for_each_inner!((WIFI(unstable))); _for_each_inner!((MEM2MEM1(unstable)));
        _for_each_inner!((MEM2MEM4(unstable))); _for_each_inner!((MEM2MEM5(unstable)));
        _for_each_inner!((MEM2MEM10(unstable))); _for_each_inner!((MEM2MEM11(unstable)));
        _for_each_inner!((MEM2MEM12(unstable))); _for_each_inner!((MEM2MEM13(unstable)));
        _for_each_inner!((MEM2MEM14(unstable))); _for_each_inner!((MEM2MEM15(unstable)));
        _for_each_inner!((all(@ peri_type GPIO0 <= virtual()), (@ peri_type GPIO1 <=
        virtual()), (@ peri_type GPIO2 <= virtual()), (@ peri_type GPIO3 <= virtual()),
        (@ peri_type GPIO4 <= virtual()), (@ peri_type GPIO5 <= virtual()), (@ peri_type
        GPIO6 <= virtual()), (@ peri_type GPIO7 <= virtual()), (@ peri_type GPIO8 <=
        virtual()), (@ peri_type GPIO9 <= virtual()), (@ peri_type GPIO10 <= virtual()),
        (@ peri_type GPIO11 <= virtual()), (@ peri_type GPIO12 <= virtual()), (@
        peri_type GPIO13 <= virtual()), (@ peri_type GPIO14 <= virtual()), (@ peri_type
        GPIO15 <= virtual()), (@ peri_type GPIO16 <= virtual()), (@ peri_type GPIO17 <=
        virtual()), (@ peri_type GPIO18 <= virtual()), (@ peri_type GPIO19 <= virtual()),
        (@ peri_type GPIO20 <= virtual()), (@ peri_type GPIO21 <= virtual()), (@
        peri_type GPIO22 <= virtual()), (@ peri_type GPIO23 <= virtual()), (@ peri_type
        GPIO24 <= virtual()), (@ peri_type GPIO25 <= virtual()), (@ peri_type GPIO26 <=
        virtual()), (@ peri_type GPIO27 <= virtual()), (@ peri_type GPIO28 <= virtual()),
        (@ peri_type GPIO29 <= virtual()), (@ peri_type GPIO30 <= virtual()), (@
        peri_type AES <= AES(AES : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type APB_SARADC <= APB_SARADC()
        (unstable)), (@ peri_type ASSIST_DEBUG <= ASSIST_DEBUG() (unstable)), (@
        peri_type ATOMIC <= ATOMIC() (unstable)), (@ peri_type DMA <= DMA() (unstable)),
        (@ peri_type DS <= DS() (unstable)), (@ peri_type ECC <= ECC() (unstable)), (@
        peri_type EFUSE <= EFUSE() (unstable)), (@ peri_type EXTMEM <= EXTMEM()
        (unstable)), (@ peri_type GPIO <= GPIO() (unstable)), (@ peri_type GPIO_SD <=
        GPIO_SD() (unstable)), (@ peri_type HINF <= HINF() (unstable)), (@ peri_type HMAC
        <= HMAC() (unstable)), (@ peri_type HP_APM <= HP_APM() (unstable)), (@ peri_type
        HP_SYS <= HP_SYS() (unstable)), (@ peri_type I2C_ANA_MST <= I2C_ANA_MST()
        (unstable)), (@ peri_type I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type I2S0 <= I2S0(I2S0
        : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type IEEE802154 <= IEEE802154() (unstable)), (@ peri_type
        INTERRUPT_CORE0 <= INTERRUPT_CORE0() (unstable)), (@ peri_type INTPRI <= INTPRI()
        (unstable)), (@ peri_type IO_MUX <= IO_MUX() (unstable)), (@ peri_type LEDC <=
        LEDC() (unstable)), (@ peri_type LP_ANA <= LP_ANA() (unstable)), (@ peri_type
        LP_AON <= LP_AON() (unstable)), (@ peri_type LP_APM <= LP_APM() (unstable)), (@
        peri_type LP_APM0 <= LP_APM0() (unstable)), (@ peri_type LP_CLKRST <= LP_CLKRST()
        (unstable)), (@ peri_type LP_I2C0 <= LP_I2C0() (unstable)), (@ peri_type
        LP_I2C_ANA_MST <= LP_I2C_ANA_MST() (unstable)), (@ peri_type LP_IO <= LP_IO()
        (unstable)), (@ peri_type LP_PERI <= LP_PERI() (unstable)), (@ peri_type LP_TEE
        <= LP_TEE() (unstable)), (@ peri_type LP_TIMER <= LP_TIMER() (unstable)), (@
        peri_type LP_UART <= LP_UART() (unstable)), (@ peri_type LP_WDT <= LP_WDT()
        (unstable)), (@ peri_type LPWR <= LP_CLKRST() (unstable)), (@ peri_type MCPWM0 <=
        MCPWM0() (unstable)), (@ peri_type MEM_MONITOR <= MEM_MONITOR() (unstable)), (@
        peri_type MODEM_LPCON <= MODEM_LPCON() (unstable)), (@ peri_type MODEM_SYSCON <=
        MODEM_SYSCON() (unstable)), (@ peri_type OTP_DEBUG <= OTP_DEBUG() (unstable)), (@
        peri_type PARL_IO <= PARL_IO(PARL_IO : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type PAU <=
        PAU() (unstable)), (@ peri_type PCNT <= PCNT() (unstable)), (@ peri_type PCR <=
        PCR() (unstable)), (@ peri_type PLIC_MX <= PLIC_MX() (unstable)), (@ peri_type
        PMU <= PMU() (unstable)), (@ peri_type RMT <= RMT() (unstable)), (@ peri_type RNG
        <= RNG() (unstable)), (@ peri_type RSA <= RSA(RSA : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type SHA <=
        SHA(SHA : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type SLCHOST <= SLCHOST() (unstable)), (@ peri_type ETM <=
        SOC_ETM() (unstable)), (@ peri_type SPI0 <= SPI0() (unstable)), (@ peri_type SPI1
        <= SPI1() (unstable)), (@ peri_type SPI2 <= SPI2(SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type SYSTEM <= PCR()
        (unstable)), (@ peri_type SYSTIMER <= SYSTIMER() (unstable)), (@ peri_type TEE <=
        TEE() (unstable)), (@ peri_type TIMG0 <= TIMG0() (unstable)), (@ peri_type TIMG1
        <= TIMG1() (unstable)), (@ peri_type TRACE0 <= TRACE() (unstable)), (@ peri_type
        TWAI0 <= TWAI0() (unstable)), (@ peri_type TWAI1 <= TWAI1() (unstable)), (@
        peri_type UART0 <= UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type UART1 <= UART1(UART1 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type UHCI0 <= UHCI0() (unstable)), (@ peri_type USB_DEVICE <=
        USB_DEVICE(USB_DEVICE : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (@ peri_type DMA_CH0 <= virtual()
        (unstable)), (@ peri_type DMA_CH1 <= virtual() (unstable)), (@ peri_type DMA_CH2
        <= virtual() (unstable)), (@ peri_type ADC1 <= virtual() (unstable)), (@
        peri_type BT <= virtual() (unstable)), (@ peri_type FLASH <= virtual()
        (unstable)), (@ peri_type GPIO_DEDICATED <= virtual() (unstable)), (@ peri_type
        LP_CORE <= virtual() (unstable)), (@ peri_type SW_INTERRUPT <= virtual()
        (unstable)), (@ peri_type TSENS <= virtual() (unstable)), (@ peri_type WIFI <=
        virtual() (unstable)), (@ peri_type MEM2MEM1 <= virtual() (unstable)), (@
        peri_type MEM2MEM4 <= virtual() (unstable)), (@ peri_type MEM2MEM5 <= virtual()
        (unstable)), (@ peri_type MEM2MEM10 <= virtual() (unstable)), (@ peri_type
        MEM2MEM11 <= virtual() (unstable)), (@ peri_type MEM2MEM12 <= virtual()
        (unstable)), (@ peri_type MEM2MEM13 <= virtual() (unstable)), (@ peri_type
        MEM2MEM14 <= virtual() (unstable)), (@ peri_type MEM2MEM15 <= virtual()
        (unstable)))); _for_each_inner!((singletons(GPIO0), (GPIO1), (GPIO2), (GPIO3),
        (GPIO4), (GPIO5), (GPIO6), (GPIO7), (GPIO8), (GPIO9), (GPIO10), (GPIO11),
        (GPIO12), (GPIO13), (GPIO14), (GPIO15), (GPIO16), (GPIO17), (GPIO18), (GPIO19),
        (GPIO20), (GPIO21), (GPIO22), (GPIO23), (GPIO27), (AES(unstable)),
        (APB_SARADC(unstable)), (ASSIST_DEBUG(unstable)), (ATOMIC(unstable)),
        (DMA(unstable)), (DS(unstable)), (ECC(unstable)), (EFUSE(unstable)),
        (EXTMEM(unstable)), (GPIO(unstable)), (GPIO_SD(unstable)), (HINF(unstable)),
        (HMAC(unstable)), (HP_APM(unstable)), (HP_SYS(unstable)),
        (I2C_ANA_MST(unstable)), (I2C0), (I2S0(unstable)), (IEEE802154(unstable)),
        (INTERRUPT_CORE0(unstable)), (INTPRI(unstable)), (IO_MUX(unstable)),
        (LEDC(unstable)), (LP_ANA(unstable)), (LP_AON(unstable)), (LP_APM(unstable)),
        (LP_APM0(unstable)), (LP_CLKRST(unstable)), (LP_I2C0(unstable)),
        (LP_I2C_ANA_MST(unstable)), (LP_IO(unstable)), (LP_PERI(unstable)),
        (LP_TEE(unstable)), (LP_TIMER(unstable)), (LP_UART(unstable)),
        (LP_WDT(unstable)), (LPWR(unstable)), (MCPWM0(unstable)),
        (MEM_MONITOR(unstable)), (MODEM_LPCON(unstable)), (MODEM_SYSCON(unstable)),
        (OTP_DEBUG(unstable)), (PARL_IO(unstable)), (PAU(unstable)), (PCNT(unstable)),
        (PCR(unstable)), (PLIC_MX(unstable)), (PMU(unstable)), (RMT(unstable)),
        (RNG(unstable)), (RSA(unstable)), (SHA(unstable)), (SLCHOST(unstable)),
        (ETM(unstable)), (SPI0(unstable)), (SPI1(unstable)), (SPI2), (SYSTEM(unstable)),
        (SYSTIMER(unstable)), (TEE(unstable)), (TIMG0(unstable)), (TIMG1(unstable)),
        (TRACE0(unstable)), (TWAI0(unstable)), (TWAI1(unstable)), (UART0), (UART1),
        (UHCI0(unstable)), (USB_DEVICE(unstable)), (DMA_CH0(unstable)),
        (DMA_CH1(unstable)), (DMA_CH2(unstable)), (ADC1(unstable)), (BT(unstable)),
        (FLASH(unstable)), (GPIO_DEDICATED(unstable)), (LP_CORE(unstable)),
        (SW_INTERRUPT(unstable)), (TSENS(unstable)), (WIFI(unstable)),
        (MEM2MEM1(unstable)), (MEM2MEM4(unstable)), (MEM2MEM5(unstable)),
        (MEM2MEM10(unstable)), (MEM2MEM11(unstable)), (MEM2MEM12(unstable)),
        (MEM2MEM13(unstable)), (MEM2MEM14(unstable)), (MEM2MEM15(unstable))));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, GPIO0() () ([Input] [Output]))); _for_each_inner!((1,
        GPIO1() () ([Input] [Output]))); _for_each_inner!((2, GPIO2(_2 => FSPIQ) (_2 =>
        FSPIQ) ([Input] [Output]))); _for_each_inner!((3, GPIO3() () ([Input]
        [Output]))); _for_each_inner!((4, GPIO4(_0 => MTMS _2 => FSPIHD) (_2 => FSPIHD)
        ([Input] [Output]))); _for_each_inner!((5, GPIO5(_0 => MTDI _2 => FSPIWP) (_2 =>
        FSPIWP) ([Input] [Output]))); _for_each_inner!((6, GPIO6(_0 => MTCK _2 =>
        FSPICLK) (_2 => FSPICLK) ([Input] [Output]))); _for_each_inner!((7, GPIO7(_2 =>
        FSPID) (_0 => MTDO _2 => FSPID) ([Input] [Output]))); _for_each_inner!((8,
        GPIO8() () ([Input] [Output]))); _for_each_inner!((9, GPIO9() () ([Input]
        [Output]))); _for_each_inner!((10, GPIO10() () ([Input] [Output])));
        _for_each_inner!((11, GPIO11() () ([Input] [Output]))); _for_each_inner!((12,
        GPIO12() () ([Input] [Output]))); _for_each_inner!((13, GPIO13() () ([Input]
        [Output]))); _for_each_inner!((14, GPIO14() () ([Input] [Output])));
        _for_each_inner!((15, GPIO15() () ([Input] [Output]))); _for_each_inner!((16,
        GPIO16(_2 => FSPICS0) (_0 => U0TXD _2 => FSPICS0) ([Input] [Output])));
        _for_each_inner!((17, GPIO17(_0 => U0RXD) (_2 => FSPICS1) ([Input] [Output])));
        _for_each_inner!((18, GPIO18(_0 => SDIO_CMD) (_0 => SDIO_CMD _2 => FSPICS2)
        ([Input] [Output]))); _for_each_inner!((19, GPIO19() (_0 => SDIO_CLK _2 =>
        FSPICS3) ([Input] [Output]))); _for_each_inner!((20, GPIO20(_0 => SDIO_DATA0) (_0
        => SDIO_DATA0 _2 => FSPICS4) ([Input] [Output]))); _for_each_inner!((21,
        GPIO21(_0 => SDIO_DATA1) (_0 => SDIO_DATA1 _2 => FSPICS5) ([Input] [Output])));
        _for_each_inner!((22, GPIO22(_0 => SDIO_DATA2) (_0 => SDIO_DATA2) ([Input]
        [Output]))); _for_each_inner!((23, GPIO23(_0 => SDIO_DATA3) (_0 => SDIO_DATA3)
        ([Input] [Output]))); _for_each_inner!((24, GPIO24() (_0 => SPICS0) ([Input]
        [Output]))); _for_each_inner!((25, GPIO25(_0 => SPIQ) (_0 => SPIQ) ([Input]
        [Output]))); _for_each_inner!((26, GPIO26(_0 => SPIWP) (_0 => SPIWP) ([Input]
        [Output]))); _for_each_inner!((27, GPIO27() () ([Input] [Output])));
        _for_each_inner!((28, GPIO28(_0 => SPIHD) (_0 => SPIHD) ([Input] [Output])));
        _for_each_inner!((29, GPIO29() (_0 => SPICLK) ([Input] [Output])));
        _for_each_inner!((30, GPIO30(_0 => SPID) (_0 => SPID) ([Input] [Output])));
        _for_each_inner!((all(0, GPIO0() () ([Input] [Output])), (1, GPIO1() () ([Input]
        [Output])), (2, GPIO2(_2 => FSPIQ) (_2 => FSPIQ) ([Input] [Output])), (3, GPIO3()
        () ([Input] [Output])), (4, GPIO4(_0 => MTMS _2 => FSPIHD) (_2 => FSPIHD)
        ([Input] [Output])), (5, GPIO5(_0 => MTDI _2 => FSPIWP) (_2 => FSPIWP) ([Input]
        [Output])), (6, GPIO6(_0 => MTCK _2 => FSPICLK) (_2 => FSPICLK) ([Input]
        [Output])), (7, GPIO7(_2 => FSPID) (_0 => MTDO _2 => FSPID) ([Input] [Output])),
        (8, GPIO8() () ([Input] [Output])), (9, GPIO9() () ([Input] [Output])), (10,
        GPIO10() () ([Input] [Output])), (11, GPIO11() () ([Input] [Output])), (12,
        GPIO12() () ([Input] [Output])), (13, GPIO13() () ([Input] [Output])), (14,
        GPIO14() () ([Input] [Output])), (15, GPIO15() () ([Input] [Output])), (16,
        GPIO16(_2 => FSPICS0) (_0 => U0TXD _2 => FSPICS0) ([Input] [Output])), (17,
        GPIO17(_0 => U0RXD) (_2 => FSPICS1) ([Input] [Output])), (18, GPIO18(_0 =>
        SDIO_CMD) (_0 => SDIO_CMD _2 => FSPICS2) ([Input] [Output])), (19, GPIO19() (_0
        => SDIO_CLK _2 => FSPICS3) ([Input] [Output])), (20, GPIO20(_0 => SDIO_DATA0) (_0
        => SDIO_DATA0 _2 => FSPICS4) ([Input] [Output])), (21, GPIO21(_0 => SDIO_DATA1)
        (_0 => SDIO_DATA1 _2 => FSPICS5) ([Input] [Output])), (22, GPIO22(_0 =>
        SDIO_DATA2) (_0 => SDIO_DATA2) ([Input] [Output])), (23, GPIO23(_0 => SDIO_DATA3)
        (_0 => SDIO_DATA3) ([Input] [Output])), (24, GPIO24() (_0 => SPICS0) ([Input]
        [Output])), (25, GPIO25(_0 => SPIQ) (_0 => SPIQ) ([Input] [Output])), (26,
        GPIO26(_0 => SPIWP) (_0 => SPIWP) ([Input] [Output])), (27, GPIO27() () ([Input]
        [Output])), (28, GPIO28(_0 => SPIHD) (_0 => SPIHD) ([Input] [Output])), (29,
        GPIO29() (_0 => SPICLK) ([Input] [Output])), (30, GPIO30(_0 => SPID) (_0 => SPID)
        ([Input] [Output]))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((XTAL_32K_P, GPIO0)); _for_each_inner!((ADC0_CH0, GPIO0));
        _for_each_inner!((XTAL_32K_N, GPIO1)); _for_each_inner!((ADC0_CH1, GPIO1));
        _for_each_inner!((ADC0_CH2, GPIO2)); _for_each_inner!((ADC0_CH3, GPIO3));
        _for_each_inner!((ADC0_CH4, GPIO4)); _for_each_inner!((ADC0_CH5, GPIO5));
        _for_each_inner!((ADC0_CH6, GPIO6)); _for_each_inner!((USB_DM, GPIO12));
        _for_each_inner!((USB_DP, GPIO13)); _for_each_inner!(((ADC0_CH0, ADCn_CHm, 0, 0),
        GPIO0)); _for_each_inner!(((ADC0_CH1, ADCn_CHm, 0, 1), GPIO1));
        _for_each_inner!(((ADC0_CH2, ADCn_CHm, 0, 2), GPIO2));
        _for_each_inner!(((ADC0_CH3, ADCn_CHm, 0, 3), GPIO3));
        _for_each_inner!(((ADC0_CH4, ADCn_CHm, 0, 4), GPIO4));
        _for_each_inner!(((ADC0_CH5, ADCn_CHm, 0, 5), GPIO5));
        _for_each_inner!(((ADC0_CH6, ADCn_CHm, 0, 6), GPIO6));
        _for_each_inner!((all(XTAL_32K_P, GPIO0), (ADC0_CH0, GPIO0), (XTAL_32K_N, GPIO1),
        (ADC0_CH1, GPIO1), (ADC0_CH2, GPIO2), (ADC0_CH3, GPIO3), (ADC0_CH4, GPIO4),
        (ADC0_CH5, GPIO5), (ADC0_CH6, GPIO6), (USB_DM, GPIO12), (USB_DP, GPIO13)));
        _for_each_inner!((all_expanded((ADC0_CH0, ADCn_CHm, 0, 0), GPIO0), ((ADC0_CH1,
        ADCn_CHm, 0, 1), GPIO1), ((ADC0_CH2, ADCn_CHm, 0, 2), GPIO2), ((ADC0_CH3,
        ADCn_CHm, 0, 3), GPIO3), ((ADC0_CH4, ADCn_CHm, 0, 4), GPIO4), ((ADC0_CH5,
        ADCn_CHm, 0, 5), GPIO5), ((ADC0_CH6, ADCn_CHm, 0, 6), GPIO6)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((LP_GPIO0, GPIO0)); _for_each_inner!((LP_UART_DTRN, GPIO0));
        _for_each_inner!((LP_GPIO1, GPIO1)); _for_each_inner!((LP_UART_DSRN, GPIO1));
        _for_each_inner!((LP_GPIO2, GPIO2)); _for_each_inner!((LP_UART_RTSN, GPIO2));
        _for_each_inner!((LP_GPIO3, GPIO3)); _for_each_inner!((LP_UART_CTSN, GPIO3));
        _for_each_inner!((LP_GPIO4, GPIO4)); _for_each_inner!((LP_UART_RXD, GPIO4));
        _for_each_inner!((LP_GPIO5, GPIO5)); _for_each_inner!((LP_UART_TXD, GPIO5));
        _for_each_inner!((LP_GPIO6, GPIO6)); _for_each_inner!((LP_I2C_SDA, GPIO6));
        _for_each_inner!((LP_GPIO7, GPIO7)); _for_each_inner!((LP_I2C_SCL, GPIO7));
        _for_each_inner!(((LP_GPIO0, LP_GPIOn, 0), GPIO0)); _for_each_inner!(((LP_GPIO1,
        LP_GPIOn, 1), GPIO1)); _for_each_inner!(((LP_GPIO2, LP_GPIOn, 2), GPIO2));
        _for_each_inner!(((LP_GPIO3, LP_GPIOn, 3), GPIO3)); _for_each_inner!(((LP_GPIO4,
        LP_GPIOn, 4), GPIO4)); _for_each_inner!(((LP_GPIO5, LP_GPIOn, 5), GPIO5));
        _for_each_inner!(((LP_GPIO6, LP_GPIOn, 6), GPIO6)); _for_each_inner!(((LP_GPIO7,
        LP_GPIOn, 7), GPIO7)); _for_each_inner!((all(LP_GPIO0, GPIO0), (LP_UART_DTRN,
        GPIO0), (LP_GPIO1, GPIO1), (LP_UART_DSRN, GPIO1), (LP_GPIO2, GPIO2),
        (LP_UART_RTSN, GPIO2), (LP_GPIO3, GPIO3), (LP_UART_CTSN, GPIO3), (LP_GPIO4,
        GPIO4), (LP_UART_RXD, GPIO4), (LP_GPIO5, GPIO5), (LP_UART_TXD, GPIO5), (LP_GPIO6,
        GPIO6), (LP_I2C_SDA, GPIO6), (LP_GPIO7, GPIO7), (LP_I2C_SCL, GPIO7)));
        _for_each_inner!((all_expanded((LP_GPIO0, LP_GPIOn, 0), GPIO0), ((LP_GPIO1,
        LP_GPIOn, 1), GPIO1), ((LP_GPIO2, LP_GPIOn, 2), GPIO2), ((LP_GPIO3, LP_GPIOn, 3),
        GPIO3), ((LP_GPIO4, LP_GPIOn, 4), GPIO4), ((LP_GPIO5, LP_GPIOn, 5), GPIO5),
        ((LP_GPIO6, LP_GPIOn, 6), GPIO6), ((LP_GPIO7, LP_GPIOn, 7), GPIO7)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            EXT_ADC_START       = 0,
            U0RXD               = 6,
            U0CTS               = 7,
            U0DSR               = 8,
            U1RXD               = 9,
            U1CTS               = 10,
            U1DSR               = 11,
            I2S_MCLK            = 12,
            I2SO_BCK            = 13,
            I2SO_WS             = 14,
            I2SI_SD             = 15,
            I2SI_BCK            = 16,
            I2SI_WS             = 17,
            USB_JTAG_TDO_BRIDGE = 19,
            CPU_TESTBUS0        = 20,
            CPU_TESTBUS1        = 21,
            CPU_TESTBUS2        = 22,
            CPU_TESTBUS3        = 23,
            CPU_TESTBUS4        = 24,
            CPU_TESTBUS5        = 25,
            CPU_TESTBUS6        = 26,
            CPU_TESTBUS7        = 27,
            CPU_GPIO_0          = 28,
            CPU_GPIO_1          = 29,
            CPU_GPIO_2          = 30,
            CPU_GPIO_3          = 31,
            CPU_GPIO_4          = 32,
            CPU_GPIO_5          = 33,
            CPU_GPIO_6          = 34,
            CPU_GPIO_7          = 35,
            USB_JTAG_TMS        = 37,
            USB_EXTPHY_OEN      = 40,
            USB_EXTPHY_VM       = 41,
            USB_EXTPHY_VPO      = 42,
            I2CEXT0_SCL         = 45,
            I2CEXT0_SDA         = 46,
            PARL_RX_DATA0       = 47,
            PARL_RX_DATA1       = 48,
            PARL_RX_DATA2       = 49,
            PARL_RX_DATA3       = 50,
            PARL_RX_DATA4       = 51,
            PARL_RX_DATA5       = 52,
            PARL_RX_DATA6       = 53,
            PARL_RX_DATA7       = 54,
            PARL_RX_DATA8       = 55,
            PARL_RX_DATA9       = 56,
            PARL_RX_DATA10      = 57,
            PARL_RX_DATA11      = 58,
            PARL_RX_DATA12      = 59,
            PARL_RX_DATA13      = 60,
            PARL_RX_DATA14      = 61,
            PARL_RX_DATA15      = 62,
            FSPICLK             = 63,
            FSPIQ               = 64,
            FSPID               = 65,
            FSPIHD              = 66,
            FSPIWP              = 67,
            FSPICS0             = 68,
            PARL_RX_CLK         = 69,
            PARL_TX_CLK         = 70,
            RMT_SIG_0           = 71,
            RMT_SIG_1           = 72,
            TWAI0_RX            = 73,
            TWAI1_RX            = 77,
            PWM0_SYNC0          = 87,
            PWM0_SYNC1          = 88,
            PWM0_SYNC2          = 89,
            PWM0_F0             = 90,
            PWM0_F1             = 91,
            PWM0_F2             = 92,
            PWM0_CAP0           = 93,
            PWM0_CAP1           = 94,
            PWM0_CAP2           = 95,
            SIG_IN_FUNC97       = 97,
            SIG_IN_FUNC98       = 98,
            SIG_IN_FUNC99       = 99,
            SIG_IN_FUNC100      = 100,
            PCNT0_SIG_CH0       = 101,
            PCNT0_SIG_CH1       = 102,
            PCNT0_CTRL_CH0      = 103,
            PCNT0_CTRL_CH1      = 104,
            PCNT1_SIG_CH0       = 105,
            PCNT1_SIG_CH1       = 106,
            PCNT1_CTRL_CH0      = 107,
            PCNT1_CTRL_CH1      = 108,
            PCNT2_SIG_CH0       = 109,
            PCNT2_SIG_CH1       = 110,
            PCNT2_CTRL_CH0      = 111,
            PCNT2_CTRL_CH1      = 112,
            PCNT3_SIG_CH0       = 113,
            PCNT3_SIG_CH1       = 114,
            PCNT3_CTRL_CH0      = 115,
            PCNT3_CTRL_CH1      = 116,
            SPIQ                = 121,
            SPID                = 122,
            SPIHD               = 123,
            SPIWP               = 124,
            SDIO_CMD,
            SDIO_DATA0,
            SDIO_DATA1,
            SDIO_DATA2,
            SDIO_DATA3,
            MTDI,
            MTCK,
            MTMS,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            LEDC_LS_SIG0          = 0,
            LEDC_LS_SIG1          = 1,
            LEDC_LS_SIG2          = 2,
            LEDC_LS_SIG3          = 3,
            LEDC_LS_SIG4          = 4,
            LEDC_LS_SIG5          = 5,
            U0TXD                 = 6,
            U0RTS                 = 7,
            U0DTR                 = 8,
            U1TXD                 = 9,
            U1RTS                 = 10,
            U1DTR                 = 11,
            I2S_MCLK              = 12,
            I2SO_BCK              = 13,
            I2SO_WS               = 14,
            I2SO_SD               = 15,
            I2SI_BCK              = 16,
            I2SI_WS               = 17,
            I2SO_SD1              = 18,
            USB_JTAG_TDO_BRIDGE   = 19,
            CPU_TESTBUS0          = 20,
            CPU_TESTBUS1          = 21,
            CPU_TESTBUS2          = 22,
            CPU_TESTBUS3          = 23,
            CPU_TESTBUS4          = 24,
            CPU_TESTBUS5          = 25,
            CPU_TESTBUS6          = 26,
            CPU_TESTBUS7          = 27,
            CPU_GPIO_0            = 28,
            CPU_GPIO_1            = 29,
            CPU_GPIO_2            = 30,
            CPU_GPIO_3            = 31,
            CPU_GPIO_4            = 32,
            CPU_GPIO_5            = 33,
            CPU_GPIO_6            = 34,
            CPU_GPIO_7            = 35,
            USB_JTAG_TCK          = 36,
            USB_JTAG_TMS          = 37,
            USB_JTAG_TDI          = 38,
            USB_JTAG_TDO          = 39,
            I2CEXT0_SCL           = 45,
            I2CEXT0_SDA           = 46,
            PARL_TX_DATA0         = 47,
            PARL_TX_DATA1         = 48,
            PARL_TX_DATA2         = 49,
            PARL_TX_DATA3         = 50,
            PARL_TX_DATA4         = 51,
            PARL_TX_DATA5         = 52,
            PARL_TX_DATA6         = 53,
            PARL_TX_DATA7         = 54,
            PARL_TX_DATA8         = 55,
            PARL_TX_DATA9         = 56,
            PARL_TX_DATA10        = 57,
            PARL_TX_DATA11        = 58,
            PARL_TX_DATA12        = 59,
            PARL_TX_DATA13        = 60,
            PARL_TX_DATA14        = 61,
            PARL_TX_DATA15        = 62,
            FSPICLK               = 63,
            FSPIQ                 = 64,
            FSPID                 = 65,
            FSPIHD                = 66,
            FSPIWP                = 67,
            FSPICS0               = 68,
            SDIO_TOHOST_INT       = 69,
            PARL_TX_CLK           = 70,
            RMT_SIG_0             = 71,
            RMT_SIG_1             = 72,
            TWAI0_TX              = 73,
            TWAI0_BUS_OFF_ON      = 74,
            TWAI0_CLKOUT          = 75,
            TWAI0_STANDBY         = 76,
            TWAI1_TX              = 77,
            TWAI1_BUS_OFF_ON      = 78,
            TWAI1_CLKOUT          = 79,
            TWAI1_STANDBY         = 80,
            GPIO_SD0              = 83,
            GPIO_SD1              = 84,
            GPIO_SD2              = 85,
            GPIO_SD3              = 86,
            PWM0_0A               = 87,
            PWM0_0B               = 88,
            PWM0_1A               = 89,
            PWM0_1B               = 90,
            PWM0_2A               = 91,
            PWM0_2B               = 92,
            SIG_IN_FUNC97         = 97,
            SIG_IN_FUNC98         = 98,
            SIG_IN_FUNC99         = 99,
            SIG_IN_FUNC100        = 100,
            FSPICS1               = 101,
            FSPICS2               = 102,
            FSPICS3               = 103,
            FSPICS4               = 104,
            FSPICS5               = 105,
            SPICLK                = 114,
            SPICS0                = 115,
            SPICS1                = 116,
            GPIO_TASK_MATRIX_OUT0 = 117,
            GPIO_TASK_MATRIX_OUT1 = 118,
            GPIO_TASK_MATRIX_OUT2 = 119,
            GPIO_TASK_MATRIX_OUT3 = 120,
            SPIQ                  = 121,
            SPID                  = 122,
            SPIHD                 = 123,
            SPIWP                 = 124,
            CLK_OUT_OUT1          = 125,
            CLK_OUT_OUT2          = 126,
            CLK_OUT_OUT3          = 127,
            GPIO                  = 128,
            SDIO_CLK,
            SDIO_CMD,
            SDIO_DATA0,
            SDIO_DATA1,
            SDIO_DATA2,
            SDIO_DATA3,
            MTDO,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO {
            crate::peripherals::IO_MUX::regs().gpio(gpio_num as usize)
        }
    };
}
