// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32c3"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32c3"
    };
    ("arch") => {
        "riscv"
    };
    ("cores") => {
        1
    };
    ("cores", str) => {
        stringify!(1)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-c3_technical_reference_manual_en.pdf"
    };
    ("soc.cpu_has_csr_pc") => {
        true
    };
    ("soc.cpu_has_prv_mode") => {
        false
    };
    ("soc.rc_fast_clk_default") => {
        17500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(17500000)
    };
    ("soc.rc_slow_clock") => {
        136000
    };
    ("soc.rc_slow_clock", str) => {
        stringify!(136000)
    };
    ("soc.xtal_frequency") => {
        40
    };
    ("soc.xtal_frequency", str) => {
        stringify!(40)
    };
    ("aes.dma") => {
        true
    };
    ("aes.has_split_text_registers") => {
        true
    };
    ("aes.endianness_configurable") => {
        false
    };
    ("assist_debug.has_sp_monitor") => {
        true
    };
    ("assist_debug.has_region_monitor") => {
        true
    };
    ("gpio.has_bank_1") => {
        false
    };
    ("gpio.gpio_function") => {
        1
    };
    ("gpio.gpio_function", str) => {
        stringify!(1)
    };
    ("gpio.constant_0_input") => {
        31
    };
    ("gpio.constant_0_input", str) => {
        stringify!(31)
    };
    ("gpio.constant_1_input") => {
        30
    };
    ("gpio.constant_1_input", str) => {
        stringify!(30)
    };
    ("gpio.remap_iomux_pin_registers") => {
        false
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        100
    };
    ("gpio.input_signal_max", str) => {
        stringify!(100)
    };
    ("gpio.output_signal_max") => {
        128
    };
    ("gpio.output_signal_max", str) => {
        stringify!(128)
    };
    ("i2c_master.has_fsm_timeouts") => {
        true
    };
    ("i2c_master.has_hw_bus_clear") => {
        true
    };
    ("i2c_master.has_bus_timeout_enable") => {
        true
    };
    ("i2c_master.separate_filter_config_registers") => {
        false
    };
    ("i2c_master.can_estimate_nack_reason") => {
        false
    };
    ("i2c_master.has_conf_update") => {
        true
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        false
    };
    ("i2c_master.has_arbitration_en") => {
        true
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        true
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        true
    };
    ("i2c_master.max_bus_timeout") => {
        31
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(31)
    };
    ("i2c_master.ll_intr_mask") => {
        262143
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(262143)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("interrupts.status_registers") => {
        2
    };
    ("interrupts.status_registers", str) => {
        stringify!(2)
    };
    ("rmt.ram_start") => {
        1610703872
    };
    ("rmt.ram_start", str) => {
        stringify!(1610703872)
    };
    ("rmt.channel_ram_size") => {
        48
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(48)
    };
    ("rmt.has_tx_immediate_stop") => {
        true
    };
    ("rmt.has_tx_loop_count") => {
        true
    };
    ("rmt.has_tx_loop_auto_stop") => {
        false
    };
    ("rmt.has_tx_carrier_data_only") => {
        true
    };
    ("rmt.has_tx_sync") => {
        true
    };
    ("rmt.has_rx_wrap") => {
        true
    };
    ("rmt.has_rx_demodulation") => {
        true
    };
    ("rmt.has_dma") => {
        false
    };
    ("rmt.has_per_channel_clock") => {
        false
    };
    ("rng.apb_cycle_wait_num") => {
        16
    };
    ("rng.apb_cycle_wait_num", str) => {
        stringify!(16)
    };
    ("rsa.size_increment") => {
        32
    };
    ("rsa.size_increment", str) => {
        stringify!(32)
    };
    ("rsa.memory_size_bytes") => {
        384
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(384)
    };
    ("sha.dma") => {
        true
    };
    ("spi_master.has_octal") => {
        false
    };
    ("timergroup.timg_has_timer1") => {
        false
    };
    ("timergroup.timg_has_divcnt_rst") => {
        true
    };
    ("timergroup.default_clock_source") => {
        0
    };
    ("timergroup.default_clock_source", str) => {
        stringify!(0)
    };
    ("timergroup.default_wdt_clock_source") => {
        0
    };
    ("timergroup.default_wdt_clock_source", str) => {
        stringify!(0)
    };
    ("uart.ram_size") => {
        128
    };
    ("uart.ram_size", str) => {
        stringify!(128)
    };
    ("uart.peripheral_controls_mem_clk") => {
        false
    };
    ("wifi.has_wifi6") => {
        false
    };
    ("bt.controller") => {
        "btdm"
    };
    ("phy.combo_module") => {
        true
    };
    ("phy.backed_up_digital_register_count") => {
        21
    };
    ("phy.backed_up_digital_register_count", str) => {
        stringify!(21)
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_soc_xtal_options {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((40)); _for_each_inner!((all(40)));
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, ignore
/// ```
macro_rules! define_clock_tree_types {
    () => {
        #[doc = r" Represents the device's clock tree."]
        pub struct ClockTree {}
        impl ClockTree {
            #[doc = r" Locks the clock tree for exclusive access."]
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {});
        #[doc = r" Clock tree configuration."]
        #[doc = r""]
        #[doc = r" The fields of this struct are optional, with the following caveats:"]
        #[doc = r" - If `XTL_CLK` is not specified, the crystal frequency will be"]
        #[doc = r"   automatically detected if possible."]
        #[doc = r" - The CPU and its upstream clock nodes will be set to a default configuration."]
        #[doc = r" - Other unspecified clock sources will not be useable by peripherals."]
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct ClockConfig {}
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {});
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount += 1;
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount -= 1;
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            #[doc = "AES peripheral clock signal"]
            Aes,
            #[doc = "APB_SAR_ADC peripheral clock signal"]
            ApbSarAdc,
            #[doc = "DMA peripheral clock signal"]
            Dma,
            #[doc = "DS peripheral clock signal"]
            Ds,
            #[doc = "HMAC peripheral clock signal"]
            Hmac,
            #[doc = "I2C_EXT0 peripheral clock signal"]
            I2cExt0,
            #[doc = "I2S0 peripheral clock signal"]
            I2s0,
            #[doc = "LEDC peripheral clock signal"]
            Ledc,
            #[doc = "RMT peripheral clock signal"]
            Rmt,
            #[doc = "RSA peripheral clock signal"]
            Rsa,
            #[doc = "SHA peripheral clock signal"]
            Sha,
            #[doc = "SPI2 peripheral clock signal"]
            Spi2,
            #[doc = "SYSTIMER peripheral clock signal"]
            Systimer,
            #[doc = "TIMG0 peripheral clock signal"]
            Timg0,
            #[doc = "TIMG1 peripheral clock signal"]
            Timg1,
            #[doc = "TSENS peripheral clock signal"]
            Tsens,
            #[doc = "TWAI0 peripheral clock signal"]
            Twai0,
            #[doc = "UART0 peripheral clock signal"]
            Uart0,
            #[doc = "UART1 peripheral clock signal"]
            Uart1,
            #[doc = "UART_MEM peripheral clock signal"]
            UartMem,
            #[doc = "UHCI0 peripheral clock signal"]
            Uhci0,
            #[doc = "USB_DEVICE peripheral clock signal"]
            UsbDevice,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] = &[
                Self::Systimer,
                Self::Timg0,
                Self::Uart0,
                Self::UartMem,
                Self::UsbDevice,
            ];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::ApbSarAdc,
                Self::Dma,
                Self::Ds,
                Self::Hmac,
                Self::I2cExt0,
                Self::I2s0,
                Self::Ledc,
                Self::Rmt,
                Self::Rsa,
                Self::Sha,
                Self::Spi2,
                Self::Systimer,
                Self::Timg0,
                Self::Timg1,
                Self::Tsens,
                Self::Twai0,
                Self::Uart0,
                Self::Uart1,
                Self::UartMem,
                Self::Uhci0,
                Self::UsbDevice,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_aes_clk_en().bit(enable));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.apb_saradc_clk_en().bit(enable));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.dma_clk_en().bit(enable));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_ds_clk_en().bit(enable));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_hmac_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2c_ext0_clk_en().bit(enable));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2s0_clk_en().bit(enable));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.ledc_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_rsa_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_sha_clk_en().bit(enable));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi2_clk_en().bit(enable));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.systimer_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.timergroup_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.timergroup1_clk_en().bit(enable));
                }
                Peripheral::Tsens => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.tsens_clk_en().bit(enable));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.twai_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart_clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart1_clk_en().bit(enable));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart_mem_clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uhci0_clk_en().bit(enable));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.usb_device_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_aes_rst().bit(reset));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.apb_saradc_rst().bit(reset));
                }
                Peripheral::Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.dma_rst().bit(reset));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_ds_rst().bit(reset));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_hmac_rst().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2c_ext0_rst().bit(reset));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2s0_rst().bit(reset));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.ledc_rst().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.rmt_rst().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_rsa_rst().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_sha_rst().bit(reset));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi2_rst().bit(reset));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.systimer_rst().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.timergroup_rst().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.timergroup1_rst().bit(reset));
                }
                Peripheral::Tsens => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.tsens_rst().bit(reset));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.twai_rst().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart_rst().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart1_rst().bit(reset));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart_mem_rst().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uhci0_rst().bit(reset));
                }
                Peripheral::UsbDevice => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.usb_device_rst().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x3FC80000..0x3FCE0000
    };
    (size as str, "DRAM") => {
        "393216"
    };
    ("DRAM2_UNINIT") => {
        0x3FCCE400..0x3FCDE710
    };
    (size as str, "DRAM2_UNINIT") => {
        "66320"
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_aes_key_length {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((128)); _for_each_inner!((256)); _for_each_inner!((128, 0, 4));
        _for_each_inner!((256, 2, 6)); _for_each_inner!((bits(128), (256)));
        _for_each_inner!((modes(128, 0, 4), (256, 2, 6)));
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0)); _for_each_inner!((1)); _for_each_inner!((2));
        _for_each_inner!((3)); _for_each_inner!((0, 0)); _for_each_inner!((1, 1));
        _for_each_inner!((2, 0)); _for_each_inner!((3, 1)); _for_each_inner!((all(0),
        (1), (2), (3))); _for_each_inner!((tx(0, 0), (1, 1))); _for_each_inner!((rx(2,
        0), (3, 1)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Apb, 1)); _for_each_inner!((RcFast, 2));
        _for_each_inner!((Xtal, 3)); _for_each_inner!((Apb)); _for_each_inner!((all(Apb,
        1), (RcFast, 2), (Xtal, 3))); _for_each_inner!((default(Apb)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((1568)); _for_each_inner!((1600)); _for_each_inner!((1632));
        _for_each_inner!((1664)); _for_each_inner!((1696)); _for_each_inner!((1728));
        _for_each_inner!((1760)); _for_each_inner!((1792)); _for_each_inner!((1824));
        _for_each_inner!((1856)); _for_each_inner!((1888)); _for_each_inner!((1920));
        _for_each_inner!((1952)); _for_each_inner!((1984)); _for_each_inner!((2016));
        _for_each_inner!((2048)); _for_each_inner!((2080)); _for_each_inner!((2112));
        _for_each_inner!((2144)); _for_each_inner!((2176)); _for_each_inner!((2208));
        _for_each_inner!((2240)); _for_each_inner!((2272)); _for_each_inner!((2304));
        _for_each_inner!((2336)); _for_each_inner!((2368)); _for_each_inner!((2400));
        _for_each_inner!((2432)); _for_each_inner!((2464)); _for_each_inner!((2496));
        _for_each_inner!((2528)); _for_each_inner!((2560)); _for_each_inner!((2592));
        _for_each_inner!((2624)); _for_each_inner!((2656)); _for_each_inner!((2688));
        _for_each_inner!((2720)); _for_each_inner!((2752)); _for_each_inner!((2784));
        _for_each_inner!((2816)); _for_each_inner!((2848)); _for_each_inner!((2880));
        _for_each_inner!((2912)); _for_each_inner!((2944)); _for_each_inner!((2976));
        _for_each_inner!((3008)); _for_each_inner!((3040)); _for_each_inner!((3072));
        _for_each_inner!((all(32), (64), (96), (128), (160), (192), (224), (256), (288),
        (320), (352), (384), (416), (448), (480), (512), (544), (576), (608), (640),
        (672), (704), (736), (768), (800), (832), (864), (896), (928), (960), (992),
        (1024), (1056), (1088), (1120), (1152), (1184), (1216), (1248), (1280), (1312),
        (1344), (1376), (1408), (1440), (1472), (1504), (1536), (1568), (1600), (1632),
        (1664), (1696), (1728), (1760), (1792), (1824), (1856), (1888), (1920), (1952),
        (1984), (2016), (2048), (2080), (2112), (2144), (2176), (2208), (2240), (2272),
        (2304), (2336), (2368), (2400), (2432), (2464), (2496), (2528), (2560), (2592),
        (2624), (2656), (2688), (2720), (2752), (2784), (2816), (2848), (2880), (2912),
        (2944), (2976), (3008), (3040), (3072)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((32)); _for_each_inner!((64)); _for_each_inner!((96));
        _for_each_inner!((128)); _for_each_inner!((160)); _for_each_inner!((192));
        _for_each_inner!((224)); _for_each_inner!((256)); _for_each_inner!((288));
        _for_each_inner!((320)); _for_each_inner!((352)); _for_each_inner!((384));
        _for_each_inner!((416)); _for_each_inner!((448)); _for_each_inner!((480));
        _for_each_inner!((512)); _for_each_inner!((544)); _for_each_inner!((576));
        _for_each_inner!((608)); _for_each_inner!((640)); _for_each_inner!((672));
        _for_each_inner!((704)); _for_each_inner!((736)); _for_each_inner!((768));
        _for_each_inner!((800)); _for_each_inner!((832)); _for_each_inner!((864));
        _for_each_inner!((896)); _for_each_inner!((928)); _for_each_inner!((960));
        _for_each_inner!((992)); _for_each_inner!((1024)); _for_each_inner!((1056));
        _for_each_inner!((1088)); _for_each_inner!((1120)); _for_each_inner!((1152));
        _for_each_inner!((1184)); _for_each_inner!((1216)); _for_each_inner!((1248));
        _for_each_inner!((1280)); _for_each_inner!((1312)); _for_each_inner!((1344));
        _for_each_inner!((1376)); _for_each_inner!((1408)); _for_each_inner!((1440));
        _for_each_inner!((1472)); _for_each_inner!((1504)); _for_each_inner!((1536));
        _for_each_inner!((all(32), (64), (96), (128), (160), (192), (224), (256), (288),
        (320), (352), (384), (416), (448), (480), (512), (544), (576), (608), (640),
        (672), (704), (736), (768), (800), (832), (864), (896), (928), (960), (992),
        (1024), (1056), (1088), (1120), (1152), (1184), (1216), (1248), (1280), (1312),
        (1344), (1376), (1408), (1440), (1472), (1504), (1536)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((Sha1, "SHA-1"(sizes : 64, 20, 8) (insecure_against :
        "collision", "length extension"), 0)); _for_each_inner!((Sha224, "SHA-224"(sizes
        : 64, 28, 8) (insecure_against : "length extension"), 1));
        _for_each_inner!((Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against :
        "length extension"), 2)); _for_each_inner!((algos(Sha1, "SHA-1"(sizes : 64, 20,
        8) (insecure_against : "collision", "length extension"), 0), (Sha224,
        "SHA-224"(sizes : 64, 28, 8) (insecure_against : "length extension"), 1),
        (Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against : "length extension"),
        2)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA));
        _for_each_inner!((all(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident, $rts:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner!((UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner!((all(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (UART1, Uart1,
        U1RXD, U1TXD, U1CTS, U1RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, [$($cs:ident),*] [$($sio:ident),*
/// $($is_qspi:iteral)?])`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((GPIO0 <= virtual())); _for_each_inner!((GPIO1 <= virtual()));
        _for_each_inner!((GPIO2 <= virtual())); _for_each_inner!((GPIO3 <= virtual()));
        _for_each_inner!((GPIO4 <= virtual())); _for_each_inner!((GPIO5 <= virtual()));
        _for_each_inner!((GPIO6 <= virtual())); _for_each_inner!((GPIO7 <= virtual()));
        _for_each_inner!((GPIO8 <= virtual())); _for_each_inner!((GPIO9 <= virtual()));
        _for_each_inner!((GPIO10 <= virtual())); _for_each_inner!((GPIO18 <= virtual()));
        _for_each_inner!((GPIO19 <= virtual())); _for_each_inner!((GPIO20 <= virtual()));
        _for_each_inner!((GPIO21 <= virtual())); _for_each_inner!((AES <= AES(AES : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((APB_CTRL <= APB_CTRL() (unstable)));
        _for_each_inner!((APB_SARADC <= APB_SARADC() (unstable)));
        _for_each_inner!((ASSIST_DEBUG <= ASSIST_DEBUG() (unstable)));
        _for_each_inner!((BB <= BB() (unstable))); _for_each_inner!((DMA <= DMA()
        (unstable))); _for_each_inner!((DS <= DS() (unstable))); _for_each_inner!((EFUSE
        <= EFUSE() (unstable))); _for_each_inner!((EXTMEM <= EXTMEM() (unstable)));
        _for_each_inner!((FE <= FE() (unstable))); _for_each_inner!((FE2 <= FE2()
        (unstable))); _for_each_inner!((GPIO <= GPIO() (unstable)));
        _for_each_inner!((GPIO_SD <= GPIO_SD() (unstable))); _for_each_inner!((HMAC <=
        HMAC() (unstable))); _for_each_inner!((I2C_ANA_MST <= I2C_ANA_MST() (unstable)));
        _for_each_inner!((I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((I2S0 <=
        I2S0(I2S0 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }) (unstable))); _for_each_inner!((INTERRUPT_CORE0 <= INTERRUPT_CORE0()
        (unstable))); _for_each_inner!((IO_MUX <= IO_MUX() (unstable)));
        _for_each_inner!((LEDC <= LEDC() (unstable))); _for_each_inner!((NRX <= NRX()
        (unstable))); _for_each_inner!((RMT <= RMT() (unstable))); _for_each_inner!((RNG
        <= RNG() (unstable))); _for_each_inner!((RSA <= RSA(RSA : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner!((LPWR <= RTC_CNTL() (unstable))); _for_each_inner!((SENSITIVE <=
        SENSITIVE() (unstable))); _for_each_inner!((SHA <= SHA(SHA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable))); _for_each_inner!((SPI0 <= SPI0() (unstable)));
        _for_each_inner!((SPI1 <= SPI1() (unstable))); _for_each_inner!((SPI2 <=
        SPI2(SPI2 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }))); _for_each_inner!((SYSTEM <= SYSTEM() (unstable)));
        _for_each_inner!((SYSTIMER <= SYSTIMER() (unstable))); _for_each_inner!((TIMG0 <=
        TIMG0() (unstable))); _for_each_inner!((TIMG1 <= TIMG1() (unstable)));
        _for_each_inner!((TWAI0 <= TWAI0() (unstable))); _for_each_inner!((UART0 <=
        UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner!((UART1 <= UART1(UART1 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner!((UHCI0 <= UHCI0() (unstable))); _for_each_inner!((USB_DEVICE <=
        USB_DEVICE(USB_DEVICE : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner!((XTS_AES <= XTS_AES()
        (unstable))); _for_each_inner!((DMA_CH0 <= virtual() (unstable)));
        _for_each_inner!((DMA_CH1 <= virtual() (unstable))); _for_each_inner!((DMA_CH2 <=
        virtual() (unstable))); _for_each_inner!((ADC1 <= virtual() (unstable)));
        _for_each_inner!((ADC2 <= virtual() (unstable))); _for_each_inner!((BT <=
        virtual() (unstable))); _for_each_inner!((FLASH <= virtual() (unstable)));
        _for_each_inner!((SW_INTERRUPT <= virtual() (unstable))); _for_each_inner!((TSENS
        <= virtual() (unstable))); _for_each_inner!((WIFI <= virtual() (unstable)));
        _for_each_inner!((all(GPIO0 <= virtual()), (GPIO1 <= virtual()), (GPIO2 <=
        virtual()), (GPIO3 <= virtual()), (GPIO4 <= virtual()), (GPIO5 <= virtual()),
        (GPIO6 <= virtual()), (GPIO7 <= virtual()), (GPIO8 <= virtual()), (GPIO9 <=
        virtual()), (GPIO10 <= virtual()), (GPIO18 <= virtual()), (GPIO19 <= virtual()),
        (GPIO20 <= virtual()), (GPIO21 <= virtual()), (AES <= AES(AES : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (APB_CTRL <= APB_CTRL() (unstable)), (APB_SARADC <= APB_SARADC()
        (unstable)), (ASSIST_DEBUG <= ASSIST_DEBUG() (unstable)), (BB <= BB()
        (unstable)), (DMA <= DMA() (unstable)), (DS <= DS() (unstable)), (EFUSE <=
        EFUSE() (unstable)), (EXTMEM <= EXTMEM() (unstable)), (FE <= FE() (unstable)),
        (FE2 <= FE2() (unstable)), (GPIO <= GPIO() (unstable)), (GPIO_SD <= GPIO_SD()
        (unstable)), (HMAC <= HMAC() (unstable)), (I2C_ANA_MST <= I2C_ANA_MST()
        (unstable)), (I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (I2S0 <= I2S0(I2S0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (INTERRUPT_CORE0 <= INTERRUPT_CORE0() (unstable)), (IO_MUX <=
        IO_MUX() (unstable)), (LEDC <= LEDC() (unstable)), (NRX <= NRX() (unstable)),
        (RMT <= RMT() (unstable)), (RNG <= RNG() (unstable)), (RSA <= RSA(RSA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (LPWR <= RTC_CNTL() (unstable)), (SENSITIVE <= SENSITIVE()
        (unstable)), (SHA <= SHA(SHA : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable)), (SPI0 <= SPI0() (unstable)), (SPI1 <=
        SPI1() (unstable)), (SPI2 <= SPI2(SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (SYSTEM <= SYSTEM()
        (unstable)), (SYSTIMER <= SYSTIMER() (unstable)), (TIMG0 <= TIMG0() (unstable)),
        (TIMG1 <= TIMG1() (unstable)), (TWAI0 <= TWAI0() (unstable)), (UART0 <=
        UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (UHCI0 <= UHCI0() (unstable)),
        (USB_DEVICE <= USB_DEVICE(USB_DEVICE : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (XTS_AES <=
        XTS_AES() (unstable)), (DMA_CH0 <= virtual() (unstable)), (DMA_CH1 <= virtual()
        (unstable)), (DMA_CH2 <= virtual() (unstable)), (ADC1 <= virtual() (unstable)),
        (ADC2 <= virtual() (unstable)), (BT <= virtual() (unstable)), (FLASH <= virtual()
        (unstable)), (SW_INTERRUPT <= virtual() (unstable)), (TSENS <= virtual()
        (unstable)), (WIFI <= virtual() (unstable))));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, GPIO0() () ([Input] [Output]))); _for_each_inner!((1,
        GPIO1() () ([Input] [Output]))); _for_each_inner!((2, GPIO2(_2 => FSPIQ) (_2 =>
        FSPIQ) ([Input] [Output]))); _for_each_inner!((3, GPIO3() () ([Input]
        [Output]))); _for_each_inner!((4, GPIO4(_0 => MTMS _2 => FSPIHD) (_2 => FSPIHD)
        ([Input] [Output]))); _for_each_inner!((5, GPIO5(_0 => MTDI _2 => FSPIWP) (_2 =>
        FSPIWP) ([Input] [Output]))); _for_each_inner!((6, GPIO6(_0 => MTCK _2 =>
        FSPICLK) (_2 => FSPICLK) ([Input] [Output]))); _for_each_inner!((7, GPIO7(_2 =>
        FSPID) (_0 => MTDO _2 => FSPID) ([Input] [Output]))); _for_each_inner!((8,
        GPIO8() () ([Input] [Output]))); _for_each_inner!((9, GPIO9() () ([Input]
        [Output]))); _for_each_inner!((10, GPIO10(_2 => FSPICS0) (_2 => FSPICS0) ([Input]
        [Output]))); _for_each_inner!((18, GPIO18() () ([Input] [Output])));
        _for_each_inner!((19, GPIO19() () ([Input] [Output]))); _for_each_inner!((20,
        GPIO20(_0 => U0RXD) () ([Input] [Output]))); _for_each_inner!((21, GPIO21() (_0
        => U0TXD) ([Input] [Output]))); _for_each_inner!((all(0, GPIO0() () ([Input]
        [Output])), (1, GPIO1() () ([Input] [Output])), (2, GPIO2(_2 => FSPIQ) (_2 =>
        FSPIQ) ([Input] [Output])), (3, GPIO3() () ([Input] [Output])), (4, GPIO4(_0 =>
        MTMS _2 => FSPIHD) (_2 => FSPIHD) ([Input] [Output])), (5, GPIO5(_0 => MTDI _2 =>
        FSPIWP) (_2 => FSPIWP) ([Input] [Output])), (6, GPIO6(_0 => MTCK _2 => FSPICLK)
        (_2 => FSPICLK) ([Input] [Output])), (7, GPIO7(_2 => FSPID) (_0 => MTDO _2 =>
        FSPID) ([Input] [Output])), (8, GPIO8() () ([Input] [Output])), (9, GPIO9() ()
        ([Input] [Output])), (10, GPIO10(_2 => FSPICS0) (_2 => FSPICS0) ([Input]
        [Output])), (18, GPIO18() () ([Input] [Output])), (19, GPIO19() () ([Input]
        [Output])), (20, GPIO20(_0 => U0RXD) () ([Input] [Output])), (21, GPIO21() (_0 =>
        U0TXD) ([Input] [Output]))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((ADC1_CH0, GPIO0)); _for_each_inner!((ADC1_CH1, GPIO1));
        _for_each_inner!((ADC1_CH2, GPIO2)); _for_each_inner!((ADC1_CH3, GPIO3));
        _for_each_inner!((ADC1_CH4, GPIO4)); _for_each_inner!((ADC2_CH0, GPIO5));
        _for_each_inner!((USB_DM, GPIO18)); _for_each_inner!((USB_DP, GPIO19));
        _for_each_inner!(((ADC1_CH0, ADCn_CHm, 1, 0), GPIO0));
        _for_each_inner!(((ADC1_CH1, ADCn_CHm, 1, 1), GPIO1));
        _for_each_inner!(((ADC1_CH2, ADCn_CHm, 1, 2), GPIO2));
        _for_each_inner!(((ADC1_CH3, ADCn_CHm, 1, 3), GPIO3));
        _for_each_inner!(((ADC1_CH4, ADCn_CHm, 1, 4), GPIO4));
        _for_each_inner!(((ADC2_CH0, ADCn_CHm, 2, 0), GPIO5));
        _for_each_inner!((all(ADC1_CH0, GPIO0), (ADC1_CH1, GPIO1), (ADC1_CH2, GPIO2),
        (ADC1_CH3, GPIO3), (ADC1_CH4, GPIO4), (ADC2_CH0, GPIO5), (USB_DM, GPIO18),
        (USB_DP, GPIO19))); _for_each_inner!((all_expanded((ADC1_CH0, ADCn_CHm, 1, 0),
        GPIO0), ((ADC1_CH1, ADCn_CHm, 1, 1), GPIO1), ((ADC1_CH2, ADCn_CHm, 1, 2), GPIO2),
        ((ADC1_CH3, ADCn_CHm, 1, 3), GPIO3), ((ADC1_CH4, ADCn_CHm, 1, 4), GPIO4),
        ((ADC2_CH0, ADCn_CHm, 2, 0), GPIO5)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((RTC_GPIO0, GPIO0)); _for_each_inner!((RTC_GPIO1, GPIO1));
        _for_each_inner!((RTC_GPIO2, GPIO2)); _for_each_inner!((RTC_GPIO3, GPIO3));
        _for_each_inner!((RTC_GPIO4, GPIO4)); _for_each_inner!((RTC_GPIO5, GPIO5));
        _for_each_inner!(((RTC_GPIO0, RTC_GPIOn, 0), GPIO0));
        _for_each_inner!(((RTC_GPIO1, RTC_GPIOn, 1), GPIO1));
        _for_each_inner!(((RTC_GPIO2, RTC_GPIOn, 2), GPIO2));
        _for_each_inner!(((RTC_GPIO3, RTC_GPIOn, 3), GPIO3));
        _for_each_inner!(((RTC_GPIO4, RTC_GPIOn, 4), GPIO4));
        _for_each_inner!(((RTC_GPIO5, RTC_GPIOn, 5), GPIO5));
        _for_each_inner!((all(RTC_GPIO0, GPIO0), (RTC_GPIO1, GPIO1), (RTC_GPIO2, GPIO2),
        (RTC_GPIO3, GPIO3), (RTC_GPIO4, GPIO4), (RTC_GPIO5, GPIO5)));
        _for_each_inner!((all_expanded((RTC_GPIO0, RTC_GPIOn, 0), GPIO0), ((RTC_GPIO1,
        RTC_GPIOn, 1), GPIO1), ((RTC_GPIO2, RTC_GPIOn, 2), GPIO2), ((RTC_GPIO3,
        RTC_GPIOn, 3), GPIO3), ((RTC_GPIO4, RTC_GPIOn, 4), GPIO4), ((RTC_GPIO5,
        RTC_GPIOn, 5), GPIO5)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            SPIQ             = 0,
            SPID             = 1,
            SPIHD            = 2,
            SPIWP            = 3,
            U0RXD            = 6,
            U0CTS            = 7,
            U0DSR            = 8,
            U1RXD            = 9,
            U1CTS            = 10,
            U1DSR            = 11,
            I2S_MCLK         = 12,
            I2SO_BCK         = 13,
            I2SO_WS          = 14,
            I2SI_SD          = 15,
            I2SI_BCK         = 16,
            I2SI_WS          = 17,
            GPIO_BT_PRIORITY = 18,
            GPIO_BT_ACTIVE   = 19,
            CPU_GPIO_0       = 28,
            CPU_GPIO_1       = 29,
            CPU_GPIO_2       = 30,
            CPU_GPIO_3       = 31,
            CPU_GPIO_4       = 32,
            CPU_GPIO_5       = 33,
            CPU_GPIO_6       = 34,
            CPU_GPIO_7       = 35,
            EXT_ADC_START    = 45,
            RMT_SIG_0        = 51,
            RMT_SIG_1        = 52,
            I2CEXT0_SCL      = 53,
            I2CEXT0_SDA      = 54,
            FSPICLK          = 63,
            FSPIQ            = 64,
            FSPID            = 65,
            FSPIHD           = 66,
            FSPIWP           = 67,
            FSPICS0          = 68,
            TWAI_RX          = 74,
            SIG_FUNC_97      = 97,
            SIG_FUNC_98      = 98,
            SIG_FUNC_99      = 99,
            SIG_FUNC_100     = 100,
            MTCK,
            MTMS,
            MTDI,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            SPIQ             = 0,
            SPID             = 1,
            SPIHD            = 2,
            SPIWP            = 3,
            SPICLK           = 4,
            SPICS0           = 5,
            U0TXD            = 6,
            U0RTS            = 7,
            U0DTR            = 8,
            U1TXD            = 9,
            U1RTS            = 10,
            U1DTR            = 11,
            I2S_MCLK         = 12,
            I2SO_BCK         = 13,
            I2SO_WS          = 14,
            I2SO_SD          = 15,
            I2SI_BCK         = 16,
            I2SI_WS          = 17,
            GPIO_WLAN_PRIO   = 18,
            GPIO_WLAN_ACTIVE = 19,
            CPU_GPIO_0       = 28,
            CPU_GPIO_1       = 29,
            CPU_GPIO_2       = 30,
            CPU_GPIO_3       = 31,
            CPU_GPIO_4       = 32,
            CPU_GPIO_5       = 33,
            CPU_GPIO_6       = 34,
            CPU_GPIO_7       = 35,
            USB_JTAG_TCK     = 36,
            USB_JTAG_TMS     = 37,
            USB_JTAG_TDI     = 38,
            USB_JTAG_TDO     = 39,
            LEDC_LS_SIG0     = 45,
            LEDC_LS_SIG1     = 46,
            LEDC_LS_SIG2     = 47,
            LEDC_LS_SIG3     = 48,
            LEDC_LS_SIG4     = 49,
            LEDC_LS_SIG5     = 50,
            RMT_SIG_0        = 51,
            RMT_SIG_1        = 52,
            I2CEXT0_SCL      = 53,
            I2CEXT0_SDA      = 54,
            GPIO_SD0         = 55,
            GPIO_SD1         = 56,
            GPIO_SD2         = 57,
            GPIO_SD3         = 58,
            I2SO_SD1         = 59,
            FSPICLK          = 63,
            FSPIQ            = 64,
            FSPID            = 65,
            FSPIHD           = 66,
            FSPIWP           = 67,
            FSPICS0          = 68,
            FSPICS1          = 69,
            FSPICS3          = 70,
            FSPICS2          = 71,
            FSPICS4          = 72,
            FSPICS5          = 73,
            TWAI_TX          = 74,
            TWAI_BUS_OFF_ON  = 75,
            TWAI_CLKOUT      = 76,
            ANT_SEL0         = 89,
            ANT_SEL1         = 90,
            ANT_SEL2         = 91,
            ANT_SEL3         = 92,
            ANT_SEL4         = 93,
            ANT_SEL5         = 94,
            ANT_SEL6         = 95,
            ANT_SEL7         = 96,
            SIG_FUNC_97      = 97,
            SIG_FUNC_98      = 98,
            SIG_FUNC_99      = 99,
            SIG_FUNC_100     = 100,
            CLK_OUT1         = 123,
            CLK_OUT2         = 124,
            CLK_OUT3         = 125,
            SPICS1           = 126,
            USB_JTAG_TRST    = 127,
            GPIO             = 128,
            MTDO,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO {
            crate::peripherals::IO_MUX::regs().gpio(gpio_num as usize)
        }
    };
}
