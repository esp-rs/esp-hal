// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32s2"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32s2"
    };
    ("arch") => {
        "xtensa"
    };
    ("cores") => {
        1
    };
    ("cores", str) => {
        stringify!(1)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-s2_technical_reference_manual_en.pdf"
    };
    ("aes.dma") => {
        true
    };
    ("aes.has_split_text_registers") => {
        true
    };
    ("aes.endianness_configurable") => {
        true
    };
    ("dedicated_gpio.needs_initialization") => {
        true
    };
    ("dedicated_gpio.channel_count") => {
        8
    };
    ("dedicated_gpio.channel_count", str) => {
        stringify!(8)
    };
    ("dma.kind") => {
        "pdma"
    };
    ("dma.supports_mem2mem") => {
        true
    };
    ("dma.separate_in_out_interrupts") => {
        false
    };
    ("gpio.has_bank_1") => {
        true
    };
    ("gpio.gpio_function") => {
        1
    };
    ("gpio.gpio_function", str) => {
        stringify!(1)
    };
    ("gpio.constant_0_input") => {
        60
    };
    ("gpio.constant_0_input", str) => {
        stringify!(60)
    };
    ("gpio.constant_1_input") => {
        56
    };
    ("gpio.constant_1_input", str) => {
        stringify!(56)
    };
    ("gpio.remap_iomux_pin_registers") => {
        false
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        242
    };
    ("gpio.input_signal_max", str) => {
        stringify!(242)
    };
    ("gpio.output_signal_max") => {
        256
    };
    ("gpio.output_signal_max", str) => {
        stringify!(256)
    };
    ("i2c_master.has_fsm_timeouts") => {
        false
    };
    ("i2c_master.has_hw_bus_clear") => {
        false
    };
    ("i2c_master.has_bus_timeout_enable") => {
        true
    };
    ("i2c_master.separate_filter_config_registers") => {
        true
    };
    ("i2c_master.can_estimate_nack_reason") => {
        false
    };
    ("i2c_master.has_conf_update") => {
        false
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        false
    };
    ("i2c_master.has_arbitration_en") => {
        true
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        false
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        false
    };
    ("i2c_master.i2c0_data_register_ahb_address") => {
        1610690588
    };
    ("i2c_master.i2c0_data_register_ahb_address", str) => {
        stringify!(1610690588)
    };
    ("i2c_master.max_bus_timeout") => {
        16777215
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(16777215)
    };
    ("i2c_master.ll_intr_mask") => {
        131071
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(131071)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("interrupts.status_registers") => {
        3
    };
    ("interrupts.status_registers", str) => {
        stringify!(3)
    };
    ("phy.combo_module") => {
        false
    };
    ("rmt.ram_start") => {
        1061250048
    };
    ("rmt.ram_start", str) => {
        stringify!(1061250048)
    };
    ("rmt.channel_ram_size") => {
        64
    };
    ("rmt.channel_ram_size", str) => {
        stringify!(64)
    };
    ("rmt.has_tx_immediate_stop") => {
        true
    };
    ("rmt.has_tx_loop_count") => {
        true
    };
    ("rmt.has_tx_loop_auto_stop") => {
        false
    };
    ("rmt.has_tx_carrier_data_only") => {
        true
    };
    ("rmt.has_tx_sync") => {
        true
    };
    ("rmt.has_rx_wrap") => {
        false
    };
    ("rmt.has_rx_demodulation") => {
        true
    };
    ("rmt.has_dma") => {
        false
    };
    ("rmt.has_per_channel_clock") => {
        true
    };
    ("rng.apb_cycle_wait_num") => {
        16
    };
    ("rng.apb_cycle_wait_num", str) => {
        stringify!(16)
    };
    ("rng.trng_supported") => {
        true
    };
    ("rsa.size_increment") => {
        32
    };
    ("rsa.size_increment", str) => {
        stringify!(32)
    };
    ("rsa.memory_size_bytes") => {
        512
    };
    ("rsa.memory_size_bytes", str) => {
        stringify!(512)
    };
    ("sha.dma") => {
        true
    };
    ("sleep.light_sleep") => {
        true
    };
    ("sleep.deep_sleep") => {
        true
    };
    ("soc.cpu_has_branch_predictor") => {
        false
    };
    ("soc.cpu_has_csr_pc") => {
        false
    };
    ("soc.multi_core_enabled") => {
        false
    };
    ("soc.rc_fast_clk_default") => {
        8500000
    };
    ("soc.rc_fast_clk_default", str) => {
        stringify!(8500000)
    };
    ("spi_master.supports_dma") => {
        true
    };
    ("spi_master.has_octal") => {
        true
    };
    ("spi_master.has_app_interrupts") => {
        false
    };
    ("spi_master.has_dma_segmented_transfer") => {
        true
    };
    ("spi_master.has_clk_pre_div") => {
        false
    };
    ("spi_slave.supports_dma") => {
        true
    };
    ("timergroup.timg_has_timer1") => {
        true
    };
    ("timergroup.timg_has_divcnt_rst") => {
        false
    };
    ("uart.ram_size") => {
        128
    };
    ("uart.ram_size", str) => {
        stringify!(128)
    };
    ("uart.peripheral_controls_mem_clk") => {
        false
    };
    ("uhci.combined_uart_selector_field") => {
        false
    };
    ("wifi.has_wifi6") => {
        false
    };
    ("wifi.mac_version") => {
        1
    };
    ("wifi.mac_version", str) => {
        stringify!(1)
    };
    ("wifi.has_5g") => {
        false
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_aes_key_length {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_aes_key_length { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_aes_key_length!((128));
        _for_each_inner_aes_key_length!((192)); _for_each_inner_aes_key_length!((256));
        _for_each_inner_aes_key_length!((128, 0, 4));
        _for_each_inner_aes_key_length!((192, 1, 5));
        _for_each_inner_aes_key_length!((256, 2, 6));
        _for_each_inner_aes_key_length!((bits(128), (192), (256)));
        _for_each_inner_aes_key_length!((modes(128, 0, 4), (192, 1, 5), (256, 2, 6)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_dedicated_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_dedicated_gpio { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_dedicated_gpio!((0));
        _for_each_inner_dedicated_gpio!((1)); _for_each_inner_dedicated_gpio!((2));
        _for_each_inner_dedicated_gpio!((3)); _for_each_inner_dedicated_gpio!((4));
        _for_each_inner_dedicated_gpio!((5)); _for_each_inner_dedicated_gpio!((6));
        _for_each_inner_dedicated_gpio!((7)); _for_each_inner_dedicated_gpio!((0, 0,
        PRO_ALONEGPIO0)); _for_each_inner_dedicated_gpio!((0, 1, PRO_ALONEGPIO1));
        _for_each_inner_dedicated_gpio!((0, 2, PRO_ALONEGPIO2));
        _for_each_inner_dedicated_gpio!((0, 3, PRO_ALONEGPIO3));
        _for_each_inner_dedicated_gpio!((0, 4, PRO_ALONEGPIO4));
        _for_each_inner_dedicated_gpio!((0, 5, PRO_ALONEGPIO5));
        _for_each_inner_dedicated_gpio!((0, 6, PRO_ALONEGPIO6));
        _for_each_inner_dedicated_gpio!((0, 7, PRO_ALONEGPIO7));
        _for_each_inner_dedicated_gpio!((channels(0), (1), (2), (3), (4), (5), (6),
        (7))); _for_each_inner_dedicated_gpio!((signals(0, 0, PRO_ALONEGPIO0), (0, 1,
        PRO_ALONEGPIO1), (0, 2, PRO_ALONEGPIO2), (0, 3, PRO_ALONEGPIO3), (0, 4,
        PRO_ALONEGPIO4), (0, 5, PRO_ALONEGPIO5), (0, 6, PRO_ALONEGPIO6), (0, 7,
        PRO_ALONEGPIO7)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sw_interrupt {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_sw_interrupt { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_sw_interrupt!((0, FROM_CPU_INTR0,
        software_interrupt0)); _for_each_inner_sw_interrupt!((1, FROM_CPU_INTR1,
        software_interrupt1)); _for_each_inner_sw_interrupt!((2, FROM_CPU_INTR2,
        software_interrupt2)); _for_each_inner_sw_interrupt!((3, FROM_CPU_INTR3,
        software_interrupt3)); _for_each_inner_sw_interrupt!((all(0, FROM_CPU_INTR0,
        software_interrupt0), (1, FROM_CPU_INTR1, software_interrupt1), (2,
        FROM_CPU_INTR2, software_interrupt2), (3, FROM_CPU_INTR3, software_interrupt3)));
    };
}
#[macro_export]
macro_rules! sw_interrupt_delay {
    () => {
        unsafe {}
    };
}
/// This macro can be used to generate code for each channel of the RMT peripheral.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has three options for its "Individual matcher" case:
///
/// - `all`: `($num:literal)`
/// - `tx`: `($num:literal, $idx:literal)`
/// - `rx`: `($num:literal, $idx:literal)`
///
/// Macro fragments:
///
/// - `$num`: number of the channel, e.g. `0`
/// - `$idx`: index of the channel among channels of the same capability, e.g. `0`
///
/// Example data:
///
/// - `all`: `(0)`
/// - `tx`: `(1, 1)`
/// - `rx`: `(2, 0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_channel {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rmt_channel { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_rmt_channel!((0)); _for_each_inner_rmt_channel!((1));
        _for_each_inner_rmt_channel!((2)); _for_each_inner_rmt_channel!((3));
        _for_each_inner_rmt_channel!((0, 0)); _for_each_inner_rmt_channel!((1, 1));
        _for_each_inner_rmt_channel!((2, 2)); _for_each_inner_rmt_channel!((3, 3));
        _for_each_inner_rmt_channel!((0, 0)); _for_each_inner_rmt_channel!((1, 1));
        _for_each_inner_rmt_channel!((2, 2)); _for_each_inner_rmt_channel!((3, 3));
        _for_each_inner_rmt_channel!((all(0), (1), (2), (3)));
        _for_each_inner_rmt_channel!((tx(0, 0), (1, 1), (2, 2), (3, 3)));
        _for_each_inner_rmt_channel!((rx(0, 0), (1, 1), (2, 2), (3, 3)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rmt_clock_source {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rmt_clock_source { $(($pattern) => $code;)* ($other
        : tt) => {} } _for_each_inner_rmt_clock_source!((RefTick, 0));
        _for_each_inner_rmt_clock_source!((Apb, 1));
        _for_each_inner_rmt_clock_source!((Apb));
        _for_each_inner_rmt_clock_source!((all(RefTick, 0), (Apb, 1)));
        _for_each_inner_rmt_clock_source!((default(Apb)));
        _for_each_inner_rmt_clock_source!((is_boolean));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_exponentiation {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rsa_exponentiation { $(($pattern) => $code;)*
        ($other : tt) => {} } _for_each_inner_rsa_exponentiation!((32));
        _for_each_inner_rsa_exponentiation!((64));
        _for_each_inner_rsa_exponentiation!((96));
        _for_each_inner_rsa_exponentiation!((128));
        _for_each_inner_rsa_exponentiation!((160));
        _for_each_inner_rsa_exponentiation!((192));
        _for_each_inner_rsa_exponentiation!((224));
        _for_each_inner_rsa_exponentiation!((256));
        _for_each_inner_rsa_exponentiation!((288));
        _for_each_inner_rsa_exponentiation!((320));
        _for_each_inner_rsa_exponentiation!((352));
        _for_each_inner_rsa_exponentiation!((384));
        _for_each_inner_rsa_exponentiation!((416));
        _for_each_inner_rsa_exponentiation!((448));
        _for_each_inner_rsa_exponentiation!((480));
        _for_each_inner_rsa_exponentiation!((512));
        _for_each_inner_rsa_exponentiation!((544));
        _for_each_inner_rsa_exponentiation!((576));
        _for_each_inner_rsa_exponentiation!((608));
        _for_each_inner_rsa_exponentiation!((640));
        _for_each_inner_rsa_exponentiation!((672));
        _for_each_inner_rsa_exponentiation!((704));
        _for_each_inner_rsa_exponentiation!((736));
        _for_each_inner_rsa_exponentiation!((768));
        _for_each_inner_rsa_exponentiation!((800));
        _for_each_inner_rsa_exponentiation!((832));
        _for_each_inner_rsa_exponentiation!((864));
        _for_each_inner_rsa_exponentiation!((896));
        _for_each_inner_rsa_exponentiation!((928));
        _for_each_inner_rsa_exponentiation!((960));
        _for_each_inner_rsa_exponentiation!((992));
        _for_each_inner_rsa_exponentiation!((1024));
        _for_each_inner_rsa_exponentiation!((1056));
        _for_each_inner_rsa_exponentiation!((1088));
        _for_each_inner_rsa_exponentiation!((1120));
        _for_each_inner_rsa_exponentiation!((1152));
        _for_each_inner_rsa_exponentiation!((1184));
        _for_each_inner_rsa_exponentiation!((1216));
        _for_each_inner_rsa_exponentiation!((1248));
        _for_each_inner_rsa_exponentiation!((1280));
        _for_each_inner_rsa_exponentiation!((1312));
        _for_each_inner_rsa_exponentiation!((1344));
        _for_each_inner_rsa_exponentiation!((1376));
        _for_each_inner_rsa_exponentiation!((1408));
        _for_each_inner_rsa_exponentiation!((1440));
        _for_each_inner_rsa_exponentiation!((1472));
        _for_each_inner_rsa_exponentiation!((1504));
        _for_each_inner_rsa_exponentiation!((1536));
        _for_each_inner_rsa_exponentiation!((1568));
        _for_each_inner_rsa_exponentiation!((1600));
        _for_each_inner_rsa_exponentiation!((1632));
        _for_each_inner_rsa_exponentiation!((1664));
        _for_each_inner_rsa_exponentiation!((1696));
        _for_each_inner_rsa_exponentiation!((1728));
        _for_each_inner_rsa_exponentiation!((1760));
        _for_each_inner_rsa_exponentiation!((1792));
        _for_each_inner_rsa_exponentiation!((1824));
        _for_each_inner_rsa_exponentiation!((1856));
        _for_each_inner_rsa_exponentiation!((1888));
        _for_each_inner_rsa_exponentiation!((1920));
        _for_each_inner_rsa_exponentiation!((1952));
        _for_each_inner_rsa_exponentiation!((1984));
        _for_each_inner_rsa_exponentiation!((2016));
        _for_each_inner_rsa_exponentiation!((2048));
        _for_each_inner_rsa_exponentiation!((2080));
        _for_each_inner_rsa_exponentiation!((2112));
        _for_each_inner_rsa_exponentiation!((2144));
        _for_each_inner_rsa_exponentiation!((2176));
        _for_each_inner_rsa_exponentiation!((2208));
        _for_each_inner_rsa_exponentiation!((2240));
        _for_each_inner_rsa_exponentiation!((2272));
        _for_each_inner_rsa_exponentiation!((2304));
        _for_each_inner_rsa_exponentiation!((2336));
        _for_each_inner_rsa_exponentiation!((2368));
        _for_each_inner_rsa_exponentiation!((2400));
        _for_each_inner_rsa_exponentiation!((2432));
        _for_each_inner_rsa_exponentiation!((2464));
        _for_each_inner_rsa_exponentiation!((2496));
        _for_each_inner_rsa_exponentiation!((2528));
        _for_each_inner_rsa_exponentiation!((2560));
        _for_each_inner_rsa_exponentiation!((2592));
        _for_each_inner_rsa_exponentiation!((2624));
        _for_each_inner_rsa_exponentiation!((2656));
        _for_each_inner_rsa_exponentiation!((2688));
        _for_each_inner_rsa_exponentiation!((2720));
        _for_each_inner_rsa_exponentiation!((2752));
        _for_each_inner_rsa_exponentiation!((2784));
        _for_each_inner_rsa_exponentiation!((2816));
        _for_each_inner_rsa_exponentiation!((2848));
        _for_each_inner_rsa_exponentiation!((2880));
        _for_each_inner_rsa_exponentiation!((2912));
        _for_each_inner_rsa_exponentiation!((2944));
        _for_each_inner_rsa_exponentiation!((2976));
        _for_each_inner_rsa_exponentiation!((3008));
        _for_each_inner_rsa_exponentiation!((3040));
        _for_each_inner_rsa_exponentiation!((3072));
        _for_each_inner_rsa_exponentiation!((3104));
        _for_each_inner_rsa_exponentiation!((3136));
        _for_each_inner_rsa_exponentiation!((3168));
        _for_each_inner_rsa_exponentiation!((3200));
        _for_each_inner_rsa_exponentiation!((3232));
        _for_each_inner_rsa_exponentiation!((3264));
        _for_each_inner_rsa_exponentiation!((3296));
        _for_each_inner_rsa_exponentiation!((3328));
        _for_each_inner_rsa_exponentiation!((3360));
        _for_each_inner_rsa_exponentiation!((3392));
        _for_each_inner_rsa_exponentiation!((3424));
        _for_each_inner_rsa_exponentiation!((3456));
        _for_each_inner_rsa_exponentiation!((3488));
        _for_each_inner_rsa_exponentiation!((3520));
        _for_each_inner_rsa_exponentiation!((3552));
        _for_each_inner_rsa_exponentiation!((3584));
        _for_each_inner_rsa_exponentiation!((3616));
        _for_each_inner_rsa_exponentiation!((3648));
        _for_each_inner_rsa_exponentiation!((3680));
        _for_each_inner_rsa_exponentiation!((3712));
        _for_each_inner_rsa_exponentiation!((3744));
        _for_each_inner_rsa_exponentiation!((3776));
        _for_each_inner_rsa_exponentiation!((3808));
        _for_each_inner_rsa_exponentiation!((3840));
        _for_each_inner_rsa_exponentiation!((3872));
        _for_each_inner_rsa_exponentiation!((3904));
        _for_each_inner_rsa_exponentiation!((3936));
        _for_each_inner_rsa_exponentiation!((3968));
        _for_each_inner_rsa_exponentiation!((4000));
        _for_each_inner_rsa_exponentiation!((4032));
        _for_each_inner_rsa_exponentiation!((4064));
        _for_each_inner_rsa_exponentiation!((4096));
        _for_each_inner_rsa_exponentiation!((all(32), (64), (96), (128), (160), (192),
        (224), (256), (288), (320), (352), (384), (416), (448), (480), (512), (544),
        (576), (608), (640), (672), (704), (736), (768), (800), (832), (864), (896),
        (928), (960), (992), (1024), (1056), (1088), (1120), (1152), (1184), (1216),
        (1248), (1280), (1312), (1344), (1376), (1408), (1440), (1472), (1504), (1536),
        (1568), (1600), (1632), (1664), (1696), (1728), (1760), (1792), (1824), (1856),
        (1888), (1920), (1952), (1984), (2016), (2048), (2080), (2112), (2144), (2176),
        (2208), (2240), (2272), (2304), (2336), (2368), (2400), (2432), (2464), (2496),
        (2528), (2560), (2592), (2624), (2656), (2688), (2720), (2752), (2784), (2816),
        (2848), (2880), (2912), (2944), (2976), (3008), (3040), (3072), (3104), (3136),
        (3168), (3200), (3232), (3264), (3296), (3328), (3360), (3392), (3424), (3456),
        (3488), (3520), (3552), (3584), (3616), (3648), (3680), (3712), (3744), (3776),
        (3808), (3840), (3872), (3904), (3936), (3968), (4000), (4032), (4064), (4096)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_rsa_multiplication {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_rsa_multiplication { $(($pattern) => $code;)*
        ($other : tt) => {} } _for_each_inner_rsa_multiplication!((32));
        _for_each_inner_rsa_multiplication!((64));
        _for_each_inner_rsa_multiplication!((96));
        _for_each_inner_rsa_multiplication!((128));
        _for_each_inner_rsa_multiplication!((160));
        _for_each_inner_rsa_multiplication!((192));
        _for_each_inner_rsa_multiplication!((224));
        _for_each_inner_rsa_multiplication!((256));
        _for_each_inner_rsa_multiplication!((288));
        _for_each_inner_rsa_multiplication!((320));
        _for_each_inner_rsa_multiplication!((352));
        _for_each_inner_rsa_multiplication!((384));
        _for_each_inner_rsa_multiplication!((416));
        _for_each_inner_rsa_multiplication!((448));
        _for_each_inner_rsa_multiplication!((480));
        _for_each_inner_rsa_multiplication!((512));
        _for_each_inner_rsa_multiplication!((544));
        _for_each_inner_rsa_multiplication!((576));
        _for_each_inner_rsa_multiplication!((608));
        _for_each_inner_rsa_multiplication!((640));
        _for_each_inner_rsa_multiplication!((672));
        _for_each_inner_rsa_multiplication!((704));
        _for_each_inner_rsa_multiplication!((736));
        _for_each_inner_rsa_multiplication!((768));
        _for_each_inner_rsa_multiplication!((800));
        _for_each_inner_rsa_multiplication!((832));
        _for_each_inner_rsa_multiplication!((864));
        _for_each_inner_rsa_multiplication!((896));
        _for_each_inner_rsa_multiplication!((928));
        _for_each_inner_rsa_multiplication!((960));
        _for_each_inner_rsa_multiplication!((992));
        _for_each_inner_rsa_multiplication!((1024));
        _for_each_inner_rsa_multiplication!((1056));
        _for_each_inner_rsa_multiplication!((1088));
        _for_each_inner_rsa_multiplication!((1120));
        _for_each_inner_rsa_multiplication!((1152));
        _for_each_inner_rsa_multiplication!((1184));
        _for_each_inner_rsa_multiplication!((1216));
        _for_each_inner_rsa_multiplication!((1248));
        _for_each_inner_rsa_multiplication!((1280));
        _for_each_inner_rsa_multiplication!((1312));
        _for_each_inner_rsa_multiplication!((1344));
        _for_each_inner_rsa_multiplication!((1376));
        _for_each_inner_rsa_multiplication!((1408));
        _for_each_inner_rsa_multiplication!((1440));
        _for_each_inner_rsa_multiplication!((1472));
        _for_each_inner_rsa_multiplication!((1504));
        _for_each_inner_rsa_multiplication!((1536));
        _for_each_inner_rsa_multiplication!((1568));
        _for_each_inner_rsa_multiplication!((1600));
        _for_each_inner_rsa_multiplication!((1632));
        _for_each_inner_rsa_multiplication!((1664));
        _for_each_inner_rsa_multiplication!((1696));
        _for_each_inner_rsa_multiplication!((1728));
        _for_each_inner_rsa_multiplication!((1760));
        _for_each_inner_rsa_multiplication!((1792));
        _for_each_inner_rsa_multiplication!((1824));
        _for_each_inner_rsa_multiplication!((1856));
        _for_each_inner_rsa_multiplication!((1888));
        _for_each_inner_rsa_multiplication!((1920));
        _for_each_inner_rsa_multiplication!((1952));
        _for_each_inner_rsa_multiplication!((1984));
        _for_each_inner_rsa_multiplication!((2016));
        _for_each_inner_rsa_multiplication!((2048));
        _for_each_inner_rsa_multiplication!((all(32), (64), (96), (128), (160), (192),
        (224), (256), (288), (320), (352), (384), (416), (448), (480), (512), (544),
        (576), (608), (640), (672), (704), (736), (768), (800), (832), (864), (896),
        (928), (960), (992), (1024), (1056), (1088), (1120), (1152), (1184), (1216),
        (1248), (1280), (1312), (1344), (1376), (1408), (1440), (1472), (1504), (1536),
        (1568), (1600), (1632), (1664), (1696), (1728), (1760), (1792), (1824), (1856),
        (1888), (1920), (1952), (1984), (2016), (2048)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_sha_algorithm {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_sha_algorithm { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_sha_algorithm!((Sha1, "SHA-1"(sizes : 64, 20, 8)
        (insecure_against : "collision", "length extension"), 0));
        _for_each_inner_sha_algorithm!((Sha224, "SHA-224"(sizes : 64, 28, 8)
        (insecure_against : "length extension"), 1));
        _for_each_inner_sha_algorithm!((Sha256, "SHA-256"(sizes : 64, 32, 8)
        (insecure_against : "length extension"), 2));
        _for_each_inner_sha_algorithm!((Sha384, "SHA-384"(sizes : 128, 48, 16)
        (insecure_against :), 3)); _for_each_inner_sha_algorithm!((Sha512,
        "SHA-512"(sizes : 128, 64, 16) (insecure_against : "length extension"), 4));
        _for_each_inner_sha_algorithm!((Sha512_224, "SHA-512/224"(sizes : 128, 28, 16)
        (insecure_against :), 5)); _for_each_inner_sha_algorithm!((Sha512_256,
        "SHA-512/256"(sizes : 128, 32, 16) (insecure_against :), 6));
        _for_each_inner_sha_algorithm!((algos(Sha1, "SHA-1"(sizes : 64, 20, 8)
        (insecure_against : "collision", "length extension"), 0), (Sha224,
        "SHA-224"(sizes : 64, 28, 8) (insecure_against : "length extension"), 1),
        (Sha256, "SHA-256"(sizes : 64, 32, 8) (insecure_against : "length extension"),
        2), (Sha384, "SHA-384"(sizes : 128, 48, 16) (insecure_against :), 3), (Sha512,
        "SHA-512"(sizes : 128, 64, 16) (insecure_against : "length extension"), 4),
        (Sha512_224, "SHA-512/224"(sizes : 128, 28, 16) (insecure_against :), 5),
        (Sha512_256, "SHA-512/256"(sizes : 128, 32, 16) (insecure_against :), 6)));
    };
}
#[macro_export]
/// ESP-HAL must provide implementation for the following functions:
/// ```rust, no_run
/// // XTAL_CLK
///
/// fn configure_xtal_clk_impl(_clocks: &mut ClockTree, _config: XtalClkConfig) {
///     todo!()
/// }
///
/// // PLL_CLK
///
/// fn enable_pll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_pll_clk_impl(_clocks: &mut ClockTree, _config: PllClkConfig) {
///     todo!()
/// }
///
/// // APLL_CLK
///
/// fn enable_apll_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apll_clk_impl(_clocks: &mut ClockTree, _config: ApllClkConfig) {
///     todo!()
/// }
///
/// // RC_FAST_CLK
///
/// fn enable_rc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // CPU_PLL_DIV_IN
///
/// fn enable_cpu_pll_div_in_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_pll_div_in_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<CpuPllDivInConfig>,
///     _new_selector: CpuPllDivInConfig,
/// ) {
///     todo!()
/// }
///
/// // CPU_PLL_DIV
///
/// fn enable_cpu_pll_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_cpu_pll_div_impl(_clocks: &mut ClockTree, _new_config: CpuPllDivConfig) {
///     todo!()
/// }
///
/// // SYSTEM_PRE_DIV_IN
///
/// fn enable_system_pre_div_in_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_system_pre_div_in_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<SystemPreDivInConfig>,
///     _new_selector: SystemPreDivInConfig,
/// ) {
///     todo!()
/// }
///
/// // SYSTEM_PRE_DIV
///
/// fn enable_system_pre_div_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_system_pre_div_impl(_clocks: &mut ClockTree, _new_config: SystemPreDivConfig) {
///     todo!()
/// }
///
/// // APB_CLK
///
/// fn enable_apb_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_apb_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<ApbClkConfig>,
///     _new_selector: ApbClkConfig,
/// ) {
///     todo!()
/// }
///
/// // REF_TICK
///
/// fn enable_ref_tick_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RefTickConfig>,
///     _new_selector: RefTickConfig,
/// ) {
///     todo!()
/// }
///
/// // REF_TICK_XTAL
///
/// fn enable_ref_tick_xtal_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_xtal_impl(_clocks: &mut ClockTree, _new_config: RefTickXtalConfig) {
///     todo!()
/// }
///
/// // REF_TICK_CK8M
///
/// fn enable_ref_tick_ck8m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_ref_tick_ck8m_impl(_clocks: &mut ClockTree, _new_config: RefTickCk8mConfig) {
///     todo!()
/// }
///
/// // CPU_CLK
///
/// fn configure_cpu_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<CpuClkConfig>,
///     _new_selector: CpuClkConfig,
/// ) {
///     todo!()
/// }
///
/// // APB_CLK_CPU_DIV2
///
/// fn enable_apb_clk_cpu_div2_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // APB_CLK_80M
///
/// fn enable_apb_clk_80m_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL32K_CLK
///
/// fn enable_xtal32k_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_SLOW_CLK
///
/// fn enable_rc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RC_FAST_DIV_CLK
///
/// fn enable_rc_fast_div_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // XTAL_DIV_CLK
///
/// fn enable_xtal_div_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // RTC_SLOW_CLK
///
/// fn enable_rtc_slow_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_rtc_slow_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RtcSlowClkConfig>,
///     _new_selector: RtcSlowClkConfig,
/// ) {
///     todo!()
/// }
///
/// // RTC_FAST_CLK
///
/// fn enable_rtc_fast_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_rtc_fast_clk_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<RtcFastClkConfig>,
///     _new_selector: RtcFastClkConfig,
/// ) {
///     todo!()
/// }
///
/// // UART_MEM_CLK
///
/// fn enable_uart_mem_clk_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// // TIMG0_FUNCTION_CLOCK
///
/// fn enable_timg0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG0_CALIBRATION_CLOCK
///
/// fn enable_timg0_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg0_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_FUNCTION_CLOCK
///
/// fn enable_timg1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0FunctionClockConfig>,
///     _new_selector: Timg0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // TIMG1_CALIBRATION_CLOCK
///
/// fn enable_timg1_calibration_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_timg1_calibration_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Timg0CalibrationClockConfig>,
///     _new_selector: Timg0CalibrationClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART0_FUNCTION_CLOCK
///
/// fn enable_uart0_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart0_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0FunctionClockConfig>,
///     _new_selector: Uart0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART0_MEM_CLOCK
///
/// fn enable_uart0_mem_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart0_mem_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0MemClockConfig>,
///     _new_selector: Uart0MemClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART1_FUNCTION_CLOCK
///
/// fn enable_uart1_function_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart1_function_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0FunctionClockConfig>,
///     _new_selector: Uart0FunctionClockConfig,
/// ) {
///     todo!()
/// }
///
/// // UART1_MEM_CLOCK
///
/// fn enable_uart1_mem_clock_impl(_clocks: &mut ClockTree, _en: bool) {
///     todo!()
/// }
///
/// fn configure_uart1_mem_clock_impl(
///     _clocks: &mut ClockTree,
///     _old_selector: Option<Uart0MemClockConfig>,
///     _new_selector: Uart0MemClockConfig,
/// ) {
///     todo!()
/// }
/// ```
macro_rules! define_clock_tree_types {
    () => {
        /// Selects the output frequency of `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum XtalClkConfig {
            /// 40 MHz
            _40,
        }
        impl XtalClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    XtalClkConfig::_40 => 40000000,
                }
            }
        }
        /// Selects the output frequency of `PLL_CLK`. Depends on `XTAL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PllClkConfig {
            /// 320 MHz
            _320,
            /// 480 MHz
            _480,
        }
        impl PllClkConfig {
            pub fn value(&self) -> u32 {
                match self {
                    PllClkConfig::_320 => 320000000,
                    PllClkConfig::_480 => 480000000,
                }
            }
        }
        /// The target frequency of the `APLL_CLK` clock source. Depends on `PLL_CLK`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct ApllClkConfig(u32);
        impl ApllClkConfig {
            /// Creates a new clock source configuration.
            ///
            /// # Panics
            ///
            /// Panics if the output frequency value is outside the
            /// valid range (16 MHz - 128 MHz).
            pub const fn new(frequency: u32) -> Self {
                ::core::assert!(
                    frequency >= 16000000u32 && frequency <= 128000000u32,
                    "`APLL_CLK` output frequency value must be between 16000000 and 128000000 \
                     (inclusive)."
                );
                Self(frequency)
            }
        }
        impl ApllClkConfig {
            pub fn value(&self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `CPU_PLL_DIV_IN` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuPllDivInConfig {
            /// Selects `PLL_CLK`.
            Pll,
            /// Selects `APLL_CLK`.
            Apll,
        }
        /// Configures the `CPU_PLL_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = CPU_PLL_DIV_IN / DIVISOR`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuPllDivConfig {
            /// Selects `DIVISOR = 2`.
            _2 = 2,
            /// Selects `DIVISOR = 3`.
            _3 = 3,
            /// Selects `DIVISOR = 4`.
            _4 = 4,
            /// Selects `DIVISOR = 6`.
            _6 = 6,
        }
        impl CpuPllDivConfig {
            const fn new(raw: u32) -> Self {
                match raw {
                    2 => CpuPllDivConfig::_2,
                    3 => CpuPllDivConfig::_3,
                    4 => CpuPllDivConfig::_4,
                    6 => CpuPllDivConfig::_6,
                    _ => ::core::panic!("Invalid CPU_PLL_DIV divider value"),
                }
            }
            fn value(self) -> u32 {
                match self {
                    CpuPllDivConfig::_2 => 2,
                    CpuPllDivConfig::_3 => 3,
                    CpuPllDivConfig::_4 => 4,
                    CpuPllDivConfig::_6 => 6,
                }
            }
        }
        /// The list of clock signals that the `SYSTEM_PRE_DIV_IN` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SystemPreDivInConfig {
            /// Selects `XTAL_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            RcFast,
        }
        /// Configures the `SYSTEM_PRE_DIV` clock divider.
        ///
        /// The output is calculated as `OUTPUT = SYSTEM_PRE_DIV_IN / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct SystemPreDivConfig(u32);
        impl SystemPreDivConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 1023).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 1023u32,
                    "`SYSTEM_PRE_DIV` divisor value must be between 0 and 1023 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `APB_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApbClkConfig {
            /// Selects `APB_CLK_80M`.
            Pll,
            /// Selects `APB_CLK_CPU_DIV2`.
            Apll,
            /// Selects `CPU_CLK`.
            Xtal,
            /// Selects `CPU_CLK`.
            RcFast,
        }
        /// The list of clock signals that the `REF_TICK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RefTickConfig {
            /// Selects `REF_TICK_XTAL`.
            Pll,
            /// Selects `REF_TICK_XTAL`.
            Apll,
            /// Selects `REF_TICK_XTAL`.
            Xtal,
            /// Selects `REF_TICK_CK8M`.
            RcFast,
        }
        /// Configures the `REF_TICK_XTAL` clock divider.
        ///
        /// The output is calculated as `OUTPUT = XTAL_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct RefTickXtalConfig(u32);
        impl RefTickXtalConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`REF_TICK_XTAL` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// Configures the `REF_TICK_CK8M` clock divider.
        ///
        /// The output is calculated as `OUTPUT = RC_FAST_CLK / (DIVISOR + 1)`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub struct RefTickCk8mConfig(u32);
        impl RefTickCk8mConfig {
            /// Creates a new divider configuration.
            ///
            /// # Panics
            ///
            /// Panics if the divisor value is outside the
            /// valid range (0 ..= 255).
            pub const fn new(divisor: u32) -> Self {
                ::core::assert!(
                    divisor <= 255u32,
                    "`REF_TICK_CK8M` divisor value must be between 0 and 255 (inclusive)."
                );
                Self(divisor)
            }
            fn value(self) -> u32 {
                self.0
            }
        }
        /// The list of clock signals that the `CPU_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpuClkConfig {
            /// Selects `SYSTEM_PRE_DIV`.
            Xtal,
            /// Selects `SYSTEM_PRE_DIV`.
            RcFast,
            /// Selects `CPU_PLL_DIV`.
            Apll,
            /// Selects `CPU_PLL_DIV`.
            Pll,
        }
        /// The list of clock signals that the `RTC_SLOW_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RtcSlowClkConfig {
            /// Selects `XTAL32K_CLK`.
            Xtal32k,
            /// Selects `RC_SLOW_CLK`.
            RcSlow,
            /// Selects `RC_FAST_DIV_CLK`.
            RcFast,
        }
        /// The list of clock signals that the `RTC_FAST_CLK` multiplexer can output.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RtcFastClkConfig {
            /// Selects `XTAL_DIV_CLK`.
            Xtal,
            /// Selects `RC_FAST_CLK`.
            Rc,
        }
        /// The list of clock signals that the `TIMG0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0FunctionClockConfig {
            #[default]
            /// Selects `XTAL_CLK`.
            XtalClk,
            /// Selects `APB_CLK`.
            ApbClk,
        }
        /// The list of clock signals that the `TIMG0_CALIBRATION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timg0CalibrationClockConfig {
            #[default]
            /// Selects `RTC_SLOW_CLK`.
            RtcClk,
            /// Selects `RC_FAST_DIV_CLK`.
            RcFastDivClk,
            /// Selects `XTAL32K_CLK`.
            Xtal32kClk,
        }
        /// The list of clock signals that the `UART0_FUNCTION_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uart0FunctionClockConfig {
            #[default]
            /// Selects `APB_CLK`.
            Apb,
            /// Selects `REF_TICK`.
            RefTick,
        }
        /// The list of clock signals that the `UART0_MEM_CLOCK` multiplexer can output.
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uart0MemClockConfig {
            #[default]
            /// Selects `UART_MEM_CLK`.
            Mem,
        }
        /// Represents the device's clock tree.
        pub struct ClockTree {
            xtal_clk: Option<XtalClkConfig>,
            pll_clk: Option<PllClkConfig>,
            apll_clk: Option<ApllClkConfig>,
            cpu_pll_div_in: Option<CpuPllDivInConfig>,
            cpu_pll_div: Option<CpuPllDivConfig>,
            system_pre_div_in: Option<SystemPreDivInConfig>,
            system_pre_div: Option<SystemPreDivConfig>,
            apb_clk: Option<ApbClkConfig>,
            ref_tick: Option<RefTickConfig>,
            ref_tick_xtal: Option<RefTickXtalConfig>,
            ref_tick_ck8m: Option<RefTickCk8mConfig>,
            cpu_clk: Option<CpuClkConfig>,
            rtc_slow_clk: Option<RtcSlowClkConfig>,
            rtc_fast_clk: Option<RtcFastClkConfig>,
            timg0_function_clock: Option<Timg0FunctionClockConfig>,
            timg0_calibration_clock: Option<Timg0CalibrationClockConfig>,
            timg1_function_clock: Option<Timg0FunctionClockConfig>,
            timg1_calibration_clock: Option<Timg0CalibrationClockConfig>,
            uart0_function_clock: Option<Uart0FunctionClockConfig>,
            uart0_mem_clock: Option<Uart0MemClockConfig>,
            uart1_function_clock: Option<Uart0FunctionClockConfig>,
            uart1_mem_clock: Option<Uart0MemClockConfig>,
            pll_clk_refcount: u32,
            rc_fast_clk_refcount: u32,
            apb_clk_refcount: u32,
            ref_tick_refcount: u32,
            xtal32k_clk_refcount: u32,
            rc_fast_div_clk_refcount: u32,
            rtc_slow_clk_refcount: u32,
            rtc_fast_clk_refcount: u32,
            uart_mem_clk_refcount: u32,
            timg0_function_clock_refcount: u32,
            timg0_calibration_clock_refcount: u32,
            timg1_function_clock_refcount: u32,
            timg1_calibration_clock_refcount: u32,
            uart0_function_clock_refcount: u32,
            uart0_mem_clock_refcount: u32,
            uart1_function_clock_refcount: u32,
            uart1_mem_clock_refcount: u32,
        }
        impl ClockTree {
            /// Locks the clock tree for exclusive access.
            pub fn with<R>(f: impl FnOnce(&mut ClockTree) -> R) -> R {
                CLOCK_TREE.with(f)
            }
            /// Returns the current configuration of the XTAL_CLK clock tree node
            pub fn xtal_clk(&self) -> Option<XtalClkConfig> {
                self.xtal_clk
            }
            /// Returns the current configuration of the PLL_CLK clock tree node
            pub fn pll_clk(&self) -> Option<PllClkConfig> {
                self.pll_clk
            }
            /// Returns the current configuration of the APLL_CLK clock tree node
            pub fn apll_clk(&self) -> Option<ApllClkConfig> {
                self.apll_clk
            }
            /// Returns the current configuration of the CPU_PLL_DIV_IN clock tree node
            pub fn cpu_pll_div_in(&self) -> Option<CpuPllDivInConfig> {
                self.cpu_pll_div_in
            }
            /// Returns the current configuration of the CPU_PLL_DIV clock tree node
            pub fn cpu_pll_div(&self) -> Option<CpuPllDivConfig> {
                self.cpu_pll_div
            }
            /// Returns the current configuration of the SYSTEM_PRE_DIV_IN clock tree node
            pub fn system_pre_div_in(&self) -> Option<SystemPreDivInConfig> {
                self.system_pre_div_in
            }
            /// Returns the current configuration of the SYSTEM_PRE_DIV clock tree node
            pub fn system_pre_div(&self) -> Option<SystemPreDivConfig> {
                self.system_pre_div
            }
            /// Returns the current configuration of the APB_CLK clock tree node
            pub fn apb_clk(&self) -> Option<ApbClkConfig> {
                self.apb_clk
            }
            /// Returns the current configuration of the REF_TICK clock tree node
            pub fn ref_tick(&self) -> Option<RefTickConfig> {
                self.ref_tick
            }
            /// Returns the current configuration of the REF_TICK_XTAL clock tree node
            pub fn ref_tick_xtal(&self) -> Option<RefTickXtalConfig> {
                self.ref_tick_xtal
            }
            /// Returns the current configuration of the REF_TICK_CK8M clock tree node
            pub fn ref_tick_ck8m(&self) -> Option<RefTickCk8mConfig> {
                self.ref_tick_ck8m
            }
            /// Returns the current configuration of the CPU_CLK clock tree node
            pub fn cpu_clk(&self) -> Option<CpuClkConfig> {
                self.cpu_clk
            }
            /// Returns the current configuration of the RTC_SLOW_CLK clock tree node
            pub fn rtc_slow_clk(&self) -> Option<RtcSlowClkConfig> {
                self.rtc_slow_clk
            }
            /// Returns the current configuration of the RTC_FAST_CLK clock tree node
            pub fn rtc_fast_clk(&self) -> Option<RtcFastClkConfig> {
                self.rtc_fast_clk
            }
            /// Returns the current configuration of the TIMG0_FUNCTION_CLOCK clock tree node
            pub fn timg0_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg0_function_clock
            }
            /// Returns the current configuration of the TIMG0_CALIBRATION_CLOCK clock tree node
            pub fn timg0_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg0_calibration_clock
            }
            /// Returns the current configuration of the TIMG1_FUNCTION_CLOCK clock tree node
            pub fn timg1_function_clock(&self) -> Option<Timg0FunctionClockConfig> {
                self.timg1_function_clock
            }
            /// Returns the current configuration of the TIMG1_CALIBRATION_CLOCK clock tree node
            pub fn timg1_calibration_clock(&self) -> Option<Timg0CalibrationClockConfig> {
                self.timg1_calibration_clock
            }
            /// Returns the current configuration of the UART0_FUNCTION_CLOCK clock tree node
            pub fn uart0_function_clock(&self) -> Option<Uart0FunctionClockConfig> {
                self.uart0_function_clock
            }
            /// Returns the current configuration of the UART0_MEM_CLOCK clock tree node
            pub fn uart0_mem_clock(&self) -> Option<Uart0MemClockConfig> {
                self.uart0_mem_clock
            }
            /// Returns the current configuration of the UART1_FUNCTION_CLOCK clock tree node
            pub fn uart1_function_clock(&self) -> Option<Uart0FunctionClockConfig> {
                self.uart1_function_clock
            }
            /// Returns the current configuration of the UART1_MEM_CLOCK clock tree node
            pub fn uart1_mem_clock(&self) -> Option<Uart0MemClockConfig> {
                self.uart1_mem_clock
            }
        }
        static CLOCK_TREE: ::esp_sync::NonReentrantMutex<ClockTree> =
            ::esp_sync::NonReentrantMutex::new(ClockTree {
                xtal_clk: None,
                pll_clk: None,
                apll_clk: None,
                cpu_pll_div_in: None,
                cpu_pll_div: None,
                system_pre_div_in: None,
                system_pre_div: None,
                apb_clk: None,
                ref_tick: None,
                ref_tick_xtal: None,
                ref_tick_ck8m: None,
                cpu_clk: None,
                rtc_slow_clk: None,
                rtc_fast_clk: None,
                timg0_function_clock: None,
                timg0_calibration_clock: None,
                timg1_function_clock: None,
                timg1_calibration_clock: None,
                uart0_function_clock: None,
                uart0_mem_clock: None,
                uart1_function_clock: None,
                uart1_mem_clock: None,
                pll_clk_refcount: 0,
                rc_fast_clk_refcount: 0,
                apb_clk_refcount: 0,
                ref_tick_refcount: 0,
                xtal32k_clk_refcount: 0,
                rc_fast_div_clk_refcount: 0,
                rtc_slow_clk_refcount: 0,
                rtc_fast_clk_refcount: 0,
                uart_mem_clk_refcount: 0,
                timg0_function_clock_refcount: 0,
                timg0_calibration_clock_refcount: 0,
                timg1_function_clock_refcount: 0,
                timg1_calibration_clock_refcount: 0,
                uart0_function_clock_refcount: 0,
                uart0_mem_clock_refcount: 0,
                uart1_function_clock_refcount: 0,
                uart1_mem_clock_refcount: 0,
            });
        pub fn configure_xtal_clk(clocks: &mut ClockTree, config: XtalClkConfig) {
            clocks.xtal_clk = Some(config);
            configure_xtal_clk_impl(clocks, config);
        }
        pub fn xtal_clk_config(clocks: &mut ClockTree) -> Option<XtalClkConfig> {
            clocks.xtal_clk
        }
        fn request_xtal_clk(_clocks: &mut ClockTree) {}
        fn release_xtal_clk(_clocks: &mut ClockTree) {}
        pub fn xtal_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.xtal_clk).value()
        }
        pub fn configure_pll_clk(clocks: &mut ClockTree, config: PllClkConfig) {
            clocks.pll_clk = Some(config);
            configure_pll_clk_impl(clocks, config);
        }
        pub fn pll_clk_config(clocks: &mut ClockTree) -> Option<PllClkConfig> {
            clocks.pll_clk
        }
        pub fn request_pll_clk(clocks: &mut ClockTree) {
            trace!("Requesting PLL_CLK");
            if increment_reference_count(&mut clocks.pll_clk_refcount) {
                trace!("Enabling PLL_CLK");
                request_xtal_clk(clocks);
                enable_pll_clk_impl(clocks, true);
            }
        }
        pub fn release_pll_clk(clocks: &mut ClockTree) {
            trace!("Releasing PLL_CLK");
            if decrement_reference_count(&mut clocks.pll_clk_refcount) {
                trace!("Disabling PLL_CLK");
                enable_pll_clk_impl(clocks, false);
                release_xtal_clk(clocks);
            }
        }
        pub fn pll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.pll_clk).value()
        }
        pub fn configure_apll_clk(clocks: &mut ClockTree, config: ApllClkConfig) {
            clocks.apll_clk = Some(config);
            configure_apll_clk_impl(clocks, config);
        }
        pub fn apll_clk_config(clocks: &mut ClockTree) -> Option<ApllClkConfig> {
            clocks.apll_clk
        }
        pub fn request_apll_clk(clocks: &mut ClockTree) {
            trace!("Requesting APLL_CLK");
            trace!("Enabling APLL_CLK");
            request_pll_clk(clocks);
            enable_apll_clk_impl(clocks, true);
        }
        pub fn release_apll_clk(clocks: &mut ClockTree) {
            trace!("Releasing APLL_CLK");
            trace!("Disabling APLL_CLK");
            enable_apll_clk_impl(clocks, false);
            release_pll_clk(clocks);
        }
        pub fn apll_clk_frequency(clocks: &mut ClockTree) -> u32 {
            unwrap!(clocks.apll_clk).value()
        }
        pub fn request_rc_fast_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_FAST_CLK");
            if increment_reference_count(&mut clocks.rc_fast_clk_refcount) {
                trace!("Enabling RC_FAST_CLK");
                enable_rc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_FAST_CLK");
            if decrement_reference_count(&mut clocks.rc_fast_clk_refcount) {
                trace!("Disabling RC_FAST_CLK");
                enable_rc_fast_clk_impl(clocks, false);
            }
        }
        pub fn rc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            8000000
        }
        pub fn configure_cpu_pll_div_in(clocks: &mut ClockTree, new_selector: CpuPllDivInConfig) {
            let old_selector = clocks.cpu_pll_div_in.replace(new_selector);
            match new_selector {
                CpuPllDivInConfig::Pll => request_pll_clk(clocks),
                CpuPllDivInConfig::Apll => request_apll_clk(clocks),
            }
            configure_cpu_pll_div_in_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    CpuPllDivInConfig::Pll => release_pll_clk(clocks),
                    CpuPllDivInConfig::Apll => release_apll_clk(clocks),
                }
            }
        }
        pub fn cpu_pll_div_in_config(clocks: &mut ClockTree) -> Option<CpuPllDivInConfig> {
            clocks.cpu_pll_div_in
        }
        pub fn request_cpu_pll_div_in(clocks: &mut ClockTree) {
            trace!("Requesting CPU_PLL_DIV_IN");
            trace!("Enabling CPU_PLL_DIV_IN");
            match unwrap!(clocks.cpu_pll_div_in) {
                CpuPllDivInConfig::Pll => request_pll_clk(clocks),
                CpuPllDivInConfig::Apll => request_apll_clk(clocks),
            }
            enable_cpu_pll_div_in_impl(clocks, true);
        }
        pub fn release_cpu_pll_div_in(clocks: &mut ClockTree) {
            trace!("Releasing CPU_PLL_DIV_IN");
            trace!("Disabling CPU_PLL_DIV_IN");
            enable_cpu_pll_div_in_impl(clocks, false);
            match unwrap!(clocks.cpu_pll_div_in) {
                CpuPllDivInConfig::Pll => release_pll_clk(clocks),
                CpuPllDivInConfig::Apll => release_apll_clk(clocks),
            }
        }
        pub fn cpu_pll_div_in_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.cpu_pll_div_in) {
                CpuPllDivInConfig::Pll => pll_clk_frequency(clocks),
                CpuPllDivInConfig::Apll => apll_clk_frequency(clocks),
            }
        }
        pub fn configure_cpu_pll_div(clocks: &mut ClockTree, config: CpuPllDivConfig) {
            clocks.cpu_pll_div = Some(config);
            configure_cpu_pll_div_impl(clocks, config);
        }
        pub fn cpu_pll_div_config(clocks: &mut ClockTree) -> Option<CpuPllDivConfig> {
            clocks.cpu_pll_div
        }
        pub fn request_cpu_pll_div(clocks: &mut ClockTree) {
            trace!("Requesting CPU_PLL_DIV");
            trace!("Enabling CPU_PLL_DIV");
            request_cpu_pll_div_in(clocks);
            enable_cpu_pll_div_impl(clocks, true);
        }
        pub fn release_cpu_pll_div(clocks: &mut ClockTree) {
            trace!("Releasing CPU_PLL_DIV");
            trace!("Disabling CPU_PLL_DIV");
            enable_cpu_pll_div_impl(clocks, false);
            release_cpu_pll_div_in(clocks);
        }
        pub fn cpu_pll_div_frequency(clocks: &mut ClockTree) -> u32 {
            (cpu_pll_div_in_frequency(clocks) / unwrap!(clocks.cpu_pll_div).value())
        }
        pub fn configure_system_pre_div_in(
            clocks: &mut ClockTree,
            new_selector: SystemPreDivInConfig,
        ) {
            let old_selector = clocks.system_pre_div_in.replace(new_selector);
            match new_selector {
                SystemPreDivInConfig::Xtal => request_xtal_clk(clocks),
                SystemPreDivInConfig::RcFast => request_rc_fast_clk(clocks),
            }
            configure_system_pre_div_in_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    SystemPreDivInConfig::Xtal => release_xtal_clk(clocks),
                    SystemPreDivInConfig::RcFast => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn system_pre_div_in_config(clocks: &mut ClockTree) -> Option<SystemPreDivInConfig> {
            clocks.system_pre_div_in
        }
        pub fn request_system_pre_div_in(clocks: &mut ClockTree) {
            trace!("Requesting SYSTEM_PRE_DIV_IN");
            trace!("Enabling SYSTEM_PRE_DIV_IN");
            match unwrap!(clocks.system_pre_div_in) {
                SystemPreDivInConfig::Xtal => request_xtal_clk(clocks),
                SystemPreDivInConfig::RcFast => request_rc_fast_clk(clocks),
            }
            enable_system_pre_div_in_impl(clocks, true);
        }
        pub fn release_system_pre_div_in(clocks: &mut ClockTree) {
            trace!("Releasing SYSTEM_PRE_DIV_IN");
            trace!("Disabling SYSTEM_PRE_DIV_IN");
            enable_system_pre_div_in_impl(clocks, false);
            match unwrap!(clocks.system_pre_div_in) {
                SystemPreDivInConfig::Xtal => release_xtal_clk(clocks),
                SystemPreDivInConfig::RcFast => release_rc_fast_clk(clocks),
            }
        }
        pub fn system_pre_div_in_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.system_pre_div_in) {
                SystemPreDivInConfig::Xtal => xtal_clk_frequency(clocks),
                SystemPreDivInConfig::RcFast => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn configure_system_pre_div(clocks: &mut ClockTree, config: SystemPreDivConfig) {
            clocks.system_pre_div = Some(config);
            configure_system_pre_div_impl(clocks, config);
        }
        pub fn system_pre_div_config(clocks: &mut ClockTree) -> Option<SystemPreDivConfig> {
            clocks.system_pre_div
        }
        pub fn request_system_pre_div(clocks: &mut ClockTree) {
            trace!("Requesting SYSTEM_PRE_DIV");
            trace!("Enabling SYSTEM_PRE_DIV");
            request_system_pre_div_in(clocks);
            enable_system_pre_div_impl(clocks, true);
        }
        pub fn release_system_pre_div(clocks: &mut ClockTree) {
            trace!("Releasing SYSTEM_PRE_DIV");
            trace!("Disabling SYSTEM_PRE_DIV");
            enable_system_pre_div_impl(clocks, false);
            release_system_pre_div_in(clocks);
        }
        pub fn system_pre_div_frequency(clocks: &mut ClockTree) -> u32 {
            (system_pre_div_in_frequency(clocks) / (unwrap!(clocks.system_pre_div).value() + 1))
        }
        pub fn configure_apb_clk(clocks: &mut ClockTree, new_selector: ApbClkConfig) {
            let old_selector = clocks.apb_clk.replace(new_selector);
            if clocks.apb_clk_refcount > 0 {
                match new_selector {
                    ApbClkConfig::Pll => request_apb_clk_80m(clocks),
                    ApbClkConfig::Apll => request_apb_clk_cpu_div2(clocks),
                    ApbClkConfig::Xtal => request_cpu_clk(clocks),
                    ApbClkConfig::RcFast => request_cpu_clk(clocks),
                }
                configure_apb_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        ApbClkConfig::Pll => release_apb_clk_80m(clocks),
                        ApbClkConfig::Apll => release_apb_clk_cpu_div2(clocks),
                        ApbClkConfig::Xtal => release_cpu_clk(clocks),
                        ApbClkConfig::RcFast => release_cpu_clk(clocks),
                    }
                }
            } else {
                configure_apb_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn apb_clk_config(clocks: &mut ClockTree) -> Option<ApbClkConfig> {
            clocks.apb_clk
        }
        pub fn request_apb_clk(clocks: &mut ClockTree) {
            trace!("Requesting APB_CLK");
            if increment_reference_count(&mut clocks.apb_clk_refcount) {
                trace!("Enabling APB_CLK");
                match unwrap!(clocks.apb_clk) {
                    ApbClkConfig::Pll => request_apb_clk_80m(clocks),
                    ApbClkConfig::Apll => request_apb_clk_cpu_div2(clocks),
                    ApbClkConfig::Xtal => request_cpu_clk(clocks),
                    ApbClkConfig::RcFast => request_cpu_clk(clocks),
                }
                enable_apb_clk_impl(clocks, true);
            }
        }
        pub fn release_apb_clk(clocks: &mut ClockTree) {
            trace!("Releasing APB_CLK");
            if decrement_reference_count(&mut clocks.apb_clk_refcount) {
                trace!("Disabling APB_CLK");
                enable_apb_clk_impl(clocks, false);
                match unwrap!(clocks.apb_clk) {
                    ApbClkConfig::Pll => release_apb_clk_80m(clocks),
                    ApbClkConfig::Apll => release_apb_clk_cpu_div2(clocks),
                    ApbClkConfig::Xtal => release_cpu_clk(clocks),
                    ApbClkConfig::RcFast => release_cpu_clk(clocks),
                }
            }
        }
        pub fn apb_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.apb_clk) {
                ApbClkConfig::Pll => apb_clk_80m_frequency(clocks),
                ApbClkConfig::Apll => apb_clk_cpu_div2_frequency(clocks),
                ApbClkConfig::Xtal => cpu_clk_frequency(clocks),
                ApbClkConfig::RcFast => cpu_clk_frequency(clocks),
            }
        }
        pub fn configure_ref_tick(clocks: &mut ClockTree, new_selector: RefTickConfig) {
            let old_selector = clocks.ref_tick.replace(new_selector);
            if clocks.ref_tick_refcount > 0 {
                match new_selector {
                    RefTickConfig::Pll => request_ref_tick_xtal(clocks),
                    RefTickConfig::Apll => request_ref_tick_xtal(clocks),
                    RefTickConfig::Xtal => request_ref_tick_xtal(clocks),
                    RefTickConfig::RcFast => request_ref_tick_ck8m(clocks),
                }
                configure_ref_tick_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RefTickConfig::Pll => release_ref_tick_xtal(clocks),
                        RefTickConfig::Apll => release_ref_tick_xtal(clocks),
                        RefTickConfig::Xtal => release_ref_tick_xtal(clocks),
                        RefTickConfig::RcFast => release_ref_tick_ck8m(clocks),
                    }
                }
            } else {
                configure_ref_tick_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn ref_tick_config(clocks: &mut ClockTree) -> Option<RefTickConfig> {
            clocks.ref_tick
        }
        pub fn request_ref_tick(clocks: &mut ClockTree) {
            trace!("Requesting REF_TICK");
            if increment_reference_count(&mut clocks.ref_tick_refcount) {
                trace!("Enabling REF_TICK");
                match unwrap!(clocks.ref_tick) {
                    RefTickConfig::Pll => request_ref_tick_xtal(clocks),
                    RefTickConfig::Apll => request_ref_tick_xtal(clocks),
                    RefTickConfig::Xtal => request_ref_tick_xtal(clocks),
                    RefTickConfig::RcFast => request_ref_tick_ck8m(clocks),
                }
                enable_ref_tick_impl(clocks, true);
            }
        }
        pub fn release_ref_tick(clocks: &mut ClockTree) {
            trace!("Releasing REF_TICK");
            if decrement_reference_count(&mut clocks.ref_tick_refcount) {
                trace!("Disabling REF_TICK");
                enable_ref_tick_impl(clocks, false);
                match unwrap!(clocks.ref_tick) {
                    RefTickConfig::Pll => release_ref_tick_xtal(clocks),
                    RefTickConfig::Apll => release_ref_tick_xtal(clocks),
                    RefTickConfig::Xtal => release_ref_tick_xtal(clocks),
                    RefTickConfig::RcFast => release_ref_tick_ck8m(clocks),
                }
            }
        }
        pub fn ref_tick_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.ref_tick) {
                RefTickConfig::Pll => ref_tick_xtal_frequency(clocks),
                RefTickConfig::Apll => ref_tick_xtal_frequency(clocks),
                RefTickConfig::Xtal => ref_tick_xtal_frequency(clocks),
                RefTickConfig::RcFast => ref_tick_ck8m_frequency(clocks),
            }
        }
        pub fn configure_ref_tick_xtal(clocks: &mut ClockTree, config: RefTickXtalConfig) {
            clocks.ref_tick_xtal = Some(config);
            configure_ref_tick_xtal_impl(clocks, config);
        }
        pub fn ref_tick_xtal_config(clocks: &mut ClockTree) -> Option<RefTickXtalConfig> {
            clocks.ref_tick_xtal
        }
        pub fn request_ref_tick_xtal(clocks: &mut ClockTree) {
            trace!("Requesting REF_TICK_XTAL");
            trace!("Enabling REF_TICK_XTAL");
            request_xtal_clk(clocks);
            enable_ref_tick_xtal_impl(clocks, true);
        }
        pub fn release_ref_tick_xtal(clocks: &mut ClockTree) {
            trace!("Releasing REF_TICK_XTAL");
            trace!("Disabling REF_TICK_XTAL");
            enable_ref_tick_xtal_impl(clocks, false);
            release_xtal_clk(clocks);
        }
        pub fn ref_tick_xtal_frequency(clocks: &mut ClockTree) -> u32 {
            (xtal_clk_frequency(clocks) / (unwrap!(clocks.ref_tick_xtal).value() + 1))
        }
        pub fn configure_ref_tick_ck8m(clocks: &mut ClockTree, config: RefTickCk8mConfig) {
            clocks.ref_tick_ck8m = Some(config);
            configure_ref_tick_ck8m_impl(clocks, config);
        }
        pub fn ref_tick_ck8m_config(clocks: &mut ClockTree) -> Option<RefTickCk8mConfig> {
            clocks.ref_tick_ck8m
        }
        pub fn request_ref_tick_ck8m(clocks: &mut ClockTree) {
            trace!("Requesting REF_TICK_CK8M");
            trace!("Enabling REF_TICK_CK8M");
            request_rc_fast_clk(clocks);
            enable_ref_tick_ck8m_impl(clocks, true);
        }
        pub fn release_ref_tick_ck8m(clocks: &mut ClockTree) {
            trace!("Releasing REF_TICK_CK8M");
            trace!("Disabling REF_TICK_CK8M");
            enable_ref_tick_ck8m_impl(clocks, false);
            release_rc_fast_clk(clocks);
        }
        pub fn ref_tick_ck8m_frequency(clocks: &mut ClockTree) -> u32 {
            (rc_fast_clk_frequency(clocks) / (unwrap!(clocks.ref_tick_ck8m).value() + 1))
        }
        pub fn configure_cpu_clk(clocks: &mut ClockTree, new_selector: CpuClkConfig) {
            let old_selector = clocks.cpu_clk.replace(new_selector);
            match new_selector {
                CpuClkConfig::Xtal => {
                    configure_system_pre_div_in(clocks, SystemPreDivInConfig::Xtal);
                    configure_apb_clk(clocks, ApbClkConfig::Xtal);
                    configure_ref_tick(clocks, RefTickConfig::Xtal);
                    let config_value =
                        RefTickXtalConfig::new(((xtal_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_xtal(clocks, config_value);
                }
                CpuClkConfig::RcFast => {
                    configure_system_pre_div_in(clocks, SystemPreDivInConfig::RcFast);
                    configure_apb_clk(clocks, ApbClkConfig::RcFast);
                    configure_ref_tick(clocks, RefTickConfig::RcFast);
                    let config_value =
                        RefTickCk8mConfig::new(((rc_fast_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_ck8m(clocks, config_value);
                }
                CpuClkConfig::Apll => {
                    configure_cpu_pll_div_in(clocks, CpuPllDivInConfig::Apll);
                    configure_apb_clk(clocks, ApbClkConfig::Apll);
                    configure_ref_tick(clocks, RefTickConfig::Apll);
                    let config_value =
                        RefTickXtalConfig::new(((xtal_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_xtal(clocks, config_value);
                }
                CpuClkConfig::Pll => {
                    configure_cpu_pll_div_in(clocks, CpuPllDivInConfig::Pll);
                    configure_apb_clk(clocks, ApbClkConfig::Pll);
                    configure_ref_tick(clocks, RefTickConfig::Pll);
                    let config_value =
                        RefTickXtalConfig::new(((xtal_clk_frequency(clocks) / 1000000) - 1));
                    configure_ref_tick_xtal(clocks, config_value);
                }
            }
            match new_selector {
                CpuClkConfig::Xtal => request_system_pre_div(clocks),
                CpuClkConfig::RcFast => request_system_pre_div(clocks),
                CpuClkConfig::Apll => request_cpu_pll_div(clocks),
                CpuClkConfig::Pll => request_cpu_pll_div(clocks),
            }
            configure_cpu_clk_impl(clocks, old_selector, new_selector);
            if let Some(old_selector) = old_selector {
                match old_selector {
                    CpuClkConfig::Xtal => release_system_pre_div(clocks),
                    CpuClkConfig::RcFast => release_system_pre_div(clocks),
                    CpuClkConfig::Apll => release_cpu_pll_div(clocks),
                    CpuClkConfig::Pll => release_cpu_pll_div(clocks),
                }
            }
        }
        pub fn cpu_clk_config(clocks: &mut ClockTree) -> Option<CpuClkConfig> {
            clocks.cpu_clk
        }
        fn request_cpu_clk(_clocks: &mut ClockTree) {}
        fn release_cpu_clk(_clocks: &mut ClockTree) {}
        pub fn cpu_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.cpu_clk) {
                CpuClkConfig::Xtal => system_pre_div_frequency(clocks),
                CpuClkConfig::RcFast => system_pre_div_frequency(clocks),
                CpuClkConfig::Apll => cpu_pll_div_frequency(clocks),
                CpuClkConfig::Pll => cpu_pll_div_frequency(clocks),
            }
        }
        pub fn request_apb_clk_cpu_div2(clocks: &mut ClockTree) {
            trace!("Requesting APB_CLK_CPU_DIV2");
            trace!("Enabling APB_CLK_CPU_DIV2");
            request_cpu_clk(clocks);
            enable_apb_clk_cpu_div2_impl(clocks, true);
        }
        pub fn release_apb_clk_cpu_div2(clocks: &mut ClockTree) {
            trace!("Releasing APB_CLK_CPU_DIV2");
            trace!("Disabling APB_CLK_CPU_DIV2");
            enable_apb_clk_cpu_div2_impl(clocks, false);
            release_cpu_clk(clocks);
        }
        pub fn apb_clk_cpu_div2_frequency(clocks: &mut ClockTree) -> u32 {
            (cpu_clk_frequency(clocks) / 2)
        }
        pub fn request_apb_clk_80m(clocks: &mut ClockTree) {
            trace!("Requesting APB_CLK_80M");
            trace!("Enabling APB_CLK_80M");
            request_cpu_clk(clocks);
            enable_apb_clk_80m_impl(clocks, true);
        }
        pub fn release_apb_clk_80m(clocks: &mut ClockTree) {
            trace!("Releasing APB_CLK_80M");
            trace!("Disabling APB_CLK_80M");
            enable_apb_clk_80m_impl(clocks, false);
            release_cpu_clk(clocks);
        }
        pub fn apb_clk_80m_frequency(clocks: &mut ClockTree) -> u32 {
            80000000
        }
        pub fn request_xtal32k_clk(clocks: &mut ClockTree) {
            trace!("Requesting XTAL32K_CLK");
            if increment_reference_count(&mut clocks.xtal32k_clk_refcount) {
                trace!("Enabling XTAL32K_CLK");
                enable_xtal32k_clk_impl(clocks, true);
            }
        }
        pub fn release_xtal32k_clk(clocks: &mut ClockTree) {
            trace!("Releasing XTAL32K_CLK");
            if decrement_reference_count(&mut clocks.xtal32k_clk_refcount) {
                trace!("Disabling XTAL32K_CLK");
                enable_xtal32k_clk_impl(clocks, false);
            }
        }
        pub fn xtal32k_clk_frequency(clocks: &mut ClockTree) -> u32 {
            32768
        }
        pub fn request_rc_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_SLOW_CLK");
            trace!("Enabling RC_SLOW_CLK");
            enable_rc_slow_clk_impl(clocks, true);
        }
        pub fn release_rc_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_SLOW_CLK");
            trace!("Disabling RC_SLOW_CLK");
            enable_rc_slow_clk_impl(clocks, false);
        }
        pub fn rc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            90000
        }
        pub fn request_rc_fast_div_clk(clocks: &mut ClockTree) {
            trace!("Requesting RC_FAST_DIV_CLK");
            if increment_reference_count(&mut clocks.rc_fast_div_clk_refcount) {
                trace!("Enabling RC_FAST_DIV_CLK");
                request_rc_fast_clk(clocks);
                enable_rc_fast_div_clk_impl(clocks, true);
            }
        }
        pub fn release_rc_fast_div_clk(clocks: &mut ClockTree) {
            trace!("Releasing RC_FAST_DIV_CLK");
            if decrement_reference_count(&mut clocks.rc_fast_div_clk_refcount) {
                trace!("Disabling RC_FAST_DIV_CLK");
                enable_rc_fast_div_clk_impl(clocks, false);
                release_rc_fast_clk(clocks);
            }
        }
        pub fn rc_fast_div_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (rc_fast_clk_frequency(clocks) / 256)
        }
        pub fn request_xtal_div_clk(clocks: &mut ClockTree) {
            trace!("Requesting XTAL_DIV_CLK");
            trace!("Enabling XTAL_DIV_CLK");
            request_xtal_clk(clocks);
            enable_xtal_div_clk_impl(clocks, true);
        }
        pub fn release_xtal_div_clk(clocks: &mut ClockTree) {
            trace!("Releasing XTAL_DIV_CLK");
            trace!("Disabling XTAL_DIV_CLK");
            enable_xtal_div_clk_impl(clocks, false);
            release_xtal_clk(clocks);
        }
        pub fn xtal_div_clk_frequency(clocks: &mut ClockTree) -> u32 {
            (xtal_clk_frequency(clocks) / 4)
        }
        pub fn configure_rtc_slow_clk(clocks: &mut ClockTree, new_selector: RtcSlowClkConfig) {
            let old_selector = clocks.rtc_slow_clk.replace(new_selector);
            if clocks.rtc_slow_clk_refcount > 0 {
                match new_selector {
                    RtcSlowClkConfig::Xtal32k => request_xtal32k_clk(clocks),
                    RtcSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    RtcSlowClkConfig::RcFast => request_rc_fast_div_clk(clocks),
                }
                configure_rtc_slow_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RtcSlowClkConfig::Xtal32k => release_xtal32k_clk(clocks),
                        RtcSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                        RtcSlowClkConfig::RcFast => release_rc_fast_div_clk(clocks),
                    }
                }
            } else {
                configure_rtc_slow_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn rtc_slow_clk_config(clocks: &mut ClockTree) -> Option<RtcSlowClkConfig> {
            clocks.rtc_slow_clk
        }
        pub fn request_rtc_slow_clk(clocks: &mut ClockTree) {
            trace!("Requesting RTC_SLOW_CLK");
            if increment_reference_count(&mut clocks.rtc_slow_clk_refcount) {
                trace!("Enabling RTC_SLOW_CLK");
                match unwrap!(clocks.rtc_slow_clk) {
                    RtcSlowClkConfig::Xtal32k => request_xtal32k_clk(clocks),
                    RtcSlowClkConfig::RcSlow => request_rc_slow_clk(clocks),
                    RtcSlowClkConfig::RcFast => request_rc_fast_div_clk(clocks),
                }
                enable_rtc_slow_clk_impl(clocks, true);
            }
        }
        pub fn release_rtc_slow_clk(clocks: &mut ClockTree) {
            trace!("Releasing RTC_SLOW_CLK");
            if decrement_reference_count(&mut clocks.rtc_slow_clk_refcount) {
                trace!("Disabling RTC_SLOW_CLK");
                enable_rtc_slow_clk_impl(clocks, false);
                match unwrap!(clocks.rtc_slow_clk) {
                    RtcSlowClkConfig::Xtal32k => release_xtal32k_clk(clocks),
                    RtcSlowClkConfig::RcSlow => release_rc_slow_clk(clocks),
                    RtcSlowClkConfig::RcFast => release_rc_fast_div_clk(clocks),
                }
            }
        }
        pub fn rtc_slow_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.rtc_slow_clk) {
                RtcSlowClkConfig::Xtal32k => xtal32k_clk_frequency(clocks),
                RtcSlowClkConfig::RcSlow => rc_slow_clk_frequency(clocks),
                RtcSlowClkConfig::RcFast => rc_fast_div_clk_frequency(clocks),
            }
        }
        pub fn configure_rtc_fast_clk(clocks: &mut ClockTree, new_selector: RtcFastClkConfig) {
            let old_selector = clocks.rtc_fast_clk.replace(new_selector);
            if clocks.rtc_fast_clk_refcount > 0 {
                match new_selector {
                    RtcFastClkConfig::Xtal => request_xtal_div_clk(clocks),
                    RtcFastClkConfig::Rc => request_rc_fast_clk(clocks),
                }
                configure_rtc_fast_clk_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        RtcFastClkConfig::Xtal => release_xtal_div_clk(clocks),
                        RtcFastClkConfig::Rc => release_rc_fast_clk(clocks),
                    }
                }
            } else {
                configure_rtc_fast_clk_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn rtc_fast_clk_config(clocks: &mut ClockTree) -> Option<RtcFastClkConfig> {
            clocks.rtc_fast_clk
        }
        pub fn request_rtc_fast_clk(clocks: &mut ClockTree) {
            trace!("Requesting RTC_FAST_CLK");
            if increment_reference_count(&mut clocks.rtc_fast_clk_refcount) {
                trace!("Enabling RTC_FAST_CLK");
                match unwrap!(clocks.rtc_fast_clk) {
                    RtcFastClkConfig::Xtal => request_xtal_div_clk(clocks),
                    RtcFastClkConfig::Rc => request_rc_fast_clk(clocks),
                }
                enable_rtc_fast_clk_impl(clocks, true);
            }
        }
        pub fn release_rtc_fast_clk(clocks: &mut ClockTree) {
            trace!("Releasing RTC_FAST_CLK");
            if decrement_reference_count(&mut clocks.rtc_fast_clk_refcount) {
                trace!("Disabling RTC_FAST_CLK");
                enable_rtc_fast_clk_impl(clocks, false);
                match unwrap!(clocks.rtc_fast_clk) {
                    RtcFastClkConfig::Xtal => release_xtal_div_clk(clocks),
                    RtcFastClkConfig::Rc => release_rc_fast_clk(clocks),
                }
            }
        }
        pub fn rtc_fast_clk_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.rtc_fast_clk) {
                RtcFastClkConfig::Xtal => xtal_div_clk_frequency(clocks),
                RtcFastClkConfig::Rc => rc_fast_clk_frequency(clocks),
            }
        }
        pub fn request_uart_mem_clk(clocks: &mut ClockTree) {
            trace!("Requesting UART_MEM_CLK");
            if increment_reference_count(&mut clocks.uart_mem_clk_refcount) {
                trace!("Enabling UART_MEM_CLK");
                request_xtal_clk(clocks);
                enable_uart_mem_clk_impl(clocks, true);
            }
        }
        pub fn release_uart_mem_clk(clocks: &mut ClockTree) {
            trace!("Releasing UART_MEM_CLK");
            if decrement_reference_count(&mut clocks.uart_mem_clk_refcount) {
                trace!("Disabling UART_MEM_CLK");
                enable_uart_mem_clk_impl(clocks, false);
                release_xtal_clk(clocks);
            }
        }
        pub fn uart_mem_clk_frequency(clocks: &mut ClockTree) -> u32 {
            xtal_clk_frequency(clocks)
        }
        pub fn configure_timg0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg0_function_clock.replace(new_selector);
            if clocks.timg0_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::ApbClk => request_apb_clk(clocks),
                }
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::ApbClk => release_apb_clk(clocks),
                    }
                }
            } else {
                configure_timg0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg0_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Timg0FunctionClockConfig> {
            clocks.timg0_function_clock
        }
        pub fn request_timg0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.timg0_function_clock_refcount) {
                trace!("Enabling TIMG0_FUNCTION_CLOCK");
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::ApbClk => request_apb_clk(clocks),
                }
                enable_timg0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_function_clock_refcount) {
                trace!("Disabling TIMG0_FUNCTION_CLOCK");
                enable_timg0_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::ApbClk => release_apb_clk(clocks),
                }
            }
        }
        pub fn timg0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_function_clock) {
                Timg0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::ApbClk => apb_clk_frequency(clocks),
            }
        }
        pub fn configure_timg0_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg0_calibration_clock.replace(new_selector);
            if clocks.timg0_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::RtcClk => request_rtc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::RtcClk => release_rtc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFastDivClk => {
                            release_rc_fast_div_clk(clocks)
                        }
                        Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg0_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg0_calibration_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Timg0CalibrationClockConfig> {
            clocks.timg0_calibration_clock
        }
        pub fn request_timg0_calibration_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG0_CALIBRATION_CLOCK");
            if increment_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                trace!("Enabling TIMG0_CALIBRATION_CLOCK");
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcClk => request_rtc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg0_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg0_calibration_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG0_CALIBRATION_CLOCK");
            if decrement_reference_count(&mut clocks.timg0_calibration_clock_refcount) {
                trace!("Disabling TIMG0_CALIBRATION_CLOCK");
                enable_timg0_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg0_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcClk => release_rtc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => release_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg0_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg0_calibration_clock) {
                Timg0CalibrationClockConfig::RtcClk => rtc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFastDivClk => rc_fast_div_clk_frequency(clocks),
                Timg0CalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0FunctionClockConfig,
        ) {
            let old_selector = clocks.timg1_function_clock.replace(new_selector);
            if clocks.timg1_function_clock_refcount > 0 {
                match new_selector {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::ApbClk => request_apb_clk(clocks),
                }
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                        Timg0FunctionClockConfig::ApbClk => release_apb_clk(clocks),
                    }
                }
            } else {
                configure_timg1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg1_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Timg0FunctionClockConfig> {
            clocks.timg1_function_clock
        }
        pub fn request_timg1_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.timg1_function_clock_refcount) {
                trace!("Enabling TIMG1_FUNCTION_CLOCK");
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => request_xtal_clk(clocks),
                    Timg0FunctionClockConfig::ApbClk => request_apb_clk(clocks),
                }
                enable_timg1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_function_clock_refcount) {
                trace!("Disabling TIMG1_FUNCTION_CLOCK");
                enable_timg1_function_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_function_clock) {
                    Timg0FunctionClockConfig::XtalClk => release_xtal_clk(clocks),
                    Timg0FunctionClockConfig::ApbClk => release_apb_clk(clocks),
                }
            }
        }
        pub fn timg1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_function_clock) {
                Timg0FunctionClockConfig::XtalClk => xtal_clk_frequency(clocks),
                Timg0FunctionClockConfig::ApbClk => apb_clk_frequency(clocks),
            }
        }
        pub fn configure_timg1_calibration_clock(
            clocks: &mut ClockTree,
            new_selector: Timg0CalibrationClockConfig,
        ) {
            let old_selector = clocks.timg1_calibration_clock.replace(new_selector);
            if clocks.timg1_calibration_clock_refcount > 0 {
                match new_selector {
                    Timg0CalibrationClockConfig::RtcClk => request_rtc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Timg0CalibrationClockConfig::RtcClk => release_rtc_slow_clk(clocks),
                        Timg0CalibrationClockConfig::RcFastDivClk => {
                            release_rc_fast_div_clk(clocks)
                        }
                        Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                    }
                }
            } else {
                configure_timg1_calibration_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn timg1_calibration_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Timg0CalibrationClockConfig> {
            clocks.timg1_calibration_clock
        }
        pub fn request_timg1_calibration_clock(clocks: &mut ClockTree) {
            trace!("Requesting TIMG1_CALIBRATION_CLOCK");
            if increment_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                trace!("Enabling TIMG1_CALIBRATION_CLOCK");
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcClk => request_rtc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => request_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => request_xtal32k_clk(clocks),
                }
                enable_timg1_calibration_clock_impl(clocks, true);
            }
        }
        pub fn release_timg1_calibration_clock(clocks: &mut ClockTree) {
            trace!("Releasing TIMG1_CALIBRATION_CLOCK");
            if decrement_reference_count(&mut clocks.timg1_calibration_clock_refcount) {
                trace!("Disabling TIMG1_CALIBRATION_CLOCK");
                enable_timg1_calibration_clock_impl(clocks, false);
                match unwrap!(clocks.timg1_calibration_clock) {
                    Timg0CalibrationClockConfig::RtcClk => release_rtc_slow_clk(clocks),
                    Timg0CalibrationClockConfig::RcFastDivClk => release_rc_fast_div_clk(clocks),
                    Timg0CalibrationClockConfig::Xtal32kClk => release_xtal32k_clk(clocks),
                }
            }
        }
        pub fn timg1_calibration_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.timg1_calibration_clock) {
                Timg0CalibrationClockConfig::RtcClk => rtc_slow_clk_frequency(clocks),
                Timg0CalibrationClockConfig::RcFastDivClk => rc_fast_div_clk_frequency(clocks),
                Timg0CalibrationClockConfig::Xtal32kClk => xtal32k_clk_frequency(clocks),
            }
        }
        pub fn configure_uart0_function_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0FunctionClockConfig,
        ) {
            let old_selector = clocks.uart0_function_clock.replace(new_selector);
            if clocks.uart0_function_clock_refcount > 0 {
                match new_selector {
                    Uart0FunctionClockConfig::Apb => request_apb_clk(clocks),
                    Uart0FunctionClockConfig::RefTick => request_ref_tick(clocks),
                }
                configure_uart0_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Uart0FunctionClockConfig::Apb => release_apb_clk(clocks),
                        Uart0FunctionClockConfig::RefTick => release_ref_tick(clocks),
                    }
                }
            } else {
                configure_uart0_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn uart0_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Uart0FunctionClockConfig> {
            clocks.uart0_function_clock
        }
        pub fn request_uart0_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART0_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.uart0_function_clock_refcount) {
                trace!("Enabling UART0_FUNCTION_CLOCK");
                match unwrap!(clocks.uart0_function_clock) {
                    Uart0FunctionClockConfig::Apb => request_apb_clk(clocks),
                    Uart0FunctionClockConfig::RefTick => request_ref_tick(clocks),
                }
                enable_uart0_function_clock_impl(clocks, true);
            }
        }
        pub fn release_uart0_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART0_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.uart0_function_clock_refcount) {
                trace!("Disabling UART0_FUNCTION_CLOCK");
                enable_uart0_function_clock_impl(clocks, false);
                match unwrap!(clocks.uart0_function_clock) {
                    Uart0FunctionClockConfig::Apb => release_apb_clk(clocks),
                    Uart0FunctionClockConfig::RefTick => release_ref_tick(clocks),
                }
            }
        }
        pub fn uart0_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.uart0_function_clock) {
                Uart0FunctionClockConfig::Apb => apb_clk_frequency(clocks),
                Uart0FunctionClockConfig::RefTick => ref_tick_frequency(clocks),
            }
        }
        pub fn configure_uart0_mem_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0MemClockConfig,
        ) {
            let old_selector = clocks.uart0_mem_clock.replace(new_selector);
            if clocks.uart0_mem_clock_refcount > 0 {
                request_uart_mem_clk(clocks);
                configure_uart0_mem_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    release_uart_mem_clk(clocks);
                }
            } else {
                configure_uart0_mem_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn uart0_mem_clock_config(clocks: &mut ClockTree) -> Option<Uart0MemClockConfig> {
            clocks.uart0_mem_clock
        }
        pub fn request_uart0_mem_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART0_MEM_CLOCK");
            if increment_reference_count(&mut clocks.uart0_mem_clock_refcount) {
                trace!("Enabling UART0_MEM_CLOCK");
                request_uart_mem_clk(clocks);
                enable_uart0_mem_clock_impl(clocks, true);
            }
        }
        pub fn release_uart0_mem_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART0_MEM_CLOCK");
            if decrement_reference_count(&mut clocks.uart0_mem_clock_refcount) {
                trace!("Disabling UART0_MEM_CLOCK");
                enable_uart0_mem_clock_impl(clocks, false);
                release_uart_mem_clk(clocks);
            }
        }
        pub fn uart0_mem_clock_frequency(clocks: &mut ClockTree) -> u32 {
            uart_mem_clk_frequency(clocks)
        }
        pub fn configure_uart1_function_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0FunctionClockConfig,
        ) {
            let old_selector = clocks.uart1_function_clock.replace(new_selector);
            if clocks.uart1_function_clock_refcount > 0 {
                match new_selector {
                    Uart0FunctionClockConfig::Apb => request_apb_clk(clocks),
                    Uart0FunctionClockConfig::RefTick => request_ref_tick(clocks),
                }
                configure_uart1_function_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    match old_selector {
                        Uart0FunctionClockConfig::Apb => release_apb_clk(clocks),
                        Uart0FunctionClockConfig::RefTick => release_ref_tick(clocks),
                    }
                }
            } else {
                configure_uart1_function_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn uart1_function_clock_config(
            clocks: &mut ClockTree,
        ) -> Option<Uart0FunctionClockConfig> {
            clocks.uart1_function_clock
        }
        pub fn request_uart1_function_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART1_FUNCTION_CLOCK");
            if increment_reference_count(&mut clocks.uart1_function_clock_refcount) {
                trace!("Enabling UART1_FUNCTION_CLOCK");
                match unwrap!(clocks.uart1_function_clock) {
                    Uart0FunctionClockConfig::Apb => request_apb_clk(clocks),
                    Uart0FunctionClockConfig::RefTick => request_ref_tick(clocks),
                }
                enable_uart1_function_clock_impl(clocks, true);
            }
        }
        pub fn release_uart1_function_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART1_FUNCTION_CLOCK");
            if decrement_reference_count(&mut clocks.uart1_function_clock_refcount) {
                trace!("Disabling UART1_FUNCTION_CLOCK");
                enable_uart1_function_clock_impl(clocks, false);
                match unwrap!(clocks.uart1_function_clock) {
                    Uart0FunctionClockConfig::Apb => release_apb_clk(clocks),
                    Uart0FunctionClockConfig::RefTick => release_ref_tick(clocks),
                }
            }
        }
        pub fn uart1_function_clock_frequency(clocks: &mut ClockTree) -> u32 {
            match unwrap!(clocks.uart1_function_clock) {
                Uart0FunctionClockConfig::Apb => apb_clk_frequency(clocks),
                Uart0FunctionClockConfig::RefTick => ref_tick_frequency(clocks),
            }
        }
        pub fn configure_uart1_mem_clock(
            clocks: &mut ClockTree,
            new_selector: Uart0MemClockConfig,
        ) {
            let old_selector = clocks.uart1_mem_clock.replace(new_selector);
            if clocks.uart1_mem_clock_refcount > 0 {
                request_uart_mem_clk(clocks);
                configure_uart1_mem_clock_impl(clocks, old_selector, new_selector);
                if let Some(old_selector) = old_selector {
                    release_uart_mem_clk(clocks);
                }
            } else {
                configure_uart1_mem_clock_impl(clocks, old_selector, new_selector);
            }
        }
        pub fn uart1_mem_clock_config(clocks: &mut ClockTree) -> Option<Uart0MemClockConfig> {
            clocks.uart1_mem_clock
        }
        pub fn request_uart1_mem_clock(clocks: &mut ClockTree) {
            trace!("Requesting UART1_MEM_CLOCK");
            if increment_reference_count(&mut clocks.uart1_mem_clock_refcount) {
                trace!("Enabling UART1_MEM_CLOCK");
                request_uart_mem_clk(clocks);
                enable_uart1_mem_clock_impl(clocks, true);
            }
        }
        pub fn release_uart1_mem_clock(clocks: &mut ClockTree) {
            trace!("Releasing UART1_MEM_CLOCK");
            if decrement_reference_count(&mut clocks.uart1_mem_clock_refcount) {
                trace!("Disabling UART1_MEM_CLOCK");
                enable_uart1_mem_clock_impl(clocks, false);
                release_uart_mem_clk(clocks);
            }
        }
        pub fn uart1_mem_clock_frequency(clocks: &mut ClockTree) -> u32 {
            uart_mem_clk_frequency(clocks)
        }
        /// Clock tree configuration.
        ///
        /// The fields of this struct are optional, with the following caveats:
        /// - If `XTAL_CLK` is not specified, the crystal frequency will be automatically detected
        ///   if possible.
        /// - The CPU and its upstream clock nodes will be set to a default configuration.
        /// - Other unspecified clock sources will not be useable by peripherals.
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[instability::unstable]
        pub struct ClockConfig {
            /// `XTAL_CLK` configuration.
            pub xtal_clk: Option<XtalClkConfig>,
            /// `PLL_CLK` configuration.
            pub pll_clk: Option<PllClkConfig>,
            /// `APLL_CLK` configuration.
            pub apll_clk: Option<ApllClkConfig>,
            /// `CPU_PLL_DIV` configuration.
            pub cpu_pll_div: Option<CpuPllDivConfig>,
            /// `SYSTEM_PRE_DIV` configuration.
            pub system_pre_div: Option<SystemPreDivConfig>,
            /// `CPU_CLK` configuration.
            pub cpu_clk: Option<CpuClkConfig>,
            /// `RTC_SLOW_CLK` configuration.
            pub rtc_slow_clk: Option<RtcSlowClkConfig>,
            /// `RTC_FAST_CLK` configuration.
            pub rtc_fast_clk: Option<RtcFastClkConfig>,
        }
        impl ClockConfig {
            fn apply(&self) {
                ClockTree::with(|clocks| {
                    if let Some(config) = self.xtal_clk {
                        configure_xtal_clk(clocks, config);
                    }
                    if let Some(config) = self.pll_clk {
                        configure_pll_clk(clocks, config);
                    }
                    if let Some(config) = self.apll_clk {
                        configure_apll_clk(clocks, config);
                    }
                    if let Some(config) = self.cpu_pll_div {
                        configure_cpu_pll_div(clocks, config);
                    }
                    if let Some(config) = self.system_pre_div {
                        configure_system_pre_div(clocks, config);
                    }
                    if let Some(config) = self.cpu_clk {
                        configure_cpu_clk(clocks, config);
                    }
                    if let Some(config) = self.rtc_slow_clk {
                        configure_rtc_slow_clk(clocks, config);
                    }
                    if let Some(config) = self.rtc_fast_clk {
                        configure_rtc_fast_clk(clocks, config);
                    }
                });
            }
        }
        fn increment_reference_count(refcount: &mut u32) -> bool {
            let first = *refcount == 0;
            *refcount = unwrap!(refcount.checked_add(1), "Reference count overflow");
            first
        }
        fn decrement_reference_count(refcount: &mut u32) -> bool {
            *refcount = refcount.saturating_sub(1);
            let last = *refcount == 0;
            last
        }
    };
}
/// Implement the `Peripheral` enum and enable/disable/reset functions.
///
/// This macro is intended to be placed in `esp_hal::system`.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! implement_peripheral_clocks {
    () => {
        #[doc(hidden)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Peripheral {
            /// AES peripheral clock signal
            Aes,
            /// APB_SAR_ADC peripheral clock signal
            ApbSarAdc,
            /// COPY_DMA peripheral clock signal
            CopyDma,
            /// CRYPTO_DMA peripheral clock signal
            CryptoDma,
            /// DEDICATED_GPIO peripheral clock signal
            DedicatedGpio,
            /// DS peripheral clock signal
            Ds,
            /// HMAC peripheral clock signal
            Hmac,
            /// I2C_EXT0 peripheral clock signal
            I2cExt0,
            /// I2C_EXT1 peripheral clock signal
            I2cExt1,
            /// I2S0 peripheral clock signal
            I2s0,
            /// LEDC peripheral clock signal
            Ledc,
            /// MCPWM0 peripheral clock signal
            Mcpwm0,
            /// MCPWM1 peripheral clock signal
            Mcpwm1,
            /// PCNT peripheral clock signal
            Pcnt,
            /// RMT peripheral clock signal
            Rmt,
            /// RSA peripheral clock signal
            Rsa,
            /// SHA peripheral clock signal
            Sha,
            /// SPI2 peripheral clock signal
            Spi2,
            /// SPI2_DMA peripheral clock signal
            Spi2Dma,
            /// SPI3 peripheral clock signal
            Spi3,
            /// SPI3_DMA peripheral clock signal
            Spi3Dma,
            /// SYSTIMER peripheral clock signal
            Systimer,
            /// TIMG0 peripheral clock signal
            Timg0,
            /// TIMG1 peripheral clock signal
            Timg1,
            /// TWAI0 peripheral clock signal
            Twai0,
            /// UART0 peripheral clock signal
            Uart0,
            /// UART1 peripheral clock signal
            Uart1,
            /// UART_MEM peripheral clock signal
            UartMem,
            /// UHCI0 peripheral clock signal
            Uhci0,
            /// UHCI1 peripheral clock signal
            Uhci1,
            /// USB peripheral clock signal
            Usb,
            /// WDG peripheral clock signal
            Wdg,
        }
        impl Peripheral {
            const KEEP_ENABLED: &[Peripheral] =
                &[Self::Systimer, Self::Timg0, Self::Uart0, Self::UartMem];
            const COUNT: usize = Self::ALL.len();
            const ALL: &[Self] = &[
                Self::Aes,
                Self::ApbSarAdc,
                Self::CopyDma,
                Self::CryptoDma,
                Self::DedicatedGpio,
                Self::Ds,
                Self::Hmac,
                Self::I2cExt0,
                Self::I2cExt1,
                Self::I2s0,
                Self::Ledc,
                Self::Mcpwm0,
                Self::Mcpwm1,
                Self::Pcnt,
                Self::Rmt,
                Self::Rsa,
                Self::Sha,
                Self::Spi2,
                Self::Spi2Dma,
                Self::Spi3,
                Self::Spi3Dma,
                Self::Systimer,
                Self::Timg0,
                Self::Timg1,
                Self::Twai0,
                Self::Uart0,
                Self::Uart1,
                Self::UartMem,
                Self::Uhci0,
                Self::Uhci1,
                Self::Usb,
                Self::Wdg,
            ];
        }
        unsafe fn enable_internal_racey(peripheral: Peripheral, enable: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_aes_clk_en().bit(enable));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.apb_saradc_clk_en().bit(enable));
                }
                Peripheral::CopyDma => {
                    crate::peripherals::DMA_COPY::regs()
                        .conf()
                        .modify(|_, w| w.clk_en().bit(enable));
                }
                Peripheral::CryptoDma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_dma_clk_en().bit(enable));
                }
                Peripheral::DedicatedGpio => {
                    crate::peripherals::SYSTEM::regs()
                        .cpu_peri_clk_en()
                        .modify(|_, w| w.dedicated_gpio_clk_en().bit(enable));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_ds_clk_en().bit(enable));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_hmac_clk_en().bit(enable));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2c_ext0_clk_en().bit(enable));
                }
                Peripheral::I2cExt1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2c_ext1_clk_en().bit(enable));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.i2s0_clk_en().bit(enable));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.ledc_clk_en().bit(enable));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.pwm0_clk_en().bit(enable));
                }
                Peripheral::Mcpwm1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.pwm1_clk_en().bit(enable));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.pcnt_clk_en().bit(enable));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.rmt_clk_en().bit(enable));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_rsa_clk_en().bit(enable));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en1()
                        .modify(|_, w| w.crypto_sha_clk_en().bit(enable));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi2_clk_en().bit(enable));
                }
                Peripheral::Spi2Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi2_dma_clk_en().bit(enable));
                }
                Peripheral::Spi3 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi3_clk_en().bit(enable));
                }
                Peripheral::Spi3Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.spi3_dma_clk_en().bit(enable));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.systimer_clk_en().bit(enable));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.timergroup_clk_en().bit(enable));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.timergroup1_clk_en().bit(enable));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.twai_clk_en().bit(enable));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart_clk_en().bit(enable));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart1_clk_en().bit(enable));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uart_mem_clk_en().bit(enable));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uhci0_clk_en().bit(enable));
                }
                Peripheral::Uhci1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.uhci1_clk_en().bit(enable));
                }
                Peripheral::Usb => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.usb_clk_en().bit(enable));
                }
                Peripheral::Wdg => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_clk_en0()
                        .modify(|_, w| w.wdg_clk_en().bit(enable));
                }
            }
        }
        unsafe fn assert_peri_reset_racey(peripheral: Peripheral, reset: bool) {
            match peripheral {
                Peripheral::Aes => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_aes_rst().bit(reset));
                }
                Peripheral::ApbSarAdc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.apb_saradc_rst().bit(reset));
                }
                Peripheral::CopyDma => {
                    crate::peripherals::DMA_COPY::regs().conf().modify(|_, w| {
                        w.in_rst()
                            .bit(reset)
                            .out_rst()
                            .bit(reset)
                            .cmdfifo_rst()
                            .bit(reset)
                            .fifo_rst()
                            .bit(reset)
                    });
                }
                Peripheral::CryptoDma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_dma_rst().bit(reset));
                }
                Peripheral::DedicatedGpio => {
                    crate::peripherals::SYSTEM::regs()
                        .cpu_peri_rst_en()
                        .modify(|_, w| w.dedicated_gpio_rst().bit(reset));
                }
                Peripheral::Ds => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_ds_rst().bit(reset));
                }
                Peripheral::Hmac => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_hmac_rst().bit(reset));
                }
                Peripheral::I2cExt0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2c_ext0_rst().bit(reset));
                }
                Peripheral::I2cExt1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2c_ext1_rst().bit(reset));
                }
                Peripheral::I2s0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.i2s0_rst().bit(reset));
                }
                Peripheral::Ledc => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.ledc_rst().bit(reset));
                }
                Peripheral::Mcpwm0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.pwm0_rst().bit(reset));
                }
                Peripheral::Mcpwm1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.pwm1_rst().bit(reset));
                }
                Peripheral::Pcnt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.pcnt_rst().bit(reset));
                }
                Peripheral::Rmt => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.rmt_rst().bit(reset));
                }
                Peripheral::Rsa => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_rsa_rst().bit(reset));
                }
                Peripheral::Sha => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en1()
                        .modify(|_, w| w.crypto_sha_rst().bit(reset));
                }
                Peripheral::Spi2 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi2_rst().bit(reset));
                }
                Peripheral::Spi2Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi2_dma_rst().bit(reset));
                }
                Peripheral::Spi3 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi3_rst().bit(reset));
                }
                Peripheral::Spi3Dma => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.spi3_dma_rst().bit(reset));
                }
                Peripheral::Systimer => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.systimer_rst().bit(reset));
                }
                Peripheral::Timg0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.timergroup_rst().bit(reset));
                }
                Peripheral::Timg1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.timergroup1_rst().bit(reset));
                }
                Peripheral::Twai0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.twai_rst().bit(reset));
                }
                Peripheral::Uart0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart_rst().bit(reset));
                }
                Peripheral::Uart1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart1_rst().bit(reset));
                }
                Peripheral::UartMem => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uart_mem_rst().bit(reset));
                }
                Peripheral::Uhci0 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uhci0_rst().bit(reset));
                }
                Peripheral::Uhci1 => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.uhci1_rst().bit(reset));
                }
                Peripheral::Usb => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.usb_rst().bit(reset));
                }
                Peripheral::Wdg => {
                    crate::peripherals::SYSTEM::regs()
                        .perip_rst_en0()
                        .modify(|_, w| w.wdg_rst().bit(reset));
                }
            }
        }
    };
}
/// Macro to get the address range of the given memory region.
///
/// This macro provides two syntax options for each memory region:
///
/// - `memory_range!("region_name")` returns the address range as a range expression (`start..end`).
/// - `memory_range!(size as str, "region_name")` returns the size of the region as a string
///   literal.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        0x3FFB0000..0x40000000
    };
    (size as str, "DRAM") => {
        "327680"
    };
    ("DRAM2_UNINIT") => {
        0x3FFDE000..0x40000000
    };
    (size as str, "DRAM2_UNINIT") => {
        "139264"
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($id:literal, $instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
/// - `$id`: the index of the I2C instance
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(0, I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_i2c_master { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_i2c_master!((0, I2C0, I2cExt0, I2CEXT0_SCL,
        I2CEXT0_SDA)); _for_each_inner_i2c_master!((1, I2C1, I2cExt1, I2CEXT1_SCL,
        I2CEXT1_SDA)); _for_each_inner_i2c_master!((all(0, I2C0, I2cExt0, I2CEXT0_SCL,
        I2CEXT0_SDA), (1, I2C1, I2cExt1, I2CEXT1_SCL, I2CEXT1_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($id:literal, $instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident,
/// $rts:ident)`
///
/// Macro fragments:
///
/// - `$id`: the index of the UART instance
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(0, UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_uart { $(($pattern) => $code;)* ($other : tt) => {}
        } _for_each_inner_uart!((0, UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner_uart!((1, UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner_uart!((all(0, UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (1,
        UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident [$($cs:ident),*] [$($sio:ident),*]
/// $($is_qspi:literal)?)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_spi_master { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_spi_master!((SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1,
        FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD, FSPIIO4,
        FSPIIO5, FSPIIO6, FSPIIO7], true)); _for_each_inner_spi_master!((SPI3, Spi3,
        SPI3_CLK[SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q]));
        _for_each_inner_spi_master!((all(SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2,
        FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD, FSPIIO4, FSPIIO5,
        FSPIIO6, FSPIIO7], true), (SPI3, Spi3, SPI3_CLK[SPI3_CS0, SPI3_CS1, SPI3_CS2]
        [SPI3_D, SPI3_Q])));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$sclk`, `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_spi_slave { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_spi_slave!((SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0));
        _for_each_inner_spi_slave!((SPI3, Spi3, SPI3_CLK, SPI3_D, SPI3_Q, SPI3_CS0));
        _for_each_inner_spi_slave!((all(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0),
        (SPI3, Spi3, SPI3_CLK, SPI3_D, SPI3_Q, SPI3_CS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_peripheral { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO0 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO0 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO1 peripheral singleton"]
        GPIO1 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO2 peripheral singleton"] GPIO2 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO3 peripheral singleton"]
        GPIO3 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO4 peripheral singleton"] GPIO4 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO5 peripheral singleton"]
        GPIO5 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO6 peripheral singleton"] GPIO6 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO7 peripheral singleton"]
        GPIO7 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO8 peripheral singleton"] GPIO8 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO9 peripheral singleton"]
        GPIO9 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO10 peripheral singleton"] GPIO10 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO11 peripheral singleton"]
        GPIO11 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO12 peripheral singleton"] GPIO12 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO13 peripheral singleton"]
        GPIO13 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO14 peripheral singleton"] GPIO14 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO15 peripheral singleton"]
        GPIO15 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO16 peripheral singleton"] GPIO16 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO17 peripheral singleton"]
        GPIO17 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO18 peripheral singleton"] GPIO18 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO19 peripheral singleton"]
        GPIO19 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO20 peripheral singleton"] GPIO20 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO21 peripheral singleton"]
        GPIO21 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO26 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO26 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO27 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO27 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO28 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO28 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO29 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO29 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO30 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO30 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO31 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO31 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO32 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO32 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO33 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO33 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO34 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO34 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO35 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO35 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO36 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO36 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO37 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO37 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO38 peripheral singleton"]
        GPIO38 <= virtual())); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO39 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO39 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO40 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO40 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO41 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO41 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO42 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO42 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO43 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO43 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO44 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO44 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO45 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO45 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO46 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO46 <= virtual()));
        _for_each_inner_peripheral!((@ peri_type #[doc = "AES peripheral singleton"] AES
        <= AES(AES : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }) (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "APB_SARADC peripheral singleton"] APB_SARADC <= APB_SARADC() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "DEDICATED_GPIO peripheral singleton"] DEDICATED_GPIO <= DEDICATED_GPIO()
        (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "DS peripheral singleton"] DS <= DS() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "EFUSE peripheral singleton"]
        EFUSE <= EFUSE() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "EXTMEM peripheral singleton"] EXTMEM <= EXTMEM() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "FE peripheral singleton"] FE <=
        FE() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "FE2 peripheral singleton"] FE2 <= FE2() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "GPIO peripheral singleton"]
        GPIO <= GPIO() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO_SD peripheral singleton"] GPIO_SD <= GPIO_SD() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "HMAC peripheral singleton"]
        HMAC <= HMAC() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "I2C_ANA_MST peripheral singleton"] I2C_ANA_MST <= I2C_ANA_MST() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "I2C0 peripheral singleton"]
        I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "I2C1 peripheral singleton"] I2C1 <= I2C1(I2C_EXT1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner_peripheral!((@ peri_type #[doc = "I2S0 peripheral singleton"]
        I2S0 <= I2S0(I2S0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }) (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "INTERRUPT_CORE0 peripheral singleton"] INTERRUPT_CORE0 <=
        INTERRUPT_CORE0() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "IO_MUX peripheral singleton"] IO_MUX <= IO_MUX() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "LEDC peripheral singleton"]
        LEDC <= LEDC() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "NRX peripheral singleton"] NRX <= NRX() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "PCNT peripheral singleton"]
        PCNT <= PCNT() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "PMS peripheral singleton"] PMS <= PMS() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "RMT peripheral singleton"] RMT
        <= RMT() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "RNG peripheral singleton"] RNG <= RNG() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "RSA peripheral singleton"] RSA
        <= RSA(RSA : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        }) (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "LPWR peripheral singleton"] LPWR <= RTC_CNTL() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "RTC_I2C peripheral singleton"]
        RTC_I2C <= RTC_I2C() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc
        = "RTC_IO peripheral singleton"] RTC_IO <= RTC_IO() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SENS peripheral singleton"]
        SENS <= SENS() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SHA peripheral singleton"] SHA <= SHA(SHA : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SPI0 peripheral singleton"]
        SPI0 <= SPI0() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SPI1 peripheral singleton"] SPI1 <= SPI1() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SPI2 peripheral singleton"]
        SPI2 <= SPI2(SPI2_DMA : { bind_dma_interrupt, enable_dma_interrupt,
        disable_dma_interrupt }, SPI2 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SPI3 peripheral singleton"] SPI3 <= SPI3(SPI3_DMA : { bind_dma_interrupt,
        enable_dma_interrupt, disable_dma_interrupt }, SPI3 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SYSCON peripheral singleton"]
        SYSCON <= SYSCON() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SYSTEM peripheral singleton"] SYSTEM <= SYSTEM() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "SYSTIMER peripheral singleton"]
        SYSTIMER <= SYSTIMER() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "TIMG0 peripheral singleton"] TIMG0 <= TIMG0() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "TIMG1 peripheral singleton"]
        TIMG1 <= TIMG1() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "TWAI0 peripheral singleton"] TWAI0 <= TWAI0() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "UART0 peripheral singleton"]
        UART0 <= UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "UART1 peripheral singleton"] UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })));
        _for_each_inner_peripheral!((@ peri_type #[doc = "UHCI0 peripheral singleton"]
        UHCI0 <= UHCI0() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "USB0 peripheral singleton"] USB0 <= USB0() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "USB_WRAP peripheral singleton"]
        USB_WRAP <= USB_WRAP() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "XTS_AES peripheral singleton"] XTS_AES <= XTS_AES() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "WIFI peripheral singleton"]
        WIFI <= WIFI(WIFI_MAC : { bind_mac_interrupt, enable_mac_interrupt,
        disable_mac_interrupt }, WIFI_PWR : { bind_pwr_interrupt, enable_pwr_interrupt,
        disable_pwr_interrupt }))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "DMA_SPI2 peripheral singleton"] DMA_SPI2 <= SPI2() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "DMA_SPI3 peripheral singleton"]
        DMA_SPI3 <= SPI3() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "DMA_I2S0 peripheral singleton"] DMA_I2S0 <= I2S0() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "DMA_CRYPTO peripheral singleton"] DMA_CRYPTO <= CRYPTO_DMA() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "DMA_COPY peripheral singleton"]
        DMA_COPY <= COPY_DMA() (unstable))); _for_each_inner_peripheral!((@ peri_type
        #[doc = "ADC1 peripheral singleton"] ADC1 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "ADC2 peripheral singleton"]
        ADC2 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "DAC1 peripheral singleton"] DAC1 <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "DAC2 peripheral singleton"]
        DAC2 <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "FLASH peripheral singleton"] FLASH <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "GPIO_DEDICATED peripheral singleton"] GPIO_DEDICATED <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc = "PSRAM peripheral singleton"]
        PSRAM <= virtual() (unstable))); _for_each_inner_peripheral!((@ peri_type #[doc =
        "SW_INTERRUPT peripheral singleton"] SW_INTERRUPT <= virtual() (unstable)));
        _for_each_inner_peripheral!((@ peri_type #[doc =
        "ULP_RISCV_CORE peripheral singleton"] ULP_RISCV_CORE <= virtual() (unstable)));
        _for_each_inner_peripheral!((GPIO0)); _for_each_inner_peripheral!((GPIO1));
        _for_each_inner_peripheral!((GPIO2)); _for_each_inner_peripheral!((GPIO3));
        _for_each_inner_peripheral!((GPIO4)); _for_each_inner_peripheral!((GPIO5));
        _for_each_inner_peripheral!((GPIO6)); _for_each_inner_peripheral!((GPIO7));
        _for_each_inner_peripheral!((GPIO8)); _for_each_inner_peripheral!((GPIO9));
        _for_each_inner_peripheral!((GPIO10)); _for_each_inner_peripheral!((GPIO11));
        _for_each_inner_peripheral!((GPIO12)); _for_each_inner_peripheral!((GPIO13));
        _for_each_inner_peripheral!((GPIO14)); _for_each_inner_peripheral!((GPIO15));
        _for_each_inner_peripheral!((GPIO16)); _for_each_inner_peripheral!((GPIO17));
        _for_each_inner_peripheral!((GPIO18)); _for_each_inner_peripheral!((GPIO19));
        _for_each_inner_peripheral!((GPIO20)); _for_each_inner_peripheral!((GPIO21));
        _for_each_inner_peripheral!((GPIO26)); _for_each_inner_peripheral!((GPIO27));
        _for_each_inner_peripheral!((GPIO28)); _for_each_inner_peripheral!((GPIO29));
        _for_each_inner_peripheral!((GPIO30)); _for_each_inner_peripheral!((GPIO31));
        _for_each_inner_peripheral!((GPIO32)); _for_each_inner_peripheral!((GPIO33));
        _for_each_inner_peripheral!((GPIO34)); _for_each_inner_peripheral!((GPIO35));
        _for_each_inner_peripheral!((GPIO36)); _for_each_inner_peripheral!((GPIO37));
        _for_each_inner_peripheral!((GPIO38)); _for_each_inner_peripheral!((GPIO39));
        _for_each_inner_peripheral!((GPIO40)); _for_each_inner_peripheral!((GPIO41));
        _for_each_inner_peripheral!((GPIO42)); _for_each_inner_peripheral!((GPIO43));
        _for_each_inner_peripheral!((GPIO44)); _for_each_inner_peripheral!((GPIO45));
        _for_each_inner_peripheral!((GPIO46));
        _for_each_inner_peripheral!((AES(unstable)));
        _for_each_inner_peripheral!((APB_SARADC(unstable)));
        _for_each_inner_peripheral!((DEDICATED_GPIO(unstable)));
        _for_each_inner_peripheral!((DS(unstable)));
        _for_each_inner_peripheral!((EXTMEM(unstable)));
        _for_each_inner_peripheral!((FE(unstable)));
        _for_each_inner_peripheral!((FE2(unstable)));
        _for_each_inner_peripheral!((GPIO(unstable)));
        _for_each_inner_peripheral!((GPIO_SD(unstable)));
        _for_each_inner_peripheral!((HMAC(unstable)));
        _for_each_inner_peripheral!((I2C_ANA_MST(unstable)));
        _for_each_inner_peripheral!((I2C0)); _for_each_inner_peripheral!((I2C1));
        _for_each_inner_peripheral!((I2S0(unstable)));
        _for_each_inner_peripheral!((INTERRUPT_CORE0(unstable)));
        _for_each_inner_peripheral!((IO_MUX(unstable)));
        _for_each_inner_peripheral!((LEDC(unstable)));
        _for_each_inner_peripheral!((NRX(unstable)));
        _for_each_inner_peripheral!((PCNT(unstable)));
        _for_each_inner_peripheral!((PMS(unstable)));
        _for_each_inner_peripheral!((RMT(unstable)));
        _for_each_inner_peripheral!((RNG(unstable)));
        _for_each_inner_peripheral!((RSA(unstable)));
        _for_each_inner_peripheral!((LPWR(unstable)));
        _for_each_inner_peripheral!((RTC_I2C(unstable)));
        _for_each_inner_peripheral!((RTC_IO(unstable)));
        _for_each_inner_peripheral!((SENS(unstable)));
        _for_each_inner_peripheral!((SHA(unstable)));
        _for_each_inner_peripheral!((SPI0(unstable)));
        _for_each_inner_peripheral!((SPI1(unstable)));
        _for_each_inner_peripheral!((SPI2)); _for_each_inner_peripheral!((SPI3));
        _for_each_inner_peripheral!((SYSCON(unstable)));
        _for_each_inner_peripheral!((SYSTEM(unstable)));
        _for_each_inner_peripheral!((SYSTIMER(unstable)));
        _for_each_inner_peripheral!((TIMG0(unstable)));
        _for_each_inner_peripheral!((TIMG1(unstable)));
        _for_each_inner_peripheral!((TWAI0(unstable)));
        _for_each_inner_peripheral!((UART0)); _for_each_inner_peripheral!((UART1));
        _for_each_inner_peripheral!((UHCI0(unstable)));
        _for_each_inner_peripheral!((USB0(unstable)));
        _for_each_inner_peripheral!((USB_WRAP(unstable)));
        _for_each_inner_peripheral!((XTS_AES(unstable)));
        _for_each_inner_peripheral!((WIFI));
        _for_each_inner_peripheral!((DMA_SPI2(unstable)));
        _for_each_inner_peripheral!((DMA_SPI3(unstable)));
        _for_each_inner_peripheral!((DMA_I2S0(unstable)));
        _for_each_inner_peripheral!((DMA_CRYPTO(unstable)));
        _for_each_inner_peripheral!((DMA_COPY(unstable)));
        _for_each_inner_peripheral!((ADC1(unstable)));
        _for_each_inner_peripheral!((ADC2(unstable)));
        _for_each_inner_peripheral!((DAC1(unstable)));
        _for_each_inner_peripheral!((DAC2(unstable)));
        _for_each_inner_peripheral!((FLASH(unstable)));
        _for_each_inner_peripheral!((GPIO_DEDICATED(unstable)));
        _for_each_inner_peripheral!((PSRAM(unstable)));
        _for_each_inner_peripheral!((SW_INTERRUPT(unstable)));
        _for_each_inner_peripheral!((ULP_RISCV_CORE(unstable)));
        _for_each_inner_peripheral!((I2S0, I2s0, 0)); _for_each_inner_peripheral!((SPI2,
        Spi2, 1)); _for_each_inner_peripheral!((SPI3, Spi3, 2));
        _for_each_inner_peripheral!((UHCI0, Uhci0, 3)); _for_each_inner_peripheral!((AES,
        Aes, 4)); _for_each_inner_peripheral!((SHA, Sha, 5));
        _for_each_inner_peripheral!((all(@ peri_type #[doc =
        "GPIO0 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO0 <= virtual()), (@ peri_type #[doc =
        "GPIO1 peripheral singleton"] GPIO1 <= virtual()), (@ peri_type #[doc =
        "GPIO2 peripheral singleton"] GPIO2 <= virtual()), (@ peri_type #[doc =
        "GPIO3 peripheral singleton"] GPIO3 <= virtual()), (@ peri_type #[doc =
        "GPIO4 peripheral singleton"] GPIO4 <= virtual()), (@ peri_type #[doc =
        "GPIO5 peripheral singleton"] GPIO5 <= virtual()), (@ peri_type #[doc =
        "GPIO6 peripheral singleton"] GPIO6 <= virtual()), (@ peri_type #[doc =
        "GPIO7 peripheral singleton"] GPIO7 <= virtual()), (@ peri_type #[doc =
        "GPIO8 peripheral singleton"] GPIO8 <= virtual()), (@ peri_type #[doc =
        "GPIO9 peripheral singleton"] GPIO9 <= virtual()), (@ peri_type #[doc =
        "GPIO10 peripheral singleton"] GPIO10 <= virtual()), (@ peri_type #[doc =
        "GPIO11 peripheral singleton"] GPIO11 <= virtual()), (@ peri_type #[doc =
        "GPIO12 peripheral singleton"] GPIO12 <= virtual()), (@ peri_type #[doc =
        "GPIO13 peripheral singleton"] GPIO13 <= virtual()), (@ peri_type #[doc =
        "GPIO14 peripheral singleton"] GPIO14 <= virtual()), (@ peri_type #[doc =
        "GPIO15 peripheral singleton"] GPIO15 <= virtual()), (@ peri_type #[doc =
        "GPIO16 peripheral singleton"] GPIO16 <= virtual()), (@ peri_type #[doc =
        "GPIO17 peripheral singleton"] GPIO17 <= virtual()), (@ peri_type #[doc =
        "GPIO18 peripheral singleton"] GPIO18 <= virtual()), (@ peri_type #[doc =
        "GPIO19 peripheral singleton"] GPIO19 <= virtual()), (@ peri_type #[doc =
        "GPIO20 peripheral singleton"] GPIO20 <= virtual()), (@ peri_type #[doc =
        "GPIO21 peripheral singleton"] GPIO21 <= virtual()), (@ peri_type #[doc =
        "GPIO26 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO26 <= virtual()), (@ peri_type #[doc =
        "GPIO27 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO27 <= virtual()), (@ peri_type #[doc =
        "GPIO28 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO28 <= virtual()), (@ peri_type #[doc =
        "GPIO29 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO29 <= virtual()), (@ peri_type #[doc =
        "GPIO30 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO30 <= virtual()), (@ peri_type #[doc =
        "GPIO31 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO31 <= virtual()), (@ peri_type #[doc =
        "GPIO32 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI flash.</li>"] #[doc =
        "<li>This pin may be reserved for interfacing with SPI PSRAM.</li>"] #[doc =
        "</ul>"] #[doc = "</section>"] GPIO32 <= virtual()), (@ peri_type #[doc =
        "GPIO33 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO33 <= virtual()), (@ peri_type #[doc =
        "GPIO34 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO34 <= virtual()), (@ peri_type #[doc =
        "GPIO35 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO35 <= virtual()), (@ peri_type #[doc =
        "GPIO36 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO36 <= virtual()), (@ peri_type #[doc =
        "GPIO37 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin may be reserved for interfacing with Octal SPI flash.</li>"] #[doc
        = "<li>This pin may be reserved for interfacing with Octal SPI PSRAM.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO37 <= virtual()), (@ peri_type #[doc =
        "GPIO38 peripheral singleton"] GPIO38 <= virtual()), (@ peri_type #[doc =
        "GPIO39 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO39 <= virtual()), (@ peri_type #[doc =
        "GPIO40 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO40 <= virtual()), (@ peri_type #[doc =
        "GPIO41 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO41 <= virtual()), (@ peri_type #[doc =
        "GPIO42 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>These pins may be used to debug the chip using an external JTAG debugger.</li>"]
        #[doc = "</ul>"] #[doc = "</section>"] GPIO42 <= virtual()), (@ peri_type #[doc =
        "GPIO43 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO43 <= virtual()), (@ peri_type #[doc =
        "GPIO44 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>By default, this pin is used by the UART programming interface.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO44 <= virtual()), (@ peri_type #[doc =
        "GPIO45 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO45 <= virtual()), (@ peri_type #[doc =
        "GPIO46 peripheral singleton (Limitations exist)"] #[doc = ""] #[doc =
        "<section class=\"warning\">"] #[doc =
        "This pin may be available with certain limitations. Check your hardware to make sure whether you can use it."]
        #[doc = "<ul>"] #[doc =
        "<li>This pin is a strapping pin, it determines how the chip boots.</li>"] #[doc
        = "</ul>"] #[doc = "</section>"] GPIO46 <= virtual()), (@ peri_type #[doc =
        "AES peripheral singleton"] AES <= AES(AES : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type #[doc
        = "APB_SARADC peripheral singleton"] APB_SARADC <= APB_SARADC() (unstable)), (@
        peri_type #[doc = "DEDICATED_GPIO peripheral singleton"] DEDICATED_GPIO <=
        DEDICATED_GPIO() (unstable)), (@ peri_type #[doc = "DS peripheral singleton"] DS
        <= DS() (unstable)), (@ peri_type #[doc = "EFUSE peripheral singleton"] EFUSE <=
        EFUSE() (unstable)), (@ peri_type #[doc = "EXTMEM peripheral singleton"] EXTMEM
        <= EXTMEM() (unstable)), (@ peri_type #[doc = "FE peripheral singleton"] FE <=
        FE() (unstable)), (@ peri_type #[doc = "FE2 peripheral singleton"] FE2 <= FE2()
        (unstable)), (@ peri_type #[doc = "GPIO peripheral singleton"] GPIO <= GPIO()
        (unstable)), (@ peri_type #[doc = "GPIO_SD peripheral singleton"] GPIO_SD <=
        GPIO_SD() (unstable)), (@ peri_type #[doc = "HMAC peripheral singleton"] HMAC <=
        HMAC() (unstable)), (@ peri_type #[doc = "I2C_ANA_MST peripheral singleton"]
        I2C_ANA_MST <= I2C_ANA_MST() (unstable)), (@ peri_type #[doc =
        "I2C0 peripheral singleton"] I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type #[doc =
        "I2C1 peripheral singleton"] I2C1 <= I2C1(I2C_EXT1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (@ peri_type #[doc =
        "I2S0 peripheral singleton"] I2S0 <= I2S0(I2S0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }) (unstable)), (@ peri_type #[doc
        = "INTERRUPT_CORE0 peripheral singleton"] INTERRUPT_CORE0 <= INTERRUPT_CORE0()
        (unstable)), (@ peri_type #[doc = "IO_MUX peripheral singleton"] IO_MUX <=
        IO_MUX() (unstable)), (@ peri_type #[doc = "LEDC peripheral singleton"] LEDC <=
        LEDC() (unstable)), (@ peri_type #[doc = "NRX peripheral singleton"] NRX <= NRX()
        (unstable)), (@ peri_type #[doc = "PCNT peripheral singleton"] PCNT <= PCNT()
        (unstable)), (@ peri_type #[doc = "PMS peripheral singleton"] PMS <= PMS()
        (unstable)), (@ peri_type #[doc = "RMT peripheral singleton"] RMT <= RMT()
        (unstable)), (@ peri_type #[doc = "RNG peripheral singleton"] RNG <= RNG()
        (unstable)), (@ peri_type #[doc = "RSA peripheral singleton"] RSA <= RSA(RSA : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "LPWR peripheral singleton"] LPWR <= RTC_CNTL()
        (unstable)), (@ peri_type #[doc = "RTC_I2C peripheral singleton"] RTC_I2C <=
        RTC_I2C() (unstable)), (@ peri_type #[doc = "RTC_IO peripheral singleton"] RTC_IO
        <= RTC_IO() (unstable)), (@ peri_type #[doc = "SENS peripheral singleton"] SENS
        <= SENS() (unstable)), (@ peri_type #[doc = "SHA peripheral singleton"] SHA <=
        SHA(SHA : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })
        (unstable)), (@ peri_type #[doc = "SPI0 peripheral singleton"] SPI0 <= SPI0()
        (unstable)), (@ peri_type #[doc = "SPI1 peripheral singleton"] SPI1 <= SPI1()
        (unstable)), (@ peri_type #[doc = "SPI2 peripheral singleton"] SPI2 <=
        SPI2(SPI2_DMA : { bind_dma_interrupt, enable_dma_interrupt, disable_dma_interrupt
        }, SPI2 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        })), (@ peri_type #[doc = "SPI3 peripheral singleton"] SPI3 <= SPI3(SPI3_DMA : {
        bind_dma_interrupt, enable_dma_interrupt, disable_dma_interrupt }, SPI3 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (@
        peri_type #[doc = "SYSCON peripheral singleton"] SYSCON <= SYSCON() (unstable)),
        (@ peri_type #[doc = "SYSTEM peripheral singleton"] SYSTEM <= SYSTEM()
        (unstable)), (@ peri_type #[doc = "SYSTIMER peripheral singleton"] SYSTIMER <=
        SYSTIMER() (unstable)), (@ peri_type #[doc = "TIMG0 peripheral singleton"] TIMG0
        <= TIMG0() (unstable)), (@ peri_type #[doc = "TIMG1 peripheral singleton"] TIMG1
        <= TIMG1() (unstable)), (@ peri_type #[doc = "TWAI0 peripheral singleton"] TWAI0
        <= TWAI0() (unstable)), (@ peri_type #[doc = "UART0 peripheral singleton"] UART0
        <= UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type #[doc = "UART1 peripheral singleton"]
        UART1 <= UART1(UART1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (@ peri_type #[doc = "UHCI0 peripheral singleton"]
        UHCI0 <= UHCI0() (unstable)), (@ peri_type #[doc = "USB0 peripheral singleton"]
        USB0 <= USB0() (unstable)), (@ peri_type #[doc = "USB_WRAP peripheral singleton"]
        USB_WRAP <= USB_WRAP() (unstable)), (@ peri_type #[doc =
        "XTS_AES peripheral singleton"] XTS_AES <= XTS_AES() (unstable)), (@ peri_type
        #[doc = "WIFI peripheral singleton"] WIFI <= WIFI(WIFI_MAC : {
        bind_mac_interrupt, enable_mac_interrupt, disable_mac_interrupt }, WIFI_PWR : {
        bind_pwr_interrupt, enable_pwr_interrupt, disable_pwr_interrupt })), (@ peri_type
        #[doc = "DMA_SPI2 peripheral singleton"] DMA_SPI2 <= SPI2() (unstable)), (@
        peri_type #[doc = "DMA_SPI3 peripheral singleton"] DMA_SPI3 <= SPI3()
        (unstable)), (@ peri_type #[doc = "DMA_I2S0 peripheral singleton"] DMA_I2S0 <=
        I2S0() (unstable)), (@ peri_type #[doc = "DMA_CRYPTO peripheral singleton"]
        DMA_CRYPTO <= CRYPTO_DMA() (unstable)), (@ peri_type #[doc =
        "DMA_COPY peripheral singleton"] DMA_COPY <= COPY_DMA() (unstable)), (@ peri_type
        #[doc = "ADC1 peripheral singleton"] ADC1 <= virtual() (unstable)), (@ peri_type
        #[doc = "ADC2 peripheral singleton"] ADC2 <= virtual() (unstable)), (@ peri_type
        #[doc = "DAC1 peripheral singleton"] DAC1 <= virtual() (unstable)), (@ peri_type
        #[doc = "DAC2 peripheral singleton"] DAC2 <= virtual() (unstable)), (@ peri_type
        #[doc = "FLASH peripheral singleton"] FLASH <= virtual() (unstable)), (@
        peri_type #[doc = "GPIO_DEDICATED peripheral singleton"] GPIO_DEDICATED <=
        virtual() (unstable)), (@ peri_type #[doc = "PSRAM peripheral singleton"] PSRAM
        <= virtual() (unstable)), (@ peri_type #[doc =
        "SW_INTERRUPT peripheral singleton"] SW_INTERRUPT <= virtual() (unstable)), (@
        peri_type #[doc = "ULP_RISCV_CORE peripheral singleton"] ULP_RISCV_CORE <=
        virtual() (unstable)))); _for_each_inner_peripheral!((singletons(GPIO0), (GPIO1),
        (GPIO2), (GPIO3), (GPIO4), (GPIO5), (GPIO6), (GPIO7), (GPIO8), (GPIO9), (GPIO10),
        (GPIO11), (GPIO12), (GPIO13), (GPIO14), (GPIO15), (GPIO16), (GPIO17), (GPIO18),
        (GPIO19), (GPIO20), (GPIO21), (GPIO26), (GPIO27), (GPIO28), (GPIO29), (GPIO30),
        (GPIO31), (GPIO32), (GPIO33), (GPIO34), (GPIO35), (GPIO36), (GPIO37), (GPIO38),
        (GPIO39), (GPIO40), (GPIO41), (GPIO42), (GPIO43), (GPIO44), (GPIO45), (GPIO46),
        (AES(unstable)), (APB_SARADC(unstable)), (DEDICATED_GPIO(unstable)),
        (DS(unstable)), (EXTMEM(unstable)), (FE(unstable)), (FE2(unstable)),
        (GPIO(unstable)), (GPIO_SD(unstable)), (HMAC(unstable)), (I2C_ANA_MST(unstable)),
        (I2C0), (I2C1), (I2S0(unstable)), (INTERRUPT_CORE0(unstable)),
        (IO_MUX(unstable)), (LEDC(unstable)), (NRX(unstable)), (PCNT(unstable)),
        (PMS(unstable)), (RMT(unstable)), (RNG(unstable)), (RSA(unstable)),
        (LPWR(unstable)), (RTC_I2C(unstable)), (RTC_IO(unstable)), (SENS(unstable)),
        (SHA(unstable)), (SPI0(unstable)), (SPI1(unstable)), (SPI2), (SPI3),
        (SYSCON(unstable)), (SYSTEM(unstable)), (SYSTIMER(unstable)), (TIMG0(unstable)),
        (TIMG1(unstable)), (TWAI0(unstable)), (UART0), (UART1), (UHCI0(unstable)),
        (USB0(unstable)), (USB_WRAP(unstable)), (XTS_AES(unstable)), (WIFI),
        (DMA_SPI2(unstable)), (DMA_SPI3(unstable)), (DMA_I2S0(unstable)),
        (DMA_CRYPTO(unstable)), (DMA_COPY(unstable)), (ADC1(unstable)), (ADC2(unstable)),
        (DAC1(unstable)), (DAC2(unstable)), (FLASH(unstable)),
        (GPIO_DEDICATED(unstable)), (PSRAM(unstable)), (SW_INTERRUPT(unstable)),
        (ULP_RISCV_CORE(unstable)))); _for_each_inner_peripheral!((dma_eligible(I2S0,
        I2s0, 0), (SPI2, Spi2, 1), (SPI3, Spi3, 2), (UHCI0, Uhci0, 3), (AES, Aes, 4),
        (SHA, Sha, 5)));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_gpio { $(($pattern) => $code;)* ($other : tt) => {}
        } _for_each_inner_gpio!((0, GPIO0() () ([Input] [Output])));
        _for_each_inner_gpio!((1, GPIO1() () ([Input] [Output])));
        _for_each_inner_gpio!((2, GPIO2() () ([Input] [Output])));
        _for_each_inner_gpio!((3, GPIO3() () ([Input] [Output])));
        _for_each_inner_gpio!((4, GPIO4() () ([Input] [Output])));
        _for_each_inner_gpio!((5, GPIO5() () ([Input] [Output])));
        _for_each_inner_gpio!((6, GPIO6() () ([Input] [Output])));
        _for_each_inner_gpio!((7, GPIO7() () ([Input] [Output])));
        _for_each_inner_gpio!((8, GPIO8() (_3 => SUBSPICS1) ([Input] [Output])));
        _for_each_inner_gpio!((9, GPIO9(_3 => SUBSPIHD _4 => FSPIHD) (_3 => SUBSPIHD _4
        => FSPIHD) ([Input] [Output]))); _for_each_inner_gpio!((10, GPIO10(_2 => FSPIIO4
        _4 => FSPICS0) (_2 => FSPIIO4 _3 => SUBSPICS0 _4 => FSPICS0) ([Input]
        [Output]))); _for_each_inner_gpio!((11, GPIO11(_2 => FSPIIO5 _3 => SUBSPID _4 =>
        FSPID) (_2 => FSPIIO5 _3 => SUBSPID _4 => FSPID) ([Input] [Output])));
        _for_each_inner_gpio!((12, GPIO12(_2 => FSPIIO6 _4 => FSPICLK) (_2 => FSPIIO6 _3
        => SUBSPICLK _4 => FSPICLK) ([Input] [Output]))); _for_each_inner_gpio!((13,
        GPIO13(_2 => FSPIIO7 _3 => SUBSPIQ _4 => FSPIQ) (_2 => FSPIIO7 _3 => SUBSPIQ _4
        => FSPIQ) ([Input] [Output]))); _for_each_inner_gpio!((14, GPIO14(_3 => SUBSPIWP
        _4 => FSPIWP) (_2 => FSPIDQS _3 => SUBSPIWP _4 => FSPIWP) ([Input] [Output])));
        _for_each_inner_gpio!((15, GPIO15() (_2 => U0RTS) ([Input] [Output])));
        _for_each_inner_gpio!((16, GPIO16(_2 => U0CTS) () ([Input] [Output])));
        _for_each_inner_gpio!((17, GPIO17() (_2 => U1TXD) ([Input] [Output])));
        _for_each_inner_gpio!((18, GPIO18(_2 => U1RXD) (_3 => CLK_OUT3) ([Input]
        [Output]))); _for_each_inner_gpio!((19, GPIO19() (_2 => U1RTS _3 => CLK_OUT2)
        ([Input] [Output]))); _for_each_inner_gpio!((20, GPIO20(_2 => U1CTS) (_3 =>
        CLK_OUT1) ([Input] [Output]))); _for_each_inner_gpio!((21, GPIO21() () ([Input]
        [Output]))); _for_each_inner_gpio!((26, GPIO26() (_0 => SPICS1) ([Input]
        [Output]))); _for_each_inner_gpio!((27, GPIO27(_0 => SPIHD) (_0 => SPIHD)
        ([Input] [Output]))); _for_each_inner_gpio!((28, GPIO28(_0 => SPIWP) (_0 =>
        SPIWP) ([Input] [Output]))); _for_each_inner_gpio!((29, GPIO29() (_0 => SPICS0)
        ([Input] [Output]))); _for_each_inner_gpio!((30, GPIO30() (_0 => SPICLK) ([Input]
        [Output]))); _for_each_inner_gpio!((31, GPIO31(_0 => SPIQ) (_0 => SPIQ) ([Input]
        [Output]))); _for_each_inner_gpio!((32, GPIO32(_0 => SPID) (_0 => SPID) ([Input]
        [Output]))); _for_each_inner_gpio!((33, GPIO33(_2 => FSPIHD _3 => SUBSPIHD) (_2
        => FSPIHD _3 => SUBSPIHD) ([Input] [Output]))); _for_each_inner_gpio!((34,
        GPIO34(_2 => FSPICS0) (_2 => FSPICS0 _3 => SUBSPICS0) ([Input] [Output])));
        _for_each_inner_gpio!((35, GPIO35(_2 => FSPID _3 => SUBSPID) (_2 => FSPID _3 =>
        SUBSPID) ([Input] [Output]))); _for_each_inner_gpio!((36, GPIO36(_2 => FSPICLK)
        (_2 => FSPICLK _3 => SUBSPICLK) ([Input] [Output]))); _for_each_inner_gpio!((37,
        GPIO37(_2 => FSPIQ _3 => SUBSPIQ _4 => SPIDQS) (_2 => FSPIQ _3 => SUBSPIQ _4 =>
        SPIDQS) ([Input] [Output]))); _for_each_inner_gpio!((38, GPIO38(_2 => FSPIWP _3
        => SUBSPIWP) (_2 => FSPIWP _3 => SUBSPIWP) ([Input] [Output])));
        _for_each_inner_gpio!((39, GPIO39(_0 => MTCK) (_2 => CLK_OUT3 _3 => SUBSPICS1)
        ([Input] [Output]))); _for_each_inner_gpio!((40, GPIO40() (_0 => MTDO _2 =>
        CLK_OUT2) ([Input] [Output]))); _for_each_inner_gpio!((41, GPIO41(_0 => MTDI) (_2
        => CLK_OUT1) ([Input] [Output]))); _for_each_inner_gpio!((42, GPIO42(_0 => MTMS)
        () ([Input] [Output]))); _for_each_inner_gpio!((43, GPIO43() (_0 => U0TXD _2 =>
        CLK_OUT1) ([Input] [Output]))); _for_each_inner_gpio!((44, GPIO44(_0 => U0RXD)
        (_2 => CLK_OUT2) ([Input] [Output]))); _for_each_inner_gpio!((45, GPIO45() ()
        ([Input] [Output]))); _for_each_inner_gpio!((46, GPIO46() () ([Input]
        [Output]))); _for_each_inner_gpio!((all(0, GPIO0() () ([Input] [Output])), (1,
        GPIO1() () ([Input] [Output])), (2, GPIO2() () ([Input] [Output])), (3, GPIO3()
        () ([Input] [Output])), (4, GPIO4() () ([Input] [Output])), (5, GPIO5() ()
        ([Input] [Output])), (6, GPIO6() () ([Input] [Output])), (7, GPIO7() () ([Input]
        [Output])), (8, GPIO8() (_3 => SUBSPICS1) ([Input] [Output])), (9, GPIO9(_3 =>
        SUBSPIHD _4 => FSPIHD) (_3 => SUBSPIHD _4 => FSPIHD) ([Input] [Output])), (10,
        GPIO10(_2 => FSPIIO4 _4 => FSPICS0) (_2 => FSPIIO4 _3 => SUBSPICS0 _4 => FSPICS0)
        ([Input] [Output])), (11, GPIO11(_2 => FSPIIO5 _3 => SUBSPID _4 => FSPID) (_2 =>
        FSPIIO5 _3 => SUBSPID _4 => FSPID) ([Input] [Output])), (12, GPIO12(_2 => FSPIIO6
        _4 => FSPICLK) (_2 => FSPIIO6 _3 => SUBSPICLK _4 => FSPICLK) ([Input] [Output])),
        (13, GPIO13(_2 => FSPIIO7 _3 => SUBSPIQ _4 => FSPIQ) (_2 => FSPIIO7 _3 => SUBSPIQ
        _4 => FSPIQ) ([Input] [Output])), (14, GPIO14(_3 => SUBSPIWP _4 => FSPIWP) (_2 =>
        FSPIDQS _3 => SUBSPIWP _4 => FSPIWP) ([Input] [Output])), (15, GPIO15() (_2 =>
        U0RTS) ([Input] [Output])), (16, GPIO16(_2 => U0CTS) () ([Input] [Output])), (17,
        GPIO17() (_2 => U1TXD) ([Input] [Output])), (18, GPIO18(_2 => U1RXD) (_3 =>
        CLK_OUT3) ([Input] [Output])), (19, GPIO19() (_2 => U1RTS _3 => CLK_OUT2)
        ([Input] [Output])), (20, GPIO20(_2 => U1CTS) (_3 => CLK_OUT1) ([Input]
        [Output])), (21, GPIO21() () ([Input] [Output])), (26, GPIO26() (_0 => SPICS1)
        ([Input] [Output])), (27, GPIO27(_0 => SPIHD) (_0 => SPIHD) ([Input] [Output])),
        (28, GPIO28(_0 => SPIWP) (_0 => SPIWP) ([Input] [Output])), (29, GPIO29() (_0 =>
        SPICS0) ([Input] [Output])), (30, GPIO30() (_0 => SPICLK) ([Input] [Output])),
        (31, GPIO31(_0 => SPIQ) (_0 => SPIQ) ([Input] [Output])), (32, GPIO32(_0 => SPID)
        (_0 => SPID) ([Input] [Output])), (33, GPIO33(_2 => FSPIHD _3 => SUBSPIHD) (_2 =>
        FSPIHD _3 => SUBSPIHD) ([Input] [Output])), (34, GPIO34(_2 => FSPICS0) (_2 =>
        FSPICS0 _3 => SUBSPICS0) ([Input] [Output])), (35, GPIO35(_2 => FSPID _3 =>
        SUBSPID) (_2 => FSPID _3 => SUBSPID) ([Input] [Output])), (36, GPIO36(_2 =>
        FSPICLK) (_2 => FSPICLK _3 => SUBSPICLK) ([Input] [Output])), (37, GPIO37(_2 =>
        FSPIQ _3 => SUBSPIQ _4 => SPIDQS) (_2 => FSPIQ _3 => SUBSPIQ _4 => SPIDQS)
        ([Input] [Output])), (38, GPIO38(_2 => FSPIWP _3 => SUBSPIWP) (_2 => FSPIWP _3 =>
        SUBSPIWP) ([Input] [Output])), (39, GPIO39(_0 => MTCK) (_2 => CLK_OUT3 _3 =>
        SUBSPICS1) ([Input] [Output])), (40, GPIO40() (_0 => MTDO _2 => CLK_OUT2)
        ([Input] [Output])), (41, GPIO41(_0 => MTDI) (_2 => CLK_OUT1) ([Input]
        [Output])), (42, GPIO42(_0 => MTMS) () ([Input] [Output])), (43, GPIO43() (_0 =>
        U0TXD _2 => CLK_OUT1) ([Input] [Output])), (44, GPIO44(_0 => U0RXD) (_2 =>
        CLK_OUT2) ([Input] [Output])), (45, GPIO45() () ([Input] [Output])), (46,
        GPIO46() () ([Input] [Output]))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_analog_function { $(($pattern) => $code;)* ($other :
        tt) => {} } _for_each_inner_analog_function!((TOUCH1, GPIO1));
        _for_each_inner_analog_function!((ADC1_CH0, GPIO1));
        _for_each_inner_analog_function!((TOUCH2, GPIO2));
        _for_each_inner_analog_function!((ADC1_CH1, GPIO2));
        _for_each_inner_analog_function!((TOUCH3, GPIO3));
        _for_each_inner_analog_function!((ADC1_CH2, GPIO3));
        _for_each_inner_analog_function!((TOUCH4, GPIO4));
        _for_each_inner_analog_function!((ADC1_CH3, GPIO4));
        _for_each_inner_analog_function!((TOUCH5, GPIO5));
        _for_each_inner_analog_function!((ADC1_CH4, GPIO5));
        _for_each_inner_analog_function!((TOUCH6, GPIO6));
        _for_each_inner_analog_function!((ADC1_CH5, GPIO6));
        _for_each_inner_analog_function!((TOUCH7, GPIO7));
        _for_each_inner_analog_function!((ADC1_CH6, GPIO7));
        _for_each_inner_analog_function!((TOUCH8, GPIO8));
        _for_each_inner_analog_function!((ADC1_CH7, GPIO8));
        _for_each_inner_analog_function!((TOUCH9, GPIO9));
        _for_each_inner_analog_function!((ADC1_CH8, GPIO9));
        _for_each_inner_analog_function!((TOUCH10, GPIO10));
        _for_each_inner_analog_function!((ADC1_CH9, GPIO10));
        _for_each_inner_analog_function!((TOUCH11, GPIO11));
        _for_each_inner_analog_function!((ADC2_CH0, GPIO11));
        _for_each_inner_analog_function!((TOUCH12, GPIO12));
        _for_each_inner_analog_function!((ADC2_CH1, GPIO12));
        _for_each_inner_analog_function!((TOUCH13, GPIO13));
        _for_each_inner_analog_function!((ADC2_CH2, GPIO13));
        _for_each_inner_analog_function!((TOUCH14, GPIO14));
        _for_each_inner_analog_function!((ADC2_CH3, GPIO14));
        _for_each_inner_analog_function!((XTAL_32K_P, GPIO15));
        _for_each_inner_analog_function!((ADC2_CH4, GPIO15));
        _for_each_inner_analog_function!((XTAL_32K_N, GPIO16));
        _for_each_inner_analog_function!((ADC2_CH5, GPIO16));
        _for_each_inner_analog_function!((DAC_1, GPIO17));
        _for_each_inner_analog_function!((ADC2_CH6, GPIO17));
        _for_each_inner_analog_function!((DAC_2, GPIO18));
        _for_each_inner_analog_function!((ADC2_CH7, GPIO18));
        _for_each_inner_analog_function!((USB_DM, GPIO19));
        _for_each_inner_analog_function!((ADC2_CH8, GPIO19));
        _for_each_inner_analog_function!((USB_DP, GPIO20));
        _for_each_inner_analog_function!((ADC2_CH9, GPIO20));
        _for_each_inner_analog_function!(((TOUCH1, TOUCHn, 1), GPIO1));
        _for_each_inner_analog_function!(((ADC1_CH0, ADCn_CHm, 1, 0), GPIO1));
        _for_each_inner_analog_function!(((TOUCH2, TOUCHn, 2), GPIO2));
        _for_each_inner_analog_function!(((ADC1_CH1, ADCn_CHm, 1, 1), GPIO2));
        _for_each_inner_analog_function!(((TOUCH3, TOUCHn, 3), GPIO3));
        _for_each_inner_analog_function!(((ADC1_CH2, ADCn_CHm, 1, 2), GPIO3));
        _for_each_inner_analog_function!(((TOUCH4, TOUCHn, 4), GPIO4));
        _for_each_inner_analog_function!(((ADC1_CH3, ADCn_CHm, 1, 3), GPIO4));
        _for_each_inner_analog_function!(((TOUCH5, TOUCHn, 5), GPIO5));
        _for_each_inner_analog_function!(((ADC1_CH4, ADCn_CHm, 1, 4), GPIO5));
        _for_each_inner_analog_function!(((TOUCH6, TOUCHn, 6), GPIO6));
        _for_each_inner_analog_function!(((ADC1_CH5, ADCn_CHm, 1, 5), GPIO6));
        _for_each_inner_analog_function!(((TOUCH7, TOUCHn, 7), GPIO7));
        _for_each_inner_analog_function!(((ADC1_CH6, ADCn_CHm, 1, 6), GPIO7));
        _for_each_inner_analog_function!(((TOUCH8, TOUCHn, 8), GPIO8));
        _for_each_inner_analog_function!(((ADC1_CH7, ADCn_CHm, 1, 7), GPIO8));
        _for_each_inner_analog_function!(((TOUCH9, TOUCHn, 9), GPIO9));
        _for_each_inner_analog_function!(((ADC1_CH8, ADCn_CHm, 1, 8), GPIO9));
        _for_each_inner_analog_function!(((TOUCH10, TOUCHn, 10), GPIO10));
        _for_each_inner_analog_function!(((ADC1_CH9, ADCn_CHm, 1, 9), GPIO10));
        _for_each_inner_analog_function!(((TOUCH11, TOUCHn, 11), GPIO11));
        _for_each_inner_analog_function!(((ADC2_CH0, ADCn_CHm, 2, 0), GPIO11));
        _for_each_inner_analog_function!(((TOUCH12, TOUCHn, 12), GPIO12));
        _for_each_inner_analog_function!(((ADC2_CH1, ADCn_CHm, 2, 1), GPIO12));
        _for_each_inner_analog_function!(((TOUCH13, TOUCHn, 13), GPIO13));
        _for_each_inner_analog_function!(((ADC2_CH2, ADCn_CHm, 2, 2), GPIO13));
        _for_each_inner_analog_function!(((TOUCH14, TOUCHn, 14), GPIO14));
        _for_each_inner_analog_function!(((ADC2_CH3, ADCn_CHm, 2, 3), GPIO14));
        _for_each_inner_analog_function!(((ADC2_CH4, ADCn_CHm, 2, 4), GPIO15));
        _for_each_inner_analog_function!(((ADC2_CH5, ADCn_CHm, 2, 5), GPIO16));
        _for_each_inner_analog_function!(((DAC_1, DAC_n, 1), GPIO17));
        _for_each_inner_analog_function!(((ADC2_CH6, ADCn_CHm, 2, 6), GPIO17));
        _for_each_inner_analog_function!(((DAC_2, DAC_n, 2), GPIO18));
        _for_each_inner_analog_function!(((ADC2_CH7, ADCn_CHm, 2, 7), GPIO18));
        _for_each_inner_analog_function!(((ADC2_CH8, ADCn_CHm, 2, 8), GPIO19));
        _for_each_inner_analog_function!(((ADC2_CH9, ADCn_CHm, 2, 9), GPIO20));
        _for_each_inner_analog_function!((all(TOUCH1, GPIO1), (ADC1_CH0, GPIO1), (TOUCH2,
        GPIO2), (ADC1_CH1, GPIO2), (TOUCH3, GPIO3), (ADC1_CH2, GPIO3), (TOUCH4, GPIO4),
        (ADC1_CH3, GPIO4), (TOUCH5, GPIO5), (ADC1_CH4, GPIO5), (TOUCH6, GPIO6),
        (ADC1_CH5, GPIO6), (TOUCH7, GPIO7), (ADC1_CH6, GPIO7), (TOUCH8, GPIO8),
        (ADC1_CH7, GPIO8), (TOUCH9, GPIO9), (ADC1_CH8, GPIO9), (TOUCH10, GPIO10),
        (ADC1_CH9, GPIO10), (TOUCH11, GPIO11), (ADC2_CH0, GPIO11), (TOUCH12, GPIO12),
        (ADC2_CH1, GPIO12), (TOUCH13, GPIO13), (ADC2_CH2, GPIO13), (TOUCH14, GPIO14),
        (ADC2_CH3, GPIO14), (XTAL_32K_P, GPIO15), (ADC2_CH4, GPIO15), (XTAL_32K_N,
        GPIO16), (ADC2_CH5, GPIO16), (DAC_1, GPIO17), (ADC2_CH6, GPIO17), (DAC_2,
        GPIO18), (ADC2_CH7, GPIO18), (USB_DM, GPIO19), (ADC2_CH8, GPIO19), (USB_DP,
        GPIO20), (ADC2_CH9, GPIO20)));
        _for_each_inner_analog_function!((all_expanded((TOUCH1, TOUCHn, 1), GPIO1),
        ((ADC1_CH0, ADCn_CHm, 1, 0), GPIO1), ((TOUCH2, TOUCHn, 2), GPIO2), ((ADC1_CH1,
        ADCn_CHm, 1, 1), GPIO2), ((TOUCH3, TOUCHn, 3), GPIO3), ((ADC1_CH2, ADCn_CHm, 1,
        2), GPIO3), ((TOUCH4, TOUCHn, 4), GPIO4), ((ADC1_CH3, ADCn_CHm, 1, 3), GPIO4),
        ((TOUCH5, TOUCHn, 5), GPIO5), ((ADC1_CH4, ADCn_CHm, 1, 4), GPIO5), ((TOUCH6,
        TOUCHn, 6), GPIO6), ((ADC1_CH5, ADCn_CHm, 1, 5), GPIO6), ((TOUCH7, TOUCHn, 7),
        GPIO7), ((ADC1_CH6, ADCn_CHm, 1, 6), GPIO7), ((TOUCH8, TOUCHn, 8), GPIO8),
        ((ADC1_CH7, ADCn_CHm, 1, 7), GPIO8), ((TOUCH9, TOUCHn, 9), GPIO9), ((ADC1_CH8,
        ADCn_CHm, 1, 8), GPIO9), ((TOUCH10, TOUCHn, 10), GPIO10), ((ADC1_CH9, ADCn_CHm,
        1, 9), GPIO10), ((TOUCH11, TOUCHn, 11), GPIO11), ((ADC2_CH0, ADCn_CHm, 2, 0),
        GPIO11), ((TOUCH12, TOUCHn, 12), GPIO12), ((ADC2_CH1, ADCn_CHm, 2, 1), GPIO12),
        ((TOUCH13, TOUCHn, 13), GPIO13), ((ADC2_CH2, ADCn_CHm, 2, 2), GPIO13), ((TOUCH14,
        TOUCHn, 14), GPIO14), ((ADC2_CH3, ADCn_CHm, 2, 3), GPIO14), ((ADC2_CH4, ADCn_CHm,
        2, 4), GPIO15), ((ADC2_CH5, ADCn_CHm, 2, 5), GPIO16), ((DAC_1, DAC_n, 1),
        GPIO17), ((ADC2_CH6, ADCn_CHm, 2, 6), GPIO17), ((DAC_2, DAC_n, 2), GPIO18),
        ((ADC2_CH7, ADCn_CHm, 2, 7), GPIO18), ((ADC2_CH8, ADCn_CHm, 2, 8), GPIO19),
        ((ADC2_CH9, ADCn_CHm, 2, 9), GPIO20)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner_lp_function { $(($pattern) => $code;)* ($other : tt)
        => {} } _for_each_inner_lp_function!((RTC_GPIO0, GPIO0));
        _for_each_inner_lp_function!((RTC_GPIO1, GPIO1));
        _for_each_inner_lp_function!((RTC_GPIO2, GPIO2));
        _for_each_inner_lp_function!((RTC_GPIO3, GPIO3));
        _for_each_inner_lp_function!((RTC_GPIO4, GPIO4));
        _for_each_inner_lp_function!((RTC_GPIO5, GPIO5));
        _for_each_inner_lp_function!((RTC_GPIO6, GPIO6));
        _for_each_inner_lp_function!((RTC_GPIO7, GPIO7));
        _for_each_inner_lp_function!((RTC_GPIO8, GPIO8));
        _for_each_inner_lp_function!((RTC_GPIO9, GPIO9));
        _for_each_inner_lp_function!((RTC_GPIO10, GPIO10));
        _for_each_inner_lp_function!((RTC_GPIO11, GPIO11));
        _for_each_inner_lp_function!((RTC_GPIO12, GPIO12));
        _for_each_inner_lp_function!((RTC_GPIO13, GPIO13));
        _for_each_inner_lp_function!((RTC_GPIO14, GPIO14));
        _for_each_inner_lp_function!((RTC_GPIO15, GPIO15));
        _for_each_inner_lp_function!((RTC_GPIO16, GPIO16));
        _for_each_inner_lp_function!((RTC_GPIO17, GPIO17));
        _for_each_inner_lp_function!((RTC_GPIO18, GPIO18));
        _for_each_inner_lp_function!((RTC_GPIO19, GPIO19));
        _for_each_inner_lp_function!((RTC_GPIO20, GPIO20));
        _for_each_inner_lp_function!((RTC_GPIO21, GPIO21));
        _for_each_inner_lp_function!(((RTC_GPIO0, RTC_GPIOn, 0), GPIO0));
        _for_each_inner_lp_function!(((RTC_GPIO1, RTC_GPIOn, 1), GPIO1));
        _for_each_inner_lp_function!(((RTC_GPIO2, RTC_GPIOn, 2), GPIO2));
        _for_each_inner_lp_function!(((RTC_GPIO3, RTC_GPIOn, 3), GPIO3));
        _for_each_inner_lp_function!(((RTC_GPIO4, RTC_GPIOn, 4), GPIO4));
        _for_each_inner_lp_function!(((RTC_GPIO5, RTC_GPIOn, 5), GPIO5));
        _for_each_inner_lp_function!(((RTC_GPIO6, RTC_GPIOn, 6), GPIO6));
        _for_each_inner_lp_function!(((RTC_GPIO7, RTC_GPIOn, 7), GPIO7));
        _for_each_inner_lp_function!(((RTC_GPIO8, RTC_GPIOn, 8), GPIO8));
        _for_each_inner_lp_function!(((RTC_GPIO9, RTC_GPIOn, 9), GPIO9));
        _for_each_inner_lp_function!(((RTC_GPIO10, RTC_GPIOn, 10), GPIO10));
        _for_each_inner_lp_function!(((RTC_GPIO11, RTC_GPIOn, 11), GPIO11));
        _for_each_inner_lp_function!(((RTC_GPIO12, RTC_GPIOn, 12), GPIO12));
        _for_each_inner_lp_function!(((RTC_GPIO13, RTC_GPIOn, 13), GPIO13));
        _for_each_inner_lp_function!(((RTC_GPIO14, RTC_GPIOn, 14), GPIO14));
        _for_each_inner_lp_function!(((RTC_GPIO15, RTC_GPIOn, 15), GPIO15));
        _for_each_inner_lp_function!(((RTC_GPIO16, RTC_GPIOn, 16), GPIO16));
        _for_each_inner_lp_function!(((RTC_GPIO17, RTC_GPIOn, 17), GPIO17));
        _for_each_inner_lp_function!(((RTC_GPIO18, RTC_GPIOn, 18), GPIO18));
        _for_each_inner_lp_function!(((RTC_GPIO19, RTC_GPIOn, 19), GPIO19));
        _for_each_inner_lp_function!(((RTC_GPIO20, RTC_GPIOn, 20), GPIO20));
        _for_each_inner_lp_function!(((RTC_GPIO21, RTC_GPIOn, 21), GPIO21));
        _for_each_inner_lp_function!((all(RTC_GPIO0, GPIO0), (RTC_GPIO1, GPIO1),
        (RTC_GPIO2, GPIO2), (RTC_GPIO3, GPIO3), (RTC_GPIO4, GPIO4), (RTC_GPIO5, GPIO5),
        (RTC_GPIO6, GPIO6), (RTC_GPIO7, GPIO7), (RTC_GPIO8, GPIO8), (RTC_GPIO9, GPIO9),
        (RTC_GPIO10, GPIO10), (RTC_GPIO11, GPIO11), (RTC_GPIO12, GPIO12), (RTC_GPIO13,
        GPIO13), (RTC_GPIO14, GPIO14), (RTC_GPIO15, GPIO15), (RTC_GPIO16, GPIO16),
        (RTC_GPIO17, GPIO17), (RTC_GPIO18, GPIO18), (RTC_GPIO19, GPIO19), (RTC_GPIO20,
        GPIO20), (RTC_GPIO21, GPIO21)));
        _for_each_inner_lp_function!((all_expanded((RTC_GPIO0, RTC_GPIOn, 0), GPIO0),
        ((RTC_GPIO1, RTC_GPIOn, 1), GPIO1), ((RTC_GPIO2, RTC_GPIOn, 2), GPIO2),
        ((RTC_GPIO3, RTC_GPIOn, 3), GPIO3), ((RTC_GPIO4, RTC_GPIOn, 4), GPIO4),
        ((RTC_GPIO5, RTC_GPIOn, 5), GPIO5), ((RTC_GPIO6, RTC_GPIOn, 6), GPIO6),
        ((RTC_GPIO7, RTC_GPIOn, 7), GPIO7), ((RTC_GPIO8, RTC_GPIOn, 8), GPIO8),
        ((RTC_GPIO9, RTC_GPIOn, 9), GPIO9), ((RTC_GPIO10, RTC_GPIOn, 10), GPIO10),
        ((RTC_GPIO11, RTC_GPIOn, 11), GPIO11), ((RTC_GPIO12, RTC_GPIOn, 12), GPIO12),
        ((RTC_GPIO13, RTC_GPIOn, 13), GPIO13), ((RTC_GPIO14, RTC_GPIOn, 14), GPIO14),
        ((RTC_GPIO15, RTC_GPIOn, 15), GPIO15), ((RTC_GPIO16, RTC_GPIOn, 16), GPIO16),
        ((RTC_GPIO17, RTC_GPIOn, 17), GPIO17), ((RTC_GPIO18, RTC_GPIOn, 18), GPIO18),
        ((RTC_GPIO19, RTC_GPIOn, 19), GPIO19), ((RTC_GPIO20, RTC_GPIOn, 20), GPIO20),
        ((RTC_GPIO21, RTC_GPIOn, 21), GPIO21)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            SPIQ              = 0,
            SPID              = 1,
            SPIHD             = 2,
            SPIWP             = 3,
            SPID4             = 7,
            SPID5             = 8,
            SPID6             = 9,
            SPID7             = 10,
            SPIDQS            = 11,
            U0RXD             = 14,
            U0CTS             = 15,
            U0DSR             = 16,
            U1RXD             = 17,
            U1CTS             = 18,
            U1DSR             = 21,
            I2S0O_BCK         = 23,
            I2S0O_WS          = 25,
            I2S0I_BCK         = 27,
            I2S0I_WS          = 28,
            I2CEXT0_SCL       = 29,
            I2CEXT0_SDA       = 30,
            PCNT0_SIG_CH0     = 39,
            PCNT0_SIG_CH1     = 40,
            PCNT0_CTRL_CH0    = 41,
            PCNT0_CTRL_CH1    = 42,
            PCNT1_SIG_CH0     = 43,
            PCNT1_SIG_CH1     = 44,
            PCNT1_CTRL_CH0    = 45,
            PCNT1_CTRL_CH1    = 46,
            PCNT2_SIG_CH0     = 47,
            PCNT2_SIG_CH1     = 48,
            PCNT2_CTRL_CH0    = 49,
            PCNT2_CTRL_CH1    = 50,
            PCNT3_SIG_CH0     = 51,
            PCNT3_SIG_CH1     = 52,
            PCNT3_CTRL_CH0    = 53,
            PCNT3_CTRL_CH1    = 54,
            USB_EXTPHY_VP     = 61,
            USB_EXTPHY_VM     = 62,
            USB_EXTPHY_RCV    = 63,
            USB_OTG_IDDIG     = 64,
            USB_OTG_AVALID    = 65,
            USB_SRP_BVALID    = 66,
            USB_OTG_VBUSVALID = 67,
            USB_SRP_SESSEND   = 68,
            SPI3_CLK          = 72,
            SPI3_Q            = 73,
            SPI3_D            = 74,
            SPI3_HD           = 75,
            SPI3_CS0          = 76,
            RMT_SIG_0         = 83,
            RMT_SIG_1         = 84,
            RMT_SIG_2         = 85,
            RMT_SIG_3         = 86,
            I2CEXT1_SCL       = 95,
            I2CEXT1_SDA       = 96,
            FSPICLK           = 108,
            FSPIQ             = 109,
            FSPID             = 110,
            FSPIHD            = 111,
            FSPIWP            = 112,
            FSPIIO4           = 113,
            FSPIIO5           = 114,
            FSPIIO6           = 115,
            FSPIIO7           = 116,
            FSPICS0           = 117,
            TWAI_RX           = 123,
            SUBSPIQ           = 127,
            SUBSPID           = 128,
            SUBSPIHD          = 129,
            SUBSPIWP          = 130,
            I2S0I_DATA_IN15   = 158,
            SUBSPID4          = 167,
            SUBSPID5          = 168,
            SUBSPID6          = 169,
            SUBSPID7          = 170,
            SUBSPIDQS         = 171,
            PCMFSYNC          = 203,
            PCMCLK            = 204,
            PRO_ALONEGPIO0    = 235,
            PRO_ALONEGPIO1    = 236,
            PRO_ALONEGPIO2    = 237,
            PRO_ALONEGPIO3    = 238,
            PRO_ALONEGPIO4    = 239,
            PRO_ALONEGPIO5    = 240,
            PRO_ALONEGPIO6    = 241,
            PRO_ALONEGPIO7    = 242,
            MTDI,
            MTCK,
            MTMS,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            SPIQ             = 0,
            SPID             = 1,
            SPIHD            = 2,
            SPIWP            = 3,
            SPICLK           = 4,
            SPICS0           = 5,
            SPICS1           = 6,
            SPID4            = 7,
            SPID5            = 8,
            SPID6            = 9,
            SPID7            = 10,
            SPIDQS           = 11,
            U0TXD            = 14,
            U0RTS            = 15,
            U0DTR            = 16,
            U1TXD            = 17,
            U1RTS            = 18,
            U1DTR            = 21,
            I2S0O_BCK        = 23,
            I2S0O_WS         = 25,
            I2S0I_BCK        = 27,
            I2S0I_WS         = 28,
            I2CEXT0_SCL      = 29,
            I2CEXT0_SDA      = 30,
            SDIO_TOHOST_INT  = 31,
            USB_EXTPHY_OEN   = 61,
            USB_EXTPHY_VPO   = 63,
            USB_EXTPHY_VMO   = 64,
            SPI3_CLK         = 72,
            SPI3_Q           = 73,
            SPI3_D           = 74,
            SPI3_HD          = 75,
            SPI3_CS0         = 76,
            SPI3_CS1         = 77,
            SPI3_CS2         = 78,
            LEDC_LS_SIG0     = 79,
            LEDC_LS_SIG1     = 80,
            LEDC_LS_SIG2     = 81,
            LEDC_LS_SIG3     = 82,
            LEDC_LS_SIG4     = 83,
            LEDC_LS_SIG5     = 84,
            LEDC_LS_SIG6     = 85,
            LEDC_LS_SIG7     = 86,
            RMT_SIG_0        = 87,
            RMT_SIG_1        = 88,
            RMT_SIG_2        = 89,
            RMT_SIG_3        = 90,
            I2CEXT1_SCL      = 95,
            I2CEXT1_SDA      = 96,
            GPIO_SD0         = 100,
            GPIO_SD1         = 101,
            GPIO_SD2         = 102,
            GPIO_SD3         = 103,
            GPIO_SD4         = 104,
            GPIO_SD5         = 105,
            GPIO_SD6         = 106,
            GPIO_SD7         = 107,
            FSPICLK          = 108,
            FSPIQ            = 109,
            FSPID            = 110,
            FSPIHD           = 111,
            FSPIWP           = 112,
            FSPIIO4          = 113,
            FSPIIO5          = 114,
            FSPIIO6          = 115,
            FSPIIO7          = 116,
            FSPICS0          = 117,
            FSPICS1          = 118,
            FSPICS2          = 119,
            FSPICS3          = 120,
            FSPICS4          = 121,
            FSPICS5          = 122,
            TWAI_TX          = 123,
            SUBSPICLK        = 126,
            SUBSPIQ          = 127,
            SUBSPID          = 128,
            SUBSPIHD         = 129,
            SUBSPIWP         = 130,
            SUBSPICS0        = 131,
            SUBSPICS1        = 132,
            FSPIDQS          = 133,
            FSPI_HSYNC       = 134,
            FSPI_VSYNC       = 135,
            FSPI_DE          = 136,
            FSPICD           = 137,
            SPI3_CD          = 139,
            SPI3_DQS         = 140,
            I2S0O_DATA_OUT23 = 166,
            SUBSPID4         = 167,
            SUBSPID5         = 168,
            SUBSPID6         = 169,
            SUBSPID7         = 170,
            SUBSPIDQS        = 171,
            PCMFSYNC         = 209,
            PCMCLK           = 210,
            PRO_ALONEGPIO0   = 235,
            PRO_ALONEGPIO1   = 236,
            PRO_ALONEGPIO2   = 237,
            PRO_ALONEGPIO3   = 238,
            PRO_ALONEGPIO4   = 239,
            PRO_ALONEGPIO5   = 240,
            PRO_ALONEGPIO6   = 241,
            PRO_ALONEGPIO7   = 242,
            CLK_I2S          = 251,
            GPIO             = 256,
            CLK_OUT1,
            CLK_OUT2,
            CLK_OUT3,
            MTDO,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO {
            crate::peripherals::IO_MUX::regs().gpio(gpio_num as usize)
        }
    };
}
