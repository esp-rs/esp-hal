//! Wi-Fi Events
//!
//! This is considered unstable functionality.
//! Use with caution.

use enumset::{EnumSet, EnumSetType};
use esp_config::esp_config_int;
use esp_sync::NonReentrantMutex;
use num_derive::FromPrimitive;

use super::Ssid;
use crate::wifi::include::{
    wifi_event_sta_wps_er_success_t__bindgen_ty_1,
    wifi_ftm_report_entry_t,
};

static WIFI_EVENT_ENABLE_MASK: NonReentrantMutex<EnumSet<WifiEvent>> =
    NonReentrantMutex::new(enumset::enum_set!());

pub(crate) static EVENT_CHANNEL: embassy_sync::pubsub::PubSubChannel<
    esp_sync::RawMutex,
    EventInfo,
    { esp_config_int!(usize, "ESP_RADIO_CONFIG_EVENT_CHANNEL_CAPACITY") },
    { esp_config_int!(usize, "ESP_RADIO_CONFIG_EVENT_CHANNEL_SUBSCRIBERS") },
    1,
> = embassy_sync::pubsub::PubSubChannel::new();

/// Events generated by the Wi-Fi driver.
#[derive(Debug, Hash, FromPrimitive, EnumSetType)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[non_exhaustive]
#[repr(i32)]
#[instability::unstable]
pub enum WifiEvent {
    /// Wi-Fi is ready for operation.
    WifiReady = 0,
    /// Scan operation has completed.
    ScanDone,
    /// Station mode started.
    StationStart,
    /// Station mode stopped.
    StationStop,
    /// Station connected to a network.
    StationConnected,
    /// Station disconnected from a network.
    StationDisconnected,
    /// Station authentication mode changed.
    StationAuthenticationModeChange,

    /// Station Wi-Fi-Protected-Status succeeds in enrollee mode.
    StationWifiProtectedStatusEnrolleeSuccess,
    /// Station Wi-Fi-Protected-Status fails in enrollee mode.
    StationWifiProtectedStatusEnrolleeFailed,
    /// Station Wi-Fi-Protected-Status timeout in enrollee mode.
    StationWifiProtectedStatusEnrolleeTimeout,
    /// Station Wi-Fi-Protected-Status pin code in enrollee mode.
    StationWifiProtectedStatusEnrolleePin,
    /// Station Wi-Fi-Protected-Status overlap in enrollee mode.
    StationWifiProtectedStatusEnrolleePushButtonConfigurationOverlap,

    /// Soft-AccessPoint start.
    AccessPointStart,
    /// Soft-AccessPoint stop.
    AccessPointStop,
    /// A station connected to Soft-AccessPoint.
    AccessPointStationConnected,
    /// A station disconnected from Soft-AccessPoint.
    AccessPointStationDisconnected,
    /// Received probe request packet in Soft-AccessPoint interface.
    AccessPointProbeRequestReceived,

    /// Received report of Fine-Timing-Measurement procedure.
    FineTimingMeasurementReport,

    /// Station Receive-Signal-Strenght-Indicator goes below the configured threshold.
    StationBasicServiceSetReceivedSignalStrengthIndicatorLow,
    /// Status indication of Action Transmission operation.
    ActionTransmissionStatus,
    /// Remain-on-Channel operation complete.
    RemainOnChannelDone,

    /// Station beacon timeout.
    StationBeaconTimeout,

    /// Connectionless module wake interval has started.
    ConnectionlessModuleWakeIntervalStart,

    /// Soft-AccessPoint Wi-Fi-Protected-Status succeeded in registrar mode.
    AccessPointWifiProtectedStatusRegistrarSuccess,
    /// Soft-AccessPoint Wi-Fi-Protected-Status failed in registrar mode.
    AccessPointWifiProtectedStatusRegistrarFailed,
    /// Soft-AccessPoint Wi-Fi-Protected-Status timed out in registrar mode.
    AccessPointWifiProtectedStatusRegistrarTimeout,
    /// Soft-AccessPoint Wi-Fi-Protected-Status pin code in registrar mode.
    AccessPointWifiProtectedStatusRegistrarPin,
    /// Soft-AccessPoint Wi-Fi-Protected-Status overlap in registrar mode.
    AccessPointWifiProtectedStatusRegistrarPushButtonConfigurationOverlap,

    /// Individual Target-Wake-Time setup.
    IndividualTargetWakeTimeSetup,
    /// Individual Target-Wake-Time teardown.
    IndividualTargetWakeTimeTeardown,
    /// Individual Target-Wake-Time probe.
    IndividualTargetWakeTimeProbe,
    /// Individual Target-Wake-Time suspended.
    IndividualTargetWakeTimeSuspend,
    /// Target-Wake-Wakeup event.
    TargetWakeTimeWakeup,
    /// Broadcast-Target-Wake-Time setup.
    BroadcastTargetWakeTimeSetup,
    /// Broadcast-Target-Wake-Time teardown.
    BroadcastTargetWakeTimeTeardown,

    /// Neighbor-Awareness-Networking discovery has started.
    NeighborAwarenessNetworkingStarted,
    /// Neighbor-Awareness-Networking discovery has stopped.
    NeighborAwarenessNetworkingStopped,
    /// Neighbor-Awareness-Networking service discovery match found.
    NeighborAwarenessNetworkingServiceMatch,
    /// Replied to a Neighbor-Awareness-Networking peer with service discovery match.
    NeighborAwarenessNetworkingReplied,
    /// Received a follow-up message in Neighbor-Awareness-Networking.
    NeighborAwarenessNetworkingReceive,
    /// Received NDP (Neighbor Discovery Protocol) request from a Neighbor-Awareness-Networking
    /// peer.
    NeighborDiscoveryProtocolIndication,
    /// NDP confirm indication.
    NeighborDiscoveryProtocolConfirmation,
    /// Neighbor-Awareness-Networking datapath terminated indication.
    NeighborDiscoveryProtocolTerminated,
    /// Wi-Fi home channel change, doesn't occur when scanning.
    HomeChannelChange,

    /// Received Neighbor Report response.
    StationNeighborRep,
}

trait Event {
    /// # Safety
    /// `ptr` must be a valid for casting to this event's inner event data.
    unsafe fn from_raw_event_data(ptr: *mut crate::sys::c_types::c_void) -> Self;
}

macro_rules! impl_wifi_event {
    // no data
    ($newtype:ident) => {
        /// See [`WifiEvent`].
        #[derive(Copy, Clone)]
        pub struct $newtype;

        impl Event for $newtype {
            unsafe fn from_raw_event_data(_: *mut crate::sys::c_types::c_void) -> Self {
                Self
            }
        }
    };

    ($newtype:ident, $data:ident) => {
        use crate::sys::include::$data;
        /// See [`WifiEvent`].
        #[derive(Copy, Clone)]
        pub struct $newtype<'a>(&'a $data);

        impl Event for $newtype<'_> {
            unsafe fn from_raw_event_data(ptr: *mut crate::sys::c_types::c_void) -> Self {
                Self(unsafe { &*ptr.cast() })
            }
        }
    };
}

impl_wifi_event!(WifiReady);
impl_wifi_event!(ScanDone, wifi_event_sta_scan_done_t);
impl_wifi_event!(StationStart);
impl_wifi_event!(StationStop);
impl_wifi_event!(StationConnected, wifi_event_sta_connected_t);
impl_wifi_event!(StationDisconnected, wifi_event_sta_disconnected_t);
impl_wifi_event!(
    StationAuthenticationModeChange,
    wifi_event_sta_authmode_change_t
);
impl_wifi_event!(
    StationWifiProtectedStatusEnrolleeSuccess,
    wifi_event_sta_wps_er_success_t
);
impl_wifi_event!(StationWifiProtectedStatusEnrolleeFailed);
impl_wifi_event!(StationWifiProtectedStatusEnrolleeTimeout);
impl_wifi_event!(
    StationWifiProtectedStatusEnrolleePin,
    wifi_event_sta_wps_er_pin_t
);
impl_wifi_event!(StationWifiProtectedStatusEnrolleePushButtonConfigurationOverlap);
impl_wifi_event!(AccessPointStart);
impl_wifi_event!(AccessPointStop);
impl_wifi_event!(AccessPointStationConnected, wifi_event_ap_staconnected_t);
impl_wifi_event!(
    AccessPointStationDisconnected,
    wifi_event_ap_stadisconnected_t
);
impl_wifi_event!(
    AccessPointProbeRequestReceived,
    wifi_event_ap_probe_req_rx_t
);
impl_wifi_event!(FineTimingMeasurementReport, wifi_event_ftm_report_t);
impl_wifi_event!(
    StationBasicServiceSetReceivedSignalStrengthIndicatorLow,
    wifi_event_bss_rssi_low_t
);
impl_wifi_event!(ActionTransmissionStatus, wifi_event_action_tx_status_t);
impl_wifi_event!(RemainOnChannelDone, wifi_event_roc_done_t);
impl_wifi_event!(StationBeaconTimeout);
impl_wifi_event!(ConnectionlessModuleWakeIntervalStart);
impl_wifi_event!(
    AccessPointWifiProtectedStatusRegistrarSuccess,
    wifi_event_ap_wps_rg_success_t
);
impl_wifi_event!(
    AccessPointWifiProtectedStatusRegistrarFailed,
    wifi_event_ap_wps_rg_fail_reason_t
);
impl_wifi_event!(AccessPointWifiProtectedStatusRegistrarTimeout);
impl_wifi_event!(
    AccessPointWifiProtectedStatusRegistrarPin,
    wifi_event_ap_wps_rg_pin_t
);
impl_wifi_event!(AccessPointWifiProtectedStatusRegistrarPushButtonConfigurationOverlap);
impl_wifi_event!(IndividualTargetWakeTimeSetup);
impl_wifi_event!(IndividualTargetWakeTimeTeardown);
impl_wifi_event!(IndividualTargetWakeTimeProbe);
impl_wifi_event!(IndividualTargetWakeTimeSuspend);
impl_wifi_event!(TargetWakeTimeWakeup);
impl_wifi_event!(BroadcastTargetWakeTimeSetup);
impl_wifi_event!(BroadcastTargetWakeTimeTeardown);
impl_wifi_event!(NeighborAwarenessNetworkingStarted);
impl_wifi_event!(NeighborAwarenessNetworkingStopped);
impl_wifi_event!(
    NeighborAwarenessNetworkingServiceMatch,
    wifi_event_nan_svc_match_t
);
impl_wifi_event!(NeighborAwarenessNetworkingReplied, wifi_event_nan_replied_t);
impl_wifi_event!(NeighborAwarenessNetworkingReceive, wifi_event_nan_receive_t);
impl_wifi_event!(
    NeighborDiscoveryProtocolIndication,
    wifi_event_ndp_indication_t
);
impl_wifi_event!(
    NeighborDiscoveryProtocolConfirmation,
    wifi_event_ndp_confirm_t
);
impl_wifi_event!(
    NeighborDiscoveryProtocolTerminated,
    wifi_event_ndp_terminated_t
);
impl_wifi_event!(HomeChannelChange, wifi_event_home_channel_change_t);
impl_wifi_event!(StationNeighborRep, wifi_event_neighbor_report_t);

impl AccessPointStationConnected<'_> {
    /// Get the MAC address of the connected station.
    pub fn mac(&self) -> &[u8] {
        &self.0.mac
    }

    /// Get the AID (Association Identifier) of the connected station.
    pub fn aid(&self) -> u8 {
        self.0.aid
    }

    /// Flag indicating whether the connected station is a mesh child.
    pub fn is_mesh_child(&self) -> bool {
        self.0.is_mesh_child
    }
}

impl AccessPointStationDisconnected<'_> {
    /// Get the MAC address of the disconnected station.
    pub fn mac(&self) -> &[u8] {
        &self.0.mac
    }

    /// Get the reason for the disconnection.
    pub fn reason(&self) -> u16 {
        self.0.reason
    }

    /// AID that the Soft-AccessPoint assigned to the disconnected station.
    pub fn aid(&self) -> u8 {
        self.0.aid
    }

    /// Flag indicating whether the connected station is a mesh child.
    pub fn is_mesh_child(&self) -> bool {
        self.0.is_mesh_child
    }
}

impl ScanDone<'_> {
    /// Get the status of the scan operation.
    pub fn status(&self) -> u32 {
        self.0.status
    }

    /// Get the number of found APs.
    pub fn number(&self) -> u8 {
        self.0.number
    }

    /// Get the scan ID associated with this scan operation.
    pub fn id(&self) -> u8 {
        self.0.scan_id
    }
}

impl StationConnected<'_> {
    /// Get the SSID of the connected station.
    pub fn ssid(&self) -> &[u8] {
        &self.0.ssid
    }

    /// Get the length of the SSID.
    pub fn ssid_len(&self) -> u8 {
        self.0.ssid_len
    }

    /// Get the BSSID (MAC address) of the connected station.
    pub fn bssid(&self) -> &[u8] {
        &self.0.bssid
    }

    /// Get the channel on which the station is connected.
    pub fn channel(&self) -> u8 {
        self.0.channel
    }

    /// Get the authentication mode used for the connection.
    pub fn authmode(&self) -> u32 {
        self.0.authmode
    }

    /// Get the AID (Association Identifier) of the connected station.
    pub fn aid(&self) -> u16 {
        self.0.aid
    }
}

impl StationDisconnected<'_> {
    /// Get the SSID of the disconnected station.
    pub fn ssid(&self) -> &[u8] {
        &self.0.ssid
    }

    /// Get the length of the SSID.
    pub fn ssid_len(&self) -> u8 {
        self.0.ssid_len
    }

    /// Get the BSSID (MAC address) of the disconnected station.
    pub fn bssid(&self) -> &[u8] {
        &self.0.bssid
    }

    /// Get the reason for the disconnection.
    pub fn reason(&self) -> u8 {
        self.0.reason
    }

    /// Get the authentication mode used for the disconnection.
    pub fn rssi(&self) -> i8 {
        self.0.rssi
    }
}

/// All access point credentials received from WPS handshake.
#[repr(transparent)]
pub struct AccessPointCredential(wifi_event_sta_wps_er_success_t__bindgen_ty_1);

impl AccessPointCredential {
    /// Get the SSID of an access point.
    pub fn ssid(&self) -> &[u8] {
        &self.0.ssid
    }

    /// Get passphrase for the access point.
    pub fn passphrase(&self) -> &[u8] {
        &self.0.passphrase
    }
}

impl StationAuthenticationModeChange<'_> {
    /// Get the old authentication mode.
    pub fn old_mode(&self) -> u32 {
        self.0.old_mode
    }

    /// Get the new authentication mode.
    pub fn new_mode(&self) -> u32 {
        self.0.new_mode
    }
}

impl StationWifiProtectedStatusEnrolleeSuccess<'_> {
    /// Get number of access point credentials received.
    pub fn access_point_cred_cnt(&self) -> u8 {
        self.0.ap_cred_cnt
    }

    /// Get all access point credentials received.
    pub fn access_point_cred(&self) -> &[AccessPointCredential] {
        let array_ref: &[AccessPointCredential; 3] =
            // cast reference of fixed-size array to wrapper type
            unsafe { &*(&self.0.ap_cred as *const _ as *const [AccessPointCredential; 3]) };

        &array_ref[..]
    }
}

impl StationWifiProtectedStatusEnrolleePin<'_> {
    /// Get the PIN code received from the WPS.
    pub fn pin(&self) -> &[u8] {
        &self.0.pin_code
    }
}

/// A safe, read-only wrapper for a single FTM report entry.
#[repr(transparent)]
pub struct FineTimingMeasurementReportEntry<'a>(&'a wifi_ftm_report_entry_t);

impl FineTimingMeasurementReportEntry<'_> {
    /// Gets the Dialog Token of the FTM frame.
    pub fn dialog_token(&self) -> u8 {
        self.0.dlog_token
    }

    /// Gets the Received Signal Strength Indicator (RSSI) of the FTM frame.
    pub fn rssi(&self) -> i8 {
        self.0.rssi
    }

    /// Gets the Round Trip Time (RTT) in picoseconds.
    pub fn rtt(&self) -> u32 {
        self.0.rtt
    }

    /// Gets T1: Time of departure of the FTM frame from the Responder (in picoseconds).
    pub fn t1(&self) -> u64 {
        self.0.t1
    }

    /// Gets T2: Time of arrival of the FTM frame at the Initiator (in picoseconds).
    pub fn t2(&self) -> u64 {
        self.0.t2
    }

    /// Gets T3: Time of departure of the ACK from the Initiator (in picoseconds).
    pub fn t3(&self) -> u64 {
        self.0.t3
    }

    /// Gets T4: Time of arrival of the ACK at the Responder (in picoseconds).
    pub fn t4(&self) -> u64 {
        self.0.t4
    }
}

impl FineTimingMeasurementReport<'_> {
    /// Get the MAC address of the FTM peer.
    pub fn peer_mac(&self) -> &[u8] {
        &self.0.peer_mac
    }

    /// Get the status of the FTM operation.
    pub fn status(&self) -> u32 {
        self.0.status
    }

    /// Get the raw round-trip time (RTT) in nanoseconds.
    pub fn rtt_raw(&self) -> u32 {
        self.0.rtt_raw
    }

    /// Get the estimated round-trip time (RTT) in nanoseconds.
    pub fn rtt_est(&self) -> u32 {
        self.0.rtt_est
    }

    /// Get the distance estimate in centimeters.
    pub fn dist_est(&self) -> u32 {
        self.0.dist_est
    }

    /// Get the number of entries in the FTM report data.
    pub fn report_num_entries(&self) -> u8 {
        self.0.ftm_report_num_entries
    }

    /// Returns an iterator over the detailed FTM report entries.
    pub fn entries(&self) -> impl Iterator<Item = FineTimingMeasurementReportEntry<'_>> + '_ {
        let ptr = self.0.ftm_report_data;
        let len = self.0.ftm_report_num_entries as usize;

        // Return an empty slice when there are no entries.
        let entries_slice = if ptr.is_null() || len == 0 {
            &[]
        } else {
            // Otherwise, it's the slice from the data.
            // Can we trust the C API to provide a valid pointer and length?
            unsafe { core::slice::from_raw_parts(ptr, len) }
        };

        entries_slice.iter().map(FineTimingMeasurementReportEntry)
    }
}

impl AccessPointProbeRequestReceived<'_> {
    /// Get received probe request SSID.
    pub fn rssi(&self) -> i32 {
        self.0.rssi
    }

    /// Get the MAC address of the station which send probe request.
    pub fn mac(&self) -> &[u8] {
        &self.0.mac
    }
}

impl StationBasicServiceSetReceivedSignalStrengthIndicatorLow<'_> {
    /// Get received probe request SSID of bss.
    pub fn rssi(&self) -> i32 {
        self.0.rssi
    }
}

impl ActionTransmissionStatus<'_> {
    /// Get Wi-Fi interface to send request to.
    pub fn ifx(&self) -> u32 {
        self.0.ifx
    }

    /// Get context to identify the request.
    pub fn context(&self) -> u32 {
        self.0.context
    }

    /// ID of the corresponding operation that was provided during action tx request.
    pub fn op_id(&self) -> u8 {
        self.0.op_id
    }

    /// Channel provided in tx request.
    pub fn channel(&self) -> u8 {
        self.0.channel
    }

    /// Get the status of the operation.
    pub fn status(&self) -> u32 {
        self.0.status
    }
}

impl RemainOnChannelDone<'_> {
    /// Get context to identify the request.
    pub fn context(&self) -> u32 {
        self.0.context
    }

    /// Get the status of the operation.
    pub fn status(&self) -> u32 {
        self.0.status
    }

    /// ID of the corresponding operation.
    pub fn op_id(&self) -> u8 {
        self.0.op_id
    }

    /// Channel provided.
    pub fn channel(&self) -> u8 {
        self.0.channel
    }
}

impl AccessPointWifiProtectedStatusRegistrarSuccess<'_> {
    /// Get enrollee mac address.
    pub fn peer_mac(&self) -> &[u8] {
        &self.0.peer_macaddr
    }
}

impl AccessPointWifiProtectedStatusRegistrarFailed<'_> {
    /// Get WPS failure reason.
    pub fn reason(&self) -> u32 {
        self.0.reason
    }

    /// Get enrollee mac address.
    pub fn peer_macaddr(&self) -> &[u8; 6] {
        &self.0.peer_macaddr
    }
}

impl AccessPointWifiProtectedStatusRegistrarPin<'_> {
    /// Get the PIN code of station in enrollee mode.
    pub fn pin_code(&self) -> &[u8] {
        &self.0.pin_code
    }
}

impl NeighborAwarenessNetworkingServiceMatch<'_> {
    /// Get the Subscribe Service ID.
    pub fn subscribe_id(&self) -> u8 {
        self.0.subscribe_id
    }

    /// Get the Publish Service ID.
    pub fn publish_id(&self) -> u8 {
        self.0.publish_id
    }

    /// Get the NAN Interface MAC of the Publisher.
    pub fn pub_if_mac(&self) -> &[u8] {
        &self.0.pub_if_mac
    }

    /// Indicates whether publisher’s service ID needs to be updated.
    pub fn update_pub_id(&self) -> bool {
        self.0.update_pub_id
    }
}

impl NeighborAwarenessNetworkingReplied<'_> {
    /// Get the Subscribe Service ID.
    pub fn subscribe_id(&self) -> u8 {
        self.0.subscribe_id
    }

    /// Get the Publish Service ID.
    pub fn publish_id(&self) -> u8 {
        self.0.publish_id
    }

    /// Get the NAN Interface MAC of the Subscriber.
    pub fn sub_if_mac(&self) -> &[u8] {
        &self.0.sub_if_mac
    }
}

impl NeighborAwarenessNetworkingReceive<'_> {
    /// Get Our Service Identifier.
    pub fn inst_id(&self) -> u8 {
        self.0.inst_id
    }

    /// Get Peer's Service Identifier.
    pub fn peer_inst_id(&self) -> u8 {
        self.0.peer_inst_id
    }

    /// Get Peer’s NAN Interface MAC
    pub fn peer_if_mac(&self) -> &[u8; 6] {
        &self.0.peer_if_mac
    }

    /// Get Peer Service Info.
    pub fn peer_svc_info(&self) -> &[u8; 64] {
        &self.0.peer_svc_info
    }
}

impl NeighborDiscoveryProtocolIndication<'_> {
    /// Get Publish ID for NAN Service.
    pub fn publish_id(&self) -> u8 {
        self.0.publish_id
    }

    /// Get NDF instance ID.
    pub fn ndp_id(&self) -> u8 {
        self.0.ndp_id
    }

    /// Get Peer’s NAN Interface MAC.
    pub fn peer_nmi(&self) -> &[u8; 6] {
        &self.0.peer_nmi
    }

    /// Get Peer’s NAN Data Interface MAC.
    pub fn peer_ndi(&self) -> &[u8; 6] {
        &self.0.peer_ndi
    }

    /// Get Service Specific Info.
    pub fn svc_info(&self) -> &[u8; 64] {
        &self.0.svc_info
    }
}

impl NeighborDiscoveryProtocolConfirmation<'_> {
    /// Get NDP status code.
    pub fn status(&self) -> u8 {
        self.0.status
    }

    /// Get NDP instance ID.
    pub fn id(&self) -> u8 {
        self.0.ndp_id
    }

    /// Get Peer’s NAN Management Interface MAC.
    pub fn peer_nmi(&self) -> &[u8; 6] {
        &self.0.peer_nmi
    }

    /// Get Peer’s NAN Data Interface MAC.
    pub fn peer_ndi(&self) -> &[u8; 6] {
        &self.0.peer_ndi
    }

    /// Get Own NAN Data Interface MAC.
    pub fn own_ndi(&self) -> &[u8; 6] {
        &self.0.own_ndi
    }

    /// Get Service Specific Info.
    pub fn svc_info(&self) -> &[u8; 64] {
        &self.0.svc_info
    }
}

impl NeighborDiscoveryProtocolTerminated<'_> {
    /// Get termination reason code.
    pub fn reason(&self) -> u8 {
        self.0.reason
    }

    /// Get NDP instance ID.
    pub fn id(&self) -> u8 {
        self.0.ndp_id
    }

    /// Get Initiator’s NAN Data Interface MAC
    pub fn init_ndi(&self) -> &[u8; 6] {
        &self.0.init_ndi
    }
}

impl HomeChannelChange<'_> {
    /// Get the old home channel of the device.
    pub fn old_chan(&self) -> u8 {
        self.0.old_chan
    }

    /// Get the old second channel of the device.
    pub fn old_snd(&self) -> u32 {
        self.0.old_snd
    }

    /// Get the new home channel of the device.
    pub fn new_chan(&self) -> u8 {
        self.0.new_chan
    }

    /// Get the new second channel of the device.
    pub fn new_snd(&self) -> u32 {
        self.0.new_snd
    }
}

impl StationNeighborRep<'_> {
    /// Get the Neighbor Report received from the access point.
    pub fn report(&self) -> &[u8] {
        &self.0.report[..self.0.report_len as usize]
    }

    /// Get the length of report.
    pub fn report_len(&self) -> u16 {
        self.0.report_len
    }
}

/// Detailed FTM report entry.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[instability::unstable]
pub struct FineTimingMeasurementReportInfo {
    /// Dialog Token of the FTM frame
    pub dlog_token: u8,
    /// RSSI of the FTM frame received
    pub rssi: i8,
    /// Round Trip Time in pSec with a peer
    pub rtt: u32,
    /// Time of departure of FTM frame from FTM Responder in pSec
    pub t1: u64,
    /// Time of arrival of FTM frame at FTM Initiator in pSec
    pub t2: u64,
    /// Time of departure of ACK from FTM Initiator in pSec
    pub t3: u64,
    /// Time of arrival of ACK at FTM Responder in pSec
    pub t4: u64,
}

/// Credential info record.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[instability::unstable]
pub struct CredentialsInfo {
    /// SSID of AP
    pub ssid: Ssid,
    /// Passphrase for the AP
    pub passphrase: [u8; 64usize],
}

/// A collection of elements.
#[derive(Debug, Clone)]
pub struct Collection<T>(alloc::vec::Vec<T>);

impl<T> Collection<T> {
    /// The elements of this collection.
    pub fn as_slice(&self) -> &[T] {
        self.0.as_slice()
    }
}

#[cfg(feature = "defmt")]
impl<T: defmt::Format> defmt::Format for Collection<T> {
    fn format(&self, fmt: defmt::Formatter<'_>) {
        self.0.iter().for_each(|v| {
            defmt::write!(fmt, "{}", v);
        });
    }
}

/// Event including the payload.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[instability::unstable]
pub enum EventInfo {
    /// Wi-Fi is ready for operation.
    WifiReady,

    /// Scan operation has completed.
    ScanDone {
        /// Status of scanning APs: 0 — success, 1 - failure
        status: u32,
        /// Number of scan results
        number: u8,
        /// Scan sequence number, used for block scan
        scan_id: u8,
    },

    /// Station mode started.
    StationStart,

    /// Station mode stopped.
    StationStop,

    /// Station connected to a network.
    StationConnected {
        /// SSID of connected AP
        ssid: Ssid,
        /// BSSID of connected AP
        bssid: [u8; 6usize],
        /// Channel of connected AP
        channel: u8,
        /// Authentication mode used by the connection
        authmode: u32,
        /// Authentication id assigned by the connected AP
        aid: u16,
    },

    /// Station disconnected from a network.
    StationDisconnected {
        /// SSID of disconnected AP
        ssid: Ssid,
        /// BSSID of disconnected AP
        bssid: [u8; 6usize],
        /// Disconnection reason
        reason: u16,
        /// Disconnection RSSI
        rssi: i8,
    },

    /// Station authentication mode changed.
    StationAuthenticationModeChange {
        /// Old auth mode of AP
        old_mode: u32,
        /// New auth mode of AP
        new_mode: u32,
    },

    /// Station Wi-Fi-Protected-Status succeeds in enrollee mode.
    StationWifiProtectedStatusEnrolleeSuccess {
        /// Credentials
        credentials: Collection<CredentialsInfo>,
    },

    /// Station Wi-Fi-Protected-Status fails in enrollee mode.
    StationWifiProtectedStatusEnrolleeFailed,

    /// Station Wi-Fi-Protected-Status timeout in enrollee mode.
    StationWifiProtectedStatusEnrolleeTimeout,

    /// Station Wi-Fi-Protected-Status pin code in enrollee mode.
    StationWifiProtectedStatusEnrolleePin {
        /// PIN code of station in enrollee mode
        pin_code: [u8; 8usize],
    },

    /// Station Wi-Fi-Protected-Status overlap in enrollee mode.
    StationWifiProtectedStatusEnrolleePushButtonConfigurationOverlap,

    /// Soft-AccessPoint start.
    AccessPointStart,

    /// Soft-AccessPoint stop.
    AccessPointStop,

    /// A station connected to Soft-AccessPoint.
    AccessPointStationConnected {
        /// MAC address of the station connected to Soft-AP
        mac: [u8; 6usize],
        /// AID assigned by the Soft-AP to the connected station
        aid: u16,
        /// Flag indicating whether the connected station is a mesh child
        is_mesh_child: bool,
    },

    /// A station disconnected from Soft-AccessPoint.
    AccessPointStationDisconnected {
        /// MAC address of the station disconnects from the soft-AP
        mac: [u8; 6usize],
        /// AID that the Soft-AP assigned to the disconnected station
        aid: u8,
        /// Flag indicating whether the disconnected station is a mesh child
        is_mesh_child: bool,
        /// Disconnection reason
        reason: u16,
    },

    /// Received probe request packet in Soft-AccessPoint interface.
    AccessPointProbeRequestReceived {
        /// Received probe request signal strength
        rssi: i8,
        /// MAC address of the station which send probe request
        mac: [u8; 6usize],
    },

    /// Received report of Fine-Timing-Measurement procedure.
    FineTimingMeasurementReport {
        /// MAC address of the FTM Peer
        peer_mac: [u8; 6usize],
        /// Status of the FTM operation
        status: u32,
        /// Raw average Round-Trip-Time with peer in Nano-Seconds
        rtt_raw: u32,
        /// Estimated Round-Trip-Time with peer in Nano-Seconds
        rtt_est: u32,
        /// Estimated one-way distance in Centi-Meters
        dist_est: u32,
        /// Detailed FTM report entries.
        entries: Collection<FineTimingMeasurementReportInfo>,
    },

    /// Station Receive-Signal-Strenght-Indicator goes below the configured threshold.
    StationBasicServiceSetReceivedSignalStrengthIndicatorLow {
        /// RSSI value of bss
        rssi: i8,
    },

    /// Status indication of Action Transmission operation.
    ActionTransmissionStatus {
        /// WiFi interface to send request to
        ifx: u32,
        /// Context to identify the request
        context: u32,
        /// Status of the operation
        status: u32,
        /// ID of the corresponding operation that was provided during action tx request
        op_id: u8,
        /// Channel provided in tx request
        channel: u8,
    },

    /// Remain-on-Channel operation complete.
    RemainOnChannelDone {
        /// Context to identify the initiator of the request
        context: u32,
        /// ROC status
        status: u32,
        /// ID of the corresponding ROC operation
        op_id: u8,
        /// Channel provided in tx request
        channel: u8,
    },

    /// Station beacon timeout.
    StationBeaconTimeout,

    /// Connectionless module wake interval has started.
    ConnectionlessModuleWakeIntervalStart,

    /// Soft-AccessPoint Wi-Fi-Protected-Status succeeded in registrar mode.
    AccessPointWifiProtectedStatusRegistrarSuccess {
        /// Enrollee mac address
        peer_macaddr: [u8; 6usize],
    },

    /// Soft-AccessPoint Wi-Fi-Protected-Status failed in registrar mode.
    AccessPointWifiProtectedStatusRegistrarFailed {
        /// WPS failure reason wps_fail_reason_t
        reason: u32,
        /// Enrollee mac address
        peer_macaddr: [u8; 6usize],
    },

    /// Soft-AccessPoint Wi-Fi-Protected-Status timed out in registrar mode.
    AccessPointWifiProtectedStatusRegistrarTimeout,

    /// Soft-AccessPoint Wi-Fi-Protected-Status pin code in registrar mode.
    AccessPointWifiProtectedStatusRegistrarPin {
        /// PIN code of station in enrollee mode
        pin_code: [u8; 8usize],
    },

    /// Soft-AccessPoint Wi-Fi-Protected-Status overlap in registrar mode.
    AccessPointWifiProtectedStatusRegistrarPushButtonConfigurationOverlap,

    /// Individual Target-Wake-Time setup.
    IndividualTargetWakeTimeSetup,

    /// Individual Target-Wake-Time teardown.
    IndividualTargetWakeTimeTeardown,

    /// Individual Target-Wake-Time probe.
    IndividualTargetWakeTimeProbe,

    /// Individual Target-Wake-Time suspended.
    IndividualTargetWakeTimeSuspend,

    /// Target-Wake-Wakeup event.
    TargetWakeTimeWakeup,

    /// Broadcast-Target-Wake-Time setup.
    BroadcastTargetWakeTimeSetup,

    /// Broadcast-Target-Wake-Time teardown.
    BroadcastTargetWakeTimeTeardown,

    // we don't currently support NAN - and there is no intention right now to change that
    /// Wi-Fi home channel change, doesn't occur when scanning.
    HomeChannelChange,
}

impl EventInfo {
    pub(crate) fn from_wifi_event_raw(
        event: WifiEvent,
        payload: *mut crate::sys::c_types::c_void,
    ) -> Option<Self> {
        let enabled = WIFI_EVENT_ENABLE_MASK.with(|mask| mask.contains(event));

        if !enabled {
            return None;
        }

        match event {
            WifiEvent::WifiReady => Some(EventInfo::WifiReady),
            WifiEvent::ScanDone => {
                let ev = unsafe { ScanDone::from_raw_event_data(payload) };

                Some(EventInfo::ScanDone {
                    status: ev.status(),
                    number: ev.number(),
                    scan_id: ev.id(),
                })
            }
            WifiEvent::StationStart => Some(EventInfo::StationStart),
            WifiEvent::StationStop => Some(EventInfo::StationStop),
            WifiEvent::StationConnected => {
                let ev = unsafe { StationConnected::from_raw_event_data(payload) };

                Some(EventInfo::StationConnected {
                    ssid: Ssid::from_raw(ev.ssid(), ev.ssid_len()),
                    bssid: ev.bssid().try_into().unwrap(),
                    channel: ev.channel(),
                    authmode: ev.authmode(),
                    aid: ev.aid(),
                })
            }
            WifiEvent::StationDisconnected => {
                let ev = unsafe { StationDisconnected::from_raw_event_data(payload) };
                Some(EventInfo::StationDisconnected {
                    ssid: Ssid::from_raw(ev.ssid(), ev.ssid_len()),
                    bssid: ev.bssid().try_into().unwrap(),
                    reason: ev.reason() as u16,
                    rssi: ev.rssi(),
                })
            }
            WifiEvent::AccessPointStart => Some(EventInfo::AccessPointStart),
            WifiEvent::AccessPointStop => Some(EventInfo::AccessPointStop),
            WifiEvent::AccessPointStationConnected => {
                let ev = unsafe { AccessPointStationConnected::from_raw_event_data(payload) };
                Some(EventInfo::AccessPointStationConnected {
                    mac: ev.mac().try_into().unwrap(),
                    aid: ev.aid() as u16,
                    is_mesh_child: ev.is_mesh_child(),
                })
            }
            WifiEvent::AccessPointStationDisconnected => {
                let ev = unsafe { AccessPointStationDisconnected::from_raw_event_data(payload) };
                Some(EventInfo::AccessPointStationDisconnected {
                    mac: ev.mac().try_into().unwrap(),
                    aid: ev.aid(),
                    is_mesh_child: ev.is_mesh_child(),
                    reason: ev.reason(),
                })
            }
            WifiEvent::StationAuthenticationModeChange => {
                let ev = unsafe { StationAuthenticationModeChange::from_raw_event_data(payload) };
                Some(EventInfo::StationAuthenticationModeChange {
                    old_mode: ev.old_mode(),
                    new_mode: ev.new_mode(),
                })
            }
            WifiEvent::StationWifiProtectedStatusEnrolleeSuccess => {
                let ev = unsafe {
                    StationWifiProtectedStatusEnrolleeSuccess::from_raw_event_data(payload)
                };
                Some(EventInfo::StationWifiProtectedStatusEnrolleeSuccess {
                    credentials: Collection(ev
                        .access_point_cred()[..ev.access_point_cred_cnt() as usize].iter()
                        .map(|cred| CredentialsInfo {
                            ssid: cred.ssid().into(),
                            passphrase: cred.passphrase().try_into().unwrap(),
                        })
                        .collect()),
                })
            }
            WifiEvent::StationWifiProtectedStatusEnrolleeFailed => {
                Some(EventInfo::StationWifiProtectedStatusEnrolleeFailed)
            }
            WifiEvent::StationWifiProtectedStatusEnrolleeTimeout => {
                Some(EventInfo::StationWifiProtectedStatusEnrolleeTimeout)
            }
            WifiEvent::StationWifiProtectedStatusEnrolleePin => {
                let ev =
                    unsafe { StationWifiProtectedStatusEnrolleePin::from_raw_event_data(payload) };
                Some(EventInfo::StationWifiProtectedStatusEnrolleePin {
                    pin_code: ev.pin().try_into().unwrap_or_default(),
                })
            }
            WifiEvent::StationWifiProtectedStatusEnrolleePushButtonConfigurationOverlap => {
                Some(EventInfo::StationWifiProtectedStatusEnrolleePushButtonConfigurationOverlap)
            }
            WifiEvent::AccessPointProbeRequestReceived => {
                let ev = unsafe { AccessPointProbeRequestReceived::from_raw_event_data(payload) };
                Some(EventInfo::AccessPointProbeRequestReceived {
                    rssi: ev.rssi() as i8,
                    mac: ev.mac().try_into().unwrap_or_default(),
                })
            }
            WifiEvent::FineTimingMeasurementReport => {
                let ev = unsafe { FineTimingMeasurementReport::from_raw_event_data(payload) };
                Some(EventInfo::FineTimingMeasurementReport {
                    peer_mac: ev.peer_mac().try_into().unwrap_or_default(),
                    status: ev.status(),
                    rtt_raw: ev.rtt_raw(),
                    rtt_est: ev.rtt_est(),
                    dist_est: ev.dist_est(),
                    entries: Collection(ev
                        .entries()
                        .map(|entry| FineTimingMeasurementReportInfo {
                            dlog_token: entry.dialog_token(),
                            rssi: entry.rssi(),
                            rtt: entry.rtt(),
                            t1: entry.t1(),
                            t2: entry.t2(),
                            t3: entry.t3(),
                            t4: entry.t4(),
                        })
                        .collect()),
                })
            }
            WifiEvent::StationBasicServiceSetReceivedSignalStrengthIndicatorLow => {
                let ev = unsafe {
                    StationBasicServiceSetReceivedSignalStrengthIndicatorLow::from_raw_event_data(
                        payload,
                    )
                };
                Some(
                    EventInfo::StationBasicServiceSetReceivedSignalStrengthIndicatorLow {
                        rssi: ev.rssi() as i8,
                    },
                )
            }
            WifiEvent::ActionTransmissionStatus => {
                let ev = unsafe { ActionTransmissionStatus::from_raw_event_data(payload) };
                Some(EventInfo::ActionTransmissionStatus {
                    ifx: ev.ifx(),
                    context: ev.context(),
                    status: ev.status(),
                    op_id: ev.op_id(),
                    channel: ev.channel(),
                })
            }
            WifiEvent::RemainOnChannelDone => {
                let ev = unsafe { RemainOnChannelDone::from_raw_event_data(payload) };
                Some(EventInfo::RemainOnChannelDone {
                    context: ev.context(),
                    status: ev.status(),
                    op_id: ev.op_id(),
                    channel: ev.channel(),
                })
            }
            WifiEvent::StationBeaconTimeout => Some(EventInfo::StationBeaconTimeout),
            WifiEvent::ConnectionlessModuleWakeIntervalStart => {
                Some(EventInfo::ConnectionlessModuleWakeIntervalStart)
            }
            WifiEvent::AccessPointWifiProtectedStatusRegistrarSuccess => {
                let ev = unsafe {
                    AccessPointWifiProtectedStatusRegistrarSuccess::from_raw_event_data(payload)
                };
                Some(EventInfo::AccessPointWifiProtectedStatusRegistrarSuccess {
                    peer_macaddr: ev.peer_mac().try_into().unwrap_or_default(),
                })
            }
            WifiEvent::AccessPointWifiProtectedStatusRegistrarFailed => {
                let ev = unsafe {
                    AccessPointWifiProtectedStatusRegistrarFailed::from_raw_event_data(payload)
                };
                Some(EventInfo::AccessPointWifiProtectedStatusRegistrarFailed {
                    reason: ev.reason(),
                    peer_macaddr: *ev.peer_macaddr(),
                })
            }
            WifiEvent::AccessPointWifiProtectedStatusRegistrarTimeout => {
                Some(EventInfo::AccessPointWifiProtectedStatusRegistrarTimeout)
            }
            WifiEvent::AccessPointWifiProtectedStatusRegistrarPin => {
                let ev = unsafe {
                    AccessPointWifiProtectedStatusRegistrarPin::from_raw_event_data(payload)
                };
                Some(EventInfo::AccessPointWifiProtectedStatusRegistrarPin {
                    pin_code: ev.pin_code().try_into().unwrap_or_default(),
                })
            }
            WifiEvent::AccessPointWifiProtectedStatusRegistrarPushButtonConfigurationOverlap => {
                Some(EventInfo::AccessPointWifiProtectedStatusRegistrarPushButtonConfigurationOverlap)
            }
            WifiEvent::IndividualTargetWakeTimeSetup => {
                Some(EventInfo::IndividualTargetWakeTimeSetup)
            }
             WifiEvent::IndividualTargetWakeTimeTeardown => {
                Some(EventInfo::IndividualTargetWakeTimeTeardown)
            }
            WifiEvent::IndividualTargetWakeTimeProbe => {
                Some(EventInfo::IndividualTargetWakeTimeProbe)
            }
            WifiEvent::IndividualTargetWakeTimeSuspend => {
                Some(EventInfo::IndividualTargetWakeTimeSuspend)
            }
            WifiEvent::TargetWakeTimeWakeup => {
                Some(EventInfo::TargetWakeTimeWakeup)
            }
            WifiEvent::BroadcastTargetWakeTimeSetup => {
                Some(EventInfo::BroadcastTargetWakeTimeSetup)
            }
            WifiEvent::BroadcastTargetWakeTimeTeardown => {
                Some(EventInfo::BroadcastTargetWakeTimeTeardown)
            }
            WifiEvent::HomeChannelChange => {
                Some(EventInfo::HomeChannelChange)
            }
            _ => None,
        }
    }
}

/// Enable the given events.
#[instability::unstable]
pub fn enable_wifi_events(events: EnumSet<WifiEvent>) {
    WIFI_EVENT_ENABLE_MASK.with(|mask| *mask |= events);
}

/// Disable the given events.
///
/// # Attention
/// Disabling events which are used internally will cause problems.
///
/// Therefore you usually don't want to disable these:
/// - [WifiEvent::StationStart]
/// - [WifiEvent::StationStop]
/// - [WifiEvent::StationConnected]
/// - [WifiEvent::StationDisconnected]
/// - [WifiEvent::AccessPointStart]
/// - [WifiEvent::AccessPointStop]
/// - [WifiEvent::ScanDone]
///
/// [crate::wifi::new] always enables these events, even if they were disabled beforehand.
#[instability::unstable]
pub fn disable_wifi_events(events: EnumSet<WifiEvent>) {
    WIFI_EVENT_ENABLE_MASK.with(|mask| *mask &= !events);
}

/// Result for [EventSubscriber::next_message].
#[derive(Debug, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[instability::unstable]
pub enum MessageResult {
    /// The subscriber did not receive all messages and lagged by the given amount of messages.
    /// (This is the amount of messages that were missed)
    Lagged(u64),
    /// The received event.
    Message(EventInfo),
}

/// Event subscriber.
#[instability::unstable]
pub struct EventSubscriber<'a> {
    inner: embassy_sync::pubsub::Subscriber<
        'a,
        esp_sync::RawMutex,
        EventInfo,
        { esp_config_int!(usize, "ESP_RADIO_CONFIG_EVENT_CHANNEL_CAPACITY") },
        { esp_config_int!(usize, "ESP_RADIO_CONFIG_EVENT_CHANNEL_SUBSCRIBERS") },
        1,
    >,
}

impl<'a> EventSubscriber<'a> {
    pub(crate) fn new(
        subscriber: embassy_sync::pubsub::Subscriber<
            'a,
            esp_sync::RawMutex,
            EventInfo,
            { esp_config_int!(usize, "ESP_RADIO_CONFIG_EVENT_CHANNEL_CAPACITY") },
            { esp_config_int!(usize, "ESP_RADIO_CONFIG_EVENT_CHANNEL_SUBSCRIBERS") },
            1,
        >,
    ) -> Self {
        Self { inner: subscriber }
    }

    /// Wait for a published event
    pub async fn next_event(&mut self) -> MessageResult {
        match self.inner.next_message().await {
            embassy_sync::pubsub::WaitResult::Lagged(missed) => MessageResult::Lagged(missed),
            embassy_sync::pubsub::WaitResult::Message(msg) => MessageResult::Message(msg),
        }
    }

    /// Wait for a published event (ignoring lag results)
    pub async fn next_event_pure(&mut self) -> EventInfo {
        self.inner.next_message_pure().await
    }
}
