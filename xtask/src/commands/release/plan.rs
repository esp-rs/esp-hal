use std::{collections::HashMap, io::Write, path::Path, process::Command};

use anyhow::{Context, Result, bail, ensure};
use cargo_semver_checks::ReleaseType;
use clap::Args;
use esp_metadata::Chip;
use serde::{Deserialize, Serialize};
use strum::IntoEnumIterator;

use crate::{
    Package,
    cargo::CargoToml,
    commands::{VersionBump, checker::min_package_update, do_version_bump},
    git::current_branch,
};

#[derive(Debug, Args)]
pub struct PlanArgs {
    /// Allow making a release from the current (non-main) branch. The
    /// branch is expected to exist in the upstream esp-hal repo.
    #[arg(long)]
    allow_non_main: bool,

    /// The packages to be released.
    #[arg(value_enum, default_values_t = Package::iter())]
    packages: Vec<Package>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct PackagePlan {
    pub package: Package,
    pub semver_checked: bool,
    pub current_version: semver::Version,
    pub new_version: semver::Version,
    pub tag_name: String,
    /// The version bump that will be applied to the package.
    pub bump: VersionBump,
}

/// A release plan is a list of packages and their version increments.
///
/// The plan is generated by analyzing the workspace and its dependencies.
/// The order of the packages in the plan is important, as it determines the
/// order in which the packages are released.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Plan {
    pub base: String,
    pub packages: Vec<PackagePlan>,
}

impl Plan {
    pub fn from_path(plan_path: &Path) -> Result<Self> {
        let plan_source = std::fs::read_to_string(&plan_path)
            .with_context(|| format!("Failed to read release plan from {}. Run `cargo xrelease plan` to generate a release plan.", plan_path.display()))?;

        if plan_source.lines().any(|line| line.starts_with("//")) {
            bail!(
                "The release plan has not been finalized. Please open the plan and follow the instructions in it."
            );
        }

        let plan = serde_json::from_str::<Plan>(&plan_source).with_context(|| {
            format!("Failed to parse release plan from {}", plan_path.display())
        })?;

        Ok(plan)
    }
}

pub fn plan(workspace: &Path, args: PlanArgs) -> Result<()> {
    let current_branch = ensure_main_branch(args.allow_non_main)?;

    // Recursively collect dependencies. A bit inefficient, but we don't need to
    // sort a lot.
    let mut packages_to_release = args
        .packages
        .iter()
        .filter(|p| p.is_published(workspace))
        .flat_map(|p| related_crates(workspace, *p))
        .collect::<Vec<_>>();

    packages_to_release.sort();
    packages_to_release.dedup();

    let mut package_tomls = packages_to_release
        .iter()
        .map(|pkg| CargoToml::new(workspace, *pkg).map(|cargo_toml| (*pkg, cargo_toml)))
        .collect::<Result<HashMap<_, _>>>()?;

    // Determine package dependencies (package -> dependencies)
    let mut dep_graph = HashMap::new();
    for (package, toml) in package_tomls.iter_mut() {
        dep_graph.insert(*package, toml.repo_dependencies());
    }

    // Topological sort the packages into a release order.
    let sorted = topological_sort(&dep_graph);
    log::debug!("Sorted packages: {:?}", sorted);

    for package in sorted.iter() {
        ensure!(
            package_tomls[&package].is_published(),
            "Cannot release {package}: package is not published. The command \
            would have released the following packages: {}",
            sorted
                .iter()
                .map(|p| p.to_string())
                .collect::<Vec<_>>()
                .join(", ")
        );
    }

    // Gather semver bump requirements
    let mut update_amounts = vec![];
    let all_chips = Chip::iter().collect::<Vec<_>>();
    for package in sorted.iter().copied() {
        let amount = if package_changed_since_last_release(workspace, package) {
            let amount = if package.is_semver_checked() {
                min_package_update(workspace, package, &all_chips)?
            } else {
                ReleaseType::Minor
            };
            log::debug!("{} needs {:?} version bump", package, amount);
            Some(amount)
        } else {
            log::debug!("{} has no changes since last release", package);
            None
        };

        update_amounts.push((package, amount));
    }

    // Generate plan file. The plan should include, as an ordered list, the packages
    // and their version increment.

    let plan = Plan {
        base: current_branch,
        packages: update_amounts
            .into_iter()
            .filter_map(|(package, bump)| {
                bump.map(|b| {
                    let current_version = package_tomls[&package].package_version();

                    let bump = if !current_version.pre.is_empty() {
                        VersionBump::PreRelease(
                            current_version
                                .pre
                                .as_str()
                                .split('.')
                                .next()
                                .unwrap()
                                .to_string(),
                        )
                    } else {
                        match b {
                            ReleaseType::Major => VersionBump::Major,
                            ReleaseType::Minor => VersionBump::Minor,
                            ReleaseType::Patch => VersionBump::Patch,
                            _ => unreachable!(),
                        }
                    };

                    let new_version = do_version_bump(&current_version, &bump).unwrap();
                    let tag_name = package.tag(&new_version);

                    PackagePlan {
                        package,
                        semver_checked: package.is_semver_checked(),
                        current_version,
                        new_version,
                        tag_name,
                        bump,
                    }
                })
            })
            .collect(),
    };

    let plan_path = workspace.join("release_plan.jsonc");
    let plan_path = crate::windows_safe_path(&plan_path);
    log::debug!("Writing release plan to {}", plan_path.display());

    let plan_header = String::from(
        r#"// Release plan generated by xtask.
//
// This file is automatically generated and meant to be manually edited. Change the version bump
// where appropriate. Remove packages that should not be released. Delete the comment block to
// finalize the release plan, otherwise trying to apply the release plan will fail.
//
// This file contains each package that needs to be released. The order of the packages is
// important, the packages will be released in the order they appear in the release plan.
// This is done in case the tool gets the dependency graph wrong.
//
// This plan may also contain packages that do not need to be released. Please review them
// in case the release was triggered by commits that only included non-relevant changes. These
// packages can be removed from the plan.
//
// You don't need to change versions and tag names. The plan will be updated when applying the
// release plan. The release plan will then be added to the release PR and will be used to
// orchestrate the actual publishing process.
//
// For each package, this plan contains the version bump that will be applied.
// The version bump is one of:
// - PreRelease (`"bump": { "PreRelease": "beta" }`)
// - Patch (`"bump": "Patch"`)
// - Minor (`"bump": "Minor"`)
// - Major (`"bump": "Major"`)
"#,
    );

    let mut plan_file = std::fs::File::create(&plan_path)?;
    plan_file.write_all(plan_header.as_bytes())?;
    serde_json::to_writer_pretty(&mut plan_file, &plan)?;
    log::debug!("Release plan written to {}", plan_path.display());

    println!("Release plan written to {}.", plan_path.display());
    println!("Please review the release plan and make changes where appropriate.");
    println!(
        "To apply the release plan, you'll need to remove the heading comment, save the \
        file, then run the following command: `cargo xrelease execute-plan`",
    );

    Ok(())
}

pub fn ensure_main_branch(allow_non_main: bool) -> Result<String> {
    let current_branch = current_branch()?;

    if allow_non_main {
        println!("Release will be made from branch: {current_branch}");
    } else {
        ensure!(
            current_branch == "main",
            "You are not on the main branch. Please switch to the main branch before running this command again, or add `--allow-non-main`."
        );
    }

    Ok(current_branch)
}

fn package_changed_since_last_release(workspace: &Path, package: Package) -> bool {
    let toml = CargoToml::new(workspace, package).expect("Failed to load Cargo.toml");

    let last_version: semver::Version = toml.package_version();

    let last_tag = package.tag(&last_version);
    let mut commits = commits_since_tag(workspace, &toml.package_path(), &last_tag);

    if commits == 0 {
        // Try to look up the last tag in the git history and retry.
        let last_tag = Command::new("git")
            .args(["describe", "--tags", "--abbrev=0"])
            .current_dir(workspace)
            .output()
            .expect("Failed to get last tag");
        let last_tag = String::from_utf8_lossy(&last_tag.stdout);
        let last_tag = last_tag.trim();

        if !last_tag.is_empty() {
            commits = commits_since_tag(workspace, &toml.package_path(), last_tag);
        }
    }

    log::trace!("{package}: {commits} commits since last release");

    commits > 0
}

fn commits_since_tag(workspace: &Path, package_path: &Path, tag: &str) -> usize {
    let commits = Command::new("git")
        .args([
            "log",
            &format!("{tag}..HEAD"),
            "--oneline",
            &package_path.display().to_string(),
        ])
        .current_dir(workspace)
        .output()
        .expect("Failed to get commit count since last tag");

    let output = String::from_utf8_lossy(&commits.stdout);

    output.lines().filter(|l| !l.trim().is_empty()).count()
}

fn related_crates(workspace: &Path, package: Package) -> Vec<Package> {
    let mut packages = vec![package];

    let mut package = CargoToml::new(workspace, package)
        .map(|cargo_toml| cargo_toml)
        .unwrap();

    for dep in package.repo_dependencies() {
        for dep in related_crates(workspace, dep) {
            if !packages.contains(&dep) {
                packages.push(dep);
            }
        }
    }

    packages
}

fn topological_sort(dep_graph: &HashMap<Package, Vec<Package>>) -> Vec<Package> {
    let mut sorted = Vec::new();
    let mut dep_graph = dep_graph.clone();
    while !dep_graph.is_empty() {
        dep_graph.retain(|pkg, deps| {
            deps.retain(|dep| !sorted.contains(dep));

            if deps.is_empty() {
                sorted.push(*pkg);
                false
            } else {
                true
            }
        });
    }

    sorted
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_topological_sort() {
        let mut dep_graph = HashMap::new();
        dep_graph.insert(Package::EspHal, vec![Package::EspAlloc]);
        dep_graph.insert(
            Package::EspIeee802154,
            vec![Package::EspHal, Package::EspWifi],
        );
        dep_graph.insert(Package::EspWifi, vec![Package::EspHal]);
        dep_graph.insert(Package::EspAlloc, vec![]);

        let sorted = topological_sort(&dep_graph);
        assert_eq!(
            sorted,
            [
                Package::EspAlloc,
                Package::EspHal,
                Package::EspWifi,
                Package::EspIeee802154
            ]
        );
    }
}
