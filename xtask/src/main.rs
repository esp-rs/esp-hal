use std::{
    path::{Path, PathBuf},
    process::Command,
    time::Instant,
};

use anyhow::{Context, Result, bail};
use clap::{Args, Parser};
use esp_metadata::{Chip, Config};
use object::{Object, ObjectSymbol, SymbolKind, read::archive::ArchiveFile};
use rustc_demangle::try_demangle;
use strum::IntoEnumIterator;
use xtask::{
    Package,
    cargo::{CargoAction, CargoArgsBuilder, CargoCommandBatcher},
    commands::*,
    update_metadata,
};

// ----------------------------------------------------------------------------
// Command-line Interface

#[derive(Debug, Parser)]
enum Cli {
    /// Build-related subcommands
    #[clap(subcommand)]
    Build(Build),
    /// Run-related subcommands
    #[clap(subcommand)]
    Run(Run),
    /// Release-related subcommands
    #[clap(subcommand)]
    Release(Release),

    /// Perform (parts of) the checks done in CI
    Ci(CiArgs),
    /// Format all packages in the workspace with rustfmt
    #[clap(alias = "format-packages")]
    FmtPackages(FmtPackagesArgs),
    /// Run cargo clean
    Clean(CleanArgs),
    /// Check all packages in the workspace with cargo check
    CheckPackages(CheckPackagesArgs),
    /// Lint all packages in the workspace with clippy
    LintPackages(LintPackagesArgs),
    /// Semver Checks
    SemverCheck(SemverCheckArgs),
    /// Check the changelog for packages.
    CheckChangelog(CheckChangelogArgs),
    /// Re-generate metadata and the chip support table in the esp-hal README.
    UpdateMetadata(UpdateMetadataArgs),
    /// Run host-tests in the workspace with `cargo test`
    HostTests(HostTestsArgs),
    /// Check global symbols in the compiled `.rlib` of the specified packages for the specified
    /// chips.
    CheckGlobalSymbols(CheckPackagesArgs),
    #[cfg(feature = "report")]
    /// Generate reports from CI data.
    GenerateReport(generate_report::ReportArgs),
    /// Tasks for checking compile tests with a local registry.
    #[cfg(feature = "rel-check")]
    #[clap(subcommand)]
    RelCheck(relcheck::RelCheckCmds),

    /// Start an MCP (Model Context Protocol) server over stdio.
    ///
    /// This exposes safe xtask commands as MCP tools for use by AI agents
    /// and other MCP clients. Release-related commands are not exposed.
    #[cfg(feature = "mcp")]
    ServeMcp,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct CiArgs {
    /// Chip to target.
    #[arg(value_enum)]
    chip: Chip,

    /// The toolchain used to run the lints
    #[arg(long)]
    toolchain: Option<String>,

    /// Whether to skip running lints
    #[arg(long)]
    no_lint: bool,

    /// Whether to skip building documentation
    #[arg(long)]
    no_docs: bool,

    /// Whether to skip checking the crates itself
    #[arg(long)]
    no_check_crates: bool,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct FmtPackagesArgs {
    /// Run in 'check' mode; exists with 0 if formatted correctly, 1 otherwise
    #[arg(long)]
    check: bool,

    /// Package(s) to target.
    #[arg(value_enum, default_values_t = Package::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_packages"))]
    packages: Vec<Package>,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct CleanArgs {
    /// Package(s) to target.
    #[arg(value_enum, default_values_t = Package::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_packages"))]
    packages: Vec<Package>,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct HostTestsArgs {
    /// Package(s) to target.
    #[arg(value_enum, default_values_t = Package::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_packages"))]
    packages: Vec<Package>,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct CheckPackagesArgs {
    /// Package(s) to target.
    #[arg(value_enum, default_values_t = Package::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_packages"))]
    packages: Vec<Package>,

    /// Check for a specific chip
    #[arg(long, value_enum, value_delimiter = ',', default_values_t = Chip::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_chips"))]
    chips: Vec<Chip>,

    /// The toolchain used to run the checks
    #[arg(long)]
    toolchain: Option<String>,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct LintPackagesArgs {
    /// Package(s) to target.
    #[arg(value_enum, default_values_t = Package::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_packages"))]
    packages: Vec<Package>,

    /// Lint for a specific chip
    #[arg(long, value_enum, value_delimiter = ',', default_values_t = Chip::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_chips"))]
    chips: Vec<Chip>,

    /// Automatically apply fixes
    #[arg(long)]
    fix: bool,

    /// The toolchain used to run the lints
    #[arg(long)]
    toolchain: Option<String>,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct CheckChangelogArgs {
    /// Package(s) to tag.
    #[arg(long, value_enum, value_delimiter = ',', default_values_t = Package::iter())]
    #[cfg_attr(feature = "mcp", serde(default = "xtask::mcp::default_packages"))]
    packages: Vec<Package>,

    /// Re-generate the changelog with consistent formatting.
    #[arg(long)]
    normalize: bool,
}

#[derive(Debug, Args)]
#[cfg_attr(feature = "mcp", derive(serde::Deserialize, schemars::JsonSchema))]
struct UpdateMetadataArgs {
    /// Run in 'check' mode; exists with 0 if formatted correctly, 1 otherwise
    #[arg(long)]
    check: bool,
}

// ----------------------------------------------------------------------------
// Application

fn main() -> Result<()> {
    let mut builder =
        env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"));
    builder.target(env_logger::Target::Stdout);
    builder.init();

    let workspace =
        std::env::current_dir().with_context(|| format!("Failed to get the current dir!"))?;
    let target_path = workspace.join("target");

    if std::env::var("CARGO_TARGET_DIR").is_err() {
        unsafe { std::env::set_var("CARGO_TARGET_DIR", target_path.to_str().unwrap()) };
    }

    match Cli::parse() {
        // Build-related subcommands:
        Cli::Build(build) => match build {
            Build::Documentation(args) => build_documentation(&workspace, args),
            #[cfg(feature = "deploy-docs")]
            Build::DocumentationIndex => build_documentation_index(&workspace),
            Build::Examples(args) => examples(&workspace, args, CargoAction::Build(None)),
            Build::Package(args) => build_package(&workspace, args),
            Build::Tests(args) => tests(
                &workspace,
                args,
                CargoAction::Build(Some(target_path.join("tests"))),
            ),
        },

        // Run-related subcommands:
        Cli::Run(run) => match run {
            Run::DocTests(args) => run_doc_tests(&workspace, args),
            Run::Elfs(args) => run_elfs(args),
            Run::Example(args) => examples(&workspace, args, CargoAction::Run),
            Run::Tests(args) => tests(&workspace, args, CargoAction::Run),
        },

        // Release-related subcommands:
        Cli::Release(release) => match release {
            Release::BumpVersion(args) => bump_version(&workspace, args),
            Release::TagReleases(args) => tag_releases(&workspace, args),
            Release::Publish(args) => publish(&workspace, args),
            #[cfg(feature = "release")]
            Release::Plan(args) => plan(&workspace, args),
            #[cfg(feature = "release")]
            Release::ExecutePlan(args) => execute_plan(&workspace, args),
            #[cfg(feature = "release")]
            Release::PublishPlan(args) => publish_plan(&workspace, args),
            #[cfg(feature = "release")]
            Release::PostRelease => post_release(&workspace),
            #[cfg(feature = "release")]
            Release::BumpMsrv(args) => bump_msrv::bump_msrv(&workspace, args),
        },

        Cli::Ci(args) => run_ci_checks(&workspace, args),
        Cli::FmtPackages(args) => fmt_packages(&workspace, args),
        Cli::Clean(args) => clean(&workspace, args),
        Cli::CheckPackages(args) => check_packages(&workspace, args),
        Cli::LintPackages(args) => lint_packages(&workspace, args),
        Cli::SemverCheck(args) => semver_checks(&workspace, args),
        Cli::CheckChangelog(args) => check_changelog(&workspace, &args.packages, args.normalize),
        Cli::UpdateMetadata(args) => update_metadata(&workspace, args.check),
        Cli::HostTests(args) => host_tests(&workspace, args),
        Cli::CheckGlobalSymbols(args) => check_global_symbols(&args.chips),
        #[cfg(feature = "report")]
        Cli::GenerateReport(args) => generate_report::generate_report(&workspace, args),
        #[cfg(feature = "rel-check")]
        Cli::RelCheck(relcheck) => relcheck::run_rel_check(relcheck),

        #[cfg(feature = "mcp")]
        Cli::ServeMcp => {
            let commands = build_mcp_registry();
            xtask::mcp::server::run(&workspace, commands)
        }
    }
}

// ----------------------------------------------------------------------------
// Subcommands

fn fmt_packages(workspace: &Path, args: FmtPackagesArgs) -> Result<()> {
    let mut packages = args.packages;
    packages.sort();

    for package in packages {
        xtask::format_package(workspace, package, args.check, None)?;
    }

    // format ymls in .github/
    xtask::format_yml(args.check, "./.github")?;

    Ok(())
}

fn clean(workspace: &Path, args: CleanArgs) -> Result<()> {
    let mut packages = args.packages;
    packages.sort();

    for package in packages {
        let path = workspace.join(package.to_string());
        for dir in walkdir::WalkDir::new(path) {
            if let Ok(dir) = dir
                && let path = dir.path()
                && path.join("Cargo.toml").exists()
            {
                log::info!("Cleaning folder: {}", path.display());
                let cargo_args = CargoArgsBuilder::default()
                    .subcommand("clean")
                    .arg("--target-dir")
                    .arg(path.join("target").display().to_string())
                    .build();

                xtask::cargo::run(&cargo_args, &path).with_context(|| {
                    format!(
                        "Failed to run `cargo run` with {cargo_args:?} in {}",
                        path.display()
                    )
                })?;
            }
        }
    }

    Ok(())
}

fn check_packages(workspace: &Path, args: CheckPackagesArgs) -> Result<()> {
    log::debug!("Checking packages: {:?}", args.packages);
    let mut packages = args.packages;
    packages.sort();

    let mut commands = CargoCommandBatcher::new();

    for package in packages.iter().filter(|p| p.is_published()) {
        // Unfortunately each package has its own unique requirements for
        // building, so we need to handle each individually (though there
        // is *some* overlap)
        for chip in &args.chips {
            log::debug!("  for chip: {}", chip);
            let device = Config::for_chip(chip);

            if let Err(e) = package.validate_package_chip(chip) {
                log::warn!("{e}. Skipping");
                continue;
            }

            for mut features in package.check_feature_rules(device) {
                if package.has_chip_features() {
                    features.push(device.name())
                }

                commands.push(build_check_package_command(
                    workspace,
                    *package,
                    chip,
                    &["--no-default-features"],
                    &features,
                    args.toolchain.as_deref(),
                )?);
            }
        }
    }

    for c in commands.build(false) {
        println!(
            "Command: cargo {}",
            c.command.join(" ").replace("---", "\n    ---")
        );
        c.run(false)?;
    }

    Ok(())
}

fn build_check_package_command(
    workspace: &Path,
    package: Package,
    chip: &Chip,
    args: &[&str],
    features: &[String],
    mut toolchain: Option<&str>,
) -> Result<CargoArgsBuilder> {
    log::info!(
        "Linting package: {} ({}, features: {:?})",
        package,
        chip,
        features
    );

    let path = workspace.join(package.to_string());

    let mut builder = CargoArgsBuilder::default()
        .subcommand("check")
        .manifest_path(path.join("Cargo.toml"));

    if !package.build_on_host(features) {
        if chip.is_xtensa() {
            // In case the user doesn't specify a toolchain, make sure we use +esp
            toolchain.get_or_insert("esp");
        }
        builder = builder.target(package.target_triple(chip)?);
    }

    if let Some(toolchain) = toolchain {
        if !package.build_on_host(features) && toolchain.starts_with("esp") {
            builder = builder.config("-Zbuild-std=core,alloc");
        }
        builder = builder.toolchain(toolchain);
    }

    builder = builder.args(&args);

    if !features.is_empty() {
        builder = builder.arg(format!("--features={}", features.join(",")));
    }

    // TODO: these should come from the outside
    builder.add_env_var("CI", "1");
    builder.add_env_var("DEFMT_LOG", "trace");
    builder.add_env_var("ESP_LOG", "trace");

    Ok(builder)
}

fn lint_packages(workspace: &Path, args: LintPackagesArgs) -> Result<()> {
    log::debug!("Linting packages: {:?}", args.packages);
    let mut packages = args.packages;
    packages.sort();

    for package in packages.iter().filter(|p| p.is_published()) {
        // Unfortunately each package has its own unique requirements for
        // building, so we need to handle each individually (though there
        // is *some* overlap)
        for chip in &args.chips {
            log::debug!("  for chip: {}", chip);
            let device = Config::for_chip(chip);

            if let Err(e) = package.validate_package_chip(chip) {
                log::warn!("{e}. Skipping");
                continue;
            }

            for mut features in package.lint_feature_rules(device) {
                if package.has_chip_features() {
                    features.push(device.name())
                }

                lint_package(
                    workspace,
                    *package,
                    chip,
                    &["--no-default-features"],
                    &features,
                    args.fix,
                    args.toolchain.as_deref(),
                )?;
            }
        }
    }

    Ok(())
}

fn lint_package(
    workspace: &Path,
    package: Package,
    chip: &Chip,
    args: &[&str],
    features: &[String],
    fix: bool,
    mut toolchain: Option<&str>,
) -> Result<()> {
    log::info!(
        "Linting package: {} ({}, features: {:?})",
        package,
        chip,
        features
    );

    let path = workspace.join(package.to_string());

    let mut builder = CargoArgsBuilder::default().subcommand("clippy");

    if !package.build_on_host(features) {
        if chip.is_xtensa() {
            // In case the user doesn't specify a toolchain, make sure we use +esp
            toolchain.get_or_insert("esp");
        }
        builder = builder.target(package.target_triple(chip)?);
    }

    if let Some(toolchain) = toolchain {
        if !package.build_on_host(features) && toolchain.starts_with("esp") {
            builder = builder.config("-Zbuild-std=core,alloc");
        }
        builder = builder.toolchain(toolchain);
    }

    for arg in args {
        builder = builder.arg(arg.to_string());
    }

    if !features.is_empty() {
        builder = builder.arg(format!("--features={}", features.join(",")));
    }

    let builder = if fix {
        builder.arg("--fix").arg("--lib").arg("--allow-dirty")
    } else {
        builder.arg("--").arg("-D").arg("warnings").arg("--no-deps")
    };

    let cargo_args = builder.build();

    xtask::cargo::run_with_env(
        &cargo_args,
        &path,
        [("CI", "1"), ("DEFMT_LOG", "trace")],
        false,
    )
    .with_context(|| {
        format!(
            "Failed to run `cargo run` with {args:?} `CI, `1`, `DEFMT_LOG`, and `trace` envs in {}",
            path.display()
        )
    })?;

    Ok(())
}

struct Runner {
    failed: Vec<&'static str>,
    started_at: Instant,
}

impl Runner {
    fn new() -> Self {
        Self {
            failed: Vec::new(),
            started_at: Instant::now(),
        }
    }

    fn run(&mut self, group: &'static str, op: impl FnOnce() -> Result<()>) {
        // Output grouped logs
        // https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-commands#grouping-log-lines
        println!("::group::{group}");
        if op().is_err() {
            self.failed.push(group);
        }
        println!("::endgroup::");
    }

    fn finish(self) -> Result<()> {
        fn write_summary(message: &str) {
            if let Some(summary_file) = std::env::var_os("GITHUB_STEP_SUMMARY") {
                std::fs::write(summary_file, message).unwrap();
            }
        }

        log::info!("CI checks completed in {:?}", self.started_at.elapsed());

        if !self.failed.is_empty() {
            let mut summary = String::new();
            summary.push_str("# Summary of failed CI checks\n");
            for failed_check in self.failed {
                summary.push_str(&format!("* {failed_check}\n"));
            }
            println!("{summary}");
            write_summary(&summary);
            bail!("CI checks failed");
        }

        Ok(())
    }
}

fn run_ci_checks(workspace: &Path, args: CiArgs) -> Result<()> {
    log::info!("Running CI checks for chip: {}", args.chip);
    println!("::add-matcher::.github/rust-matchers.json");

    let run_locally = !std::env::var("CI").is_ok();

    let mut runner = Runner::new();

    unsafe {
        std::env::set_var("CI", "true");
    }

    if !args.no_check_crates {
        runner.run("Check crates", || {
            check_packages(
                workspace,
                CheckPackagesArgs {
                    packages: Package::iter().collect(),
                    chips: vec![args.chip],
                    toolchain: args.toolchain.clone(),
                },
            )
        });
    }

    if !args.no_lint {
        runner.run("Lint", || {
            lint_packages(
                workspace,
                LintPackagesArgs {
                    packages: Package::iter().collect(),
                    chips: vec![args.chip],
                    fix: false,
                    toolchain: args.toolchain.clone(),
                },
            )
        });
    }

    runner.run("Run Doc Test", || {
        run_doc_tests(
            workspace,
            DocTestArgs {
                packages: Package::iter().collect(),
                chip: args.chip,
            },
        )
    });

    if !args.no_docs {
        runner.run("Build Docs", || {
            build_documentation(
                workspace,
                BuildDocumentationArgs {
                    packages: vec![Package::EspHal, Package::EspRadio, Package::EspRtos],
                    chips: vec![args.chip],
                    ..Default::default()
                },
            )
        });
    }

    // for chips with esp-lp-hal: Build all supported examples for the low-power
    // core first
    if args.chip.has_lp_core() {
        // Build prerequisite examples (esp-lp-hal)
        // `examples` copies the examples to a folder with the chip name as the last
        // path element then we copy it to the place where the HP core example
        // expects it
        runner.run("Build LP-HAL Examples", || {
            // The LP examples aren't really that demanding, but they need to be at a certain place.
            // Instead of trying to figure out where the results are, let's just make sure the
            // target folder is set up as expected.
            let original_target_dir = std::env::var("CARGO_TARGET_DIR");

            unsafe {
                std::env::set_var(
                    "CARGO_TARGET_DIR",
                    workspace.join("esp-lp-hal").join("target"),
                );
            }
            let result = examples(
                workspace,
                ExamplesArgs {
                    package: Package::EspLpHal,
                    chip: Some(args.chip),
                    example: Some("all".to_string()),
                    debug: false,
                    toolchain: args.toolchain.clone(),
                    timings: false,
                },
                CargoAction::Build(None),
            );

            // Still need to rename examples to remove the fingerprint off of their names:
            let dir = workspace
                .join("esp-lp-hal")
                .join("target")
                .join(Package::EspLpHal.target_triple(&args.chip)?)
                .join("release")
                .join("examples");
            let examples = dir
                .read_dir()
                .with_context(|| format!("Failed to read examples directory: {}", dir.display()))?;
            for example in examples {
                let example = example.context("Failed to read example")?;
                if example
                    .file_type()
                    .with_context(|| {
                        format!(
                            "Failed to get file type for example: {}",
                            example.path().display()
                        )
                    })?
                    .is_file()
                    && example.path().extension().is_none()
                {
                    let example_name = example.file_name().to_string_lossy().to_string();
                    let without_fingerprint = example_name
                        .rsplit_once('-')
                        .map(|(a, _)| a)
                        .unwrap_or(&example_name);
                    // Copy so we don't trigger a rebuild unnecessarily by deleting the original
                    std::fs::copy(example.path(), dir.join(without_fingerprint)).with_context(
                        || {
                            format!(
                                "Failed to copy example: {} to {}",
                                example.path().display(),
                                dir.join(without_fingerprint).display()
                            )
                        },
                    )?;
                }
            }

            // Restore the original target directory
            unsafe {
                if let Ok(target) = original_target_dir {
                    std::env::set_var("CARGO_TARGET_DIR", target);
                } else {
                    std::env::remove_var("CARGO_TARGET_DIR");
                }
            }

            result
        });

        if !args.no_docs {
            // Check documentation
            runner.run("Build LP-HAL docs", || {
                build_documentation(
                    workspace,
                    BuildDocumentationArgs {
                        packages: vec![Package::EspLpHal],
                        chips: vec![args.chip],
                        ..Default::default()
                    },
                )
            });
        }
    }

    runner.run("Build examples", || {
        // The `ota_example` expects a file named `examples/target/ota_image` - it
        // doesn't care about the contents however
        std::fs::create_dir_all("./examples/target")
            .with_context(|| format!("Failed to create `./examples/target`"))?;
        std::fs::write("./examples/target/ota_image", "DUMMY")
            .with_context(|| format!("Failed to create a dummy file required by ota example!"))?;

        examples(
            workspace,
            ExamplesArgs {
                package: Package::Examples,
                chip: Some(args.chip),
                example: Some("all".to_string()),
                debug: true,
                toolchain: args.toolchain.clone(),
                timings: false,
            },
            CargoAction::Build(None),
        )
    });

    runner.run("Build qa-test", || {
        examples(
            workspace,
            ExamplesArgs {
                package: Package::QaTest,
                chip: Some(args.chip),
                example: Some("all".to_string()),
                debug: true,
                toolchain: args.toolchain.clone(),
                timings: false,
            },
            CargoAction::Build(None),
        )
    });

    if run_locally {
        // Try-build tests
        runner.run("Build tests", || {
            let target_path = workspace.join("target");

            tests(
                workspace,
                TestsArgs {
                    chip: args.chip,
                    repeat: 1,
                    test: None,
                    toolchain: None,
                    timings: false,
                },
                CargoAction::Build(Some(target_path.join("tests"))),
            )
        });
    }

    runner.finish()
}

fn host_tests(workspace: &Path, args: HostTestsArgs) -> Result<()> {
    let mut packages = args.packages;
    packages.sort();

    for package in packages {
        log::debug!("Running host-tests for package: {}", package);
        if package.has_host_tests(workspace) {
            xtask::run_host_tests(workspace, package)?;
        }
    }

    Ok(())
}

/// Build the given package for the given chip and return its `.rlib path` with `esp` toolchain.
fn build_rlib(package: &str, chip: &str, target: &str) -> Result<PathBuf> {
    let workspace = std::env::current_dir().with_context(|| "Failed to get the current dir!")?;
    Command::new("cargo")
        .args(&[
            "+esp",
            "build",
            "--no-default-features",
            "--features",
            chip,
            "--target",
            target,
            "-Zbuild-std=core",
        ])
        .current_dir(workspace.join(package.to_string()))
        .status()
        .context("Failed to run cargo build")?;

    let lib_name = format!("lib{}.rlib", package.replace('-', "_"));
    let rlib_path = Path::new("target")
        .join(target)
        .join("debug")
        .join(&lib_name);

    if !rlib_path.exists() {
        anyhow::bail!("Expected rlib not found: {}", rlib_path.display());
    }

    Ok(rlib_path)
}

/// Check global symbols in the compiled rlib of the specified packages for the
/// specified chips. Reports any unmangled global symbols that may pollute the
/// global namespace.
fn check_global_symbols(chips: &[Chip]) -> Result<()> {
    let mut total_problematic = vec![];

    let package = Package::EspHal; // Only esp-hal for now

    for chip in chips {
        let target = package.target_triple(chip)?;

        let rlib_path = match build_rlib(&package.to_string(), &chip.to_string(), &target) {
            Ok(path) => path,
            Err(e) => {
                println!(
                    "Failed to build/find rlib for {} on {}: {}",
                    package, chip, e
                );
                continue;
            }
        };

        log::info!("Checking global symbols for {} on {}:\n", package, chip);

        let data = std::fs::read(&rlib_path)
            .with_context(|| format!("Failed to read {}!", rlib_path.display()))?;
        let archive = ArchiveFile::parse(data.as_slice())
            .with_context(|| format!("Failed to create archive!"))?;

        let mut problematic_symbols: Vec<(String, SymbolKind, usize)> = Vec::new();

        for member in archive.members().flatten() {
            let obj = object::File::parse(
                member
                    .data(data.as_slice())
                    .with_context(|| "Failed to parse archive!")?,
            )?;

            for symbol in obj.symbols().filter(|s| s.is_global() && s.is_definition()) {
                if let Ok(name) = symbol.name() {
                    if try_demangle(name).is_err() {
                        let section = symbol.section_index().map(|i| i.0).unwrap_or(0);
                        problematic_symbols.push((name.to_string(), symbol.kind(), section));
                    }
                }
            }
        }

        if problematic_symbols.is_empty() {
            println!("All global symbols are properly mangled Rust symbols\n");
        } else {
            println!(
                "Found {} potentially problematic global symbols:",
                problematic_symbols.len(),
            );

            for (name, kind, _) in &problematic_symbols {
                println!("{:?} {}", kind, name);
            }

            total_problematic.extend(
                problematic_symbols
                    .into_iter()
                    .map(|(name, kind, _)| (chip, name, kind)),
            );
        }
    }

    if !total_problematic.is_empty() {
        for (chip, name, kind) in total_problematic.iter() {
            println!("{}: {} ({:?})", chip, name, kind);
        }
        Err(anyhow::anyhow!(
            "Found {count} unmangled global symbols across all packages/chips",
            count = total_problematic.len()
        ))
    } else {
        Ok(())
    }
}

// ----------------------------------------------------------------------------
// MCP Command Registry

/// Build the MCP command registry.
///
/// Each entry maps a tool name to its Args type (for schema generation and
/// deserialization) and a handler function.  Only commands listed here are
/// exposed via the MCP server â€” this acts as an **allow-list**.
///
/// To add a new MCP-exposed command:
/// 1. Ensure the Args struct derives `serde::Deserialize` and
///    `schemars::JsonSchema` (behind `cfg_attr(feature = "mcp", ...)`).
/// 2. Add a `command!()` entry below.
///
/// Release commands are intentionally excluded.
#[cfg(feature = "mcp")]
fn build_mcp_registry() -> Vec<xtask::mcp::registry::CommandEntry> {
    use xtask::command;

    vec![
        // -- Build commands --------------------------------------------------
        command!(
            "build-documentation",
            "Build documentation for the specified packages and chips",
            BuildDocumentationArgs,
            |workspace, args| build_documentation(workspace, args)
        ),
        command!(
            "build-examples",
            "Build all examples (or a specific example) for a chip. \
             Provide `chip` and optionally `example` (use \"all\" for every example).",
            ExamplesArgs,
            |workspace, args| examples(workspace, args, CargoAction::Build(None))
        ),
        command!(
            "build-package",
            "Build a specific package with the given target, features, and toolchain",
            BuildPackageArgs,
            |workspace, args| build_package(workspace, args)
        ),
        command!(
            "build-tests",
            "Build all applicable tests or a specific test for a chip",
            TestsArgs,
            |workspace, args| {
                let target_path = workspace.join("target");
                tests(workspace, args, CargoAction::Build(Some(target_path.join("tests"))))
            }
        ),
        // -- Run commands ----------------------------------------------------
        command!(
            "run-doc-tests",
            "Run doc-tests for the specified packages and chip",
            DocTestArgs,
            |workspace, args| run_doc_tests(workspace, args)
        ),
        command!(
            "run-elfs",
            "Run ELF binaries from a folder using probe-rs",
            RunElfsArgs,
            |_workspace, args| run_elfs(args)
        ),
        command!(
            "run-tests",
            "Run all applicable tests or a specific test for a chip",
            TestsArgs,
            |workspace, args| tests(workspace, args, CargoAction::Run)
        ),
        // -- Lint / check / format commands ----------------------------------
        command!(
            "ci",
            "Perform (parts of) the checks done in CI for a specific chip",
            CiArgs,
            |workspace, args| run_ci_checks(workspace, args)
        ),
        command!(
            "fmt-packages",
            "Format all packages in the workspace with rustfmt. \
             Set `check: true` for check-only mode.",
            FmtPackagesArgs,
            |workspace, args| fmt_packages(workspace, args)
        ),
        command!(
            "clean",
            "Run cargo clean for the specified packages",
            CleanArgs,
            |workspace, args| clean(workspace, args)
        ),
        command!(
            "check-packages",
            "Check all packages with `cargo check` for the specified chips",
            CheckPackagesArgs,
            |workspace, args| check_packages(workspace, args)
        ),
        command!(
            "lint-packages",
            "Lint all packages with clippy for the specified chips. \
             Set `fix: true` to auto-apply fixes.",
            LintPackagesArgs,
            |workspace, args| lint_packages(workspace, args)
        ),
        command!(
            "check-changelog",
            "Check the changelog for the specified packages. \
             Set `normalize: true` to rewrite with consistent formatting.",
            CheckChangelogArgs,
            |workspace, args| check_changelog(workspace, &args.packages, args.normalize)
        ),
        command!(
            "update-metadata",
            "Re-generate metadata and the chip support table in the esp-hal README. \
             Set `check: true` for check-only mode.",
            UpdateMetadataArgs,
            |workspace, args| update_metadata(workspace, args.check)
        ),
        command!(
            "host-tests",
            "Run host-tests in the workspace with `cargo test`",
            HostTestsArgs,
            |workspace, args| host_tests(workspace, args)
        ),
        command!(
            "check-global-symbols",
            "Check global symbols in compiled `.rlib` files for unmangled names",
            CheckPackagesArgs,
            |_workspace, args| check_global_symbols(&args.chips)
        ),
    ]
}
